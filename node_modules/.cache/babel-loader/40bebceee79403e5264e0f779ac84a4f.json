{"ast":null,"code":"// see https://github.com/fiji/Auto_Threshold/blob/master/src/main/java/fiji/threshold/Auto_Threshold.java\n// Shanhbag A.G. (1994) \"Utilization of Information Measure as a Means of\n// Image Thresholding\" Graphical Models and Image Processing, 56(5): 414-419\n// Ported to ImageJ plugin by G.Landini from E Celebi's fourier_0.8 routines\nexport default function shanbhag(histogram, total) {\n  let normHisto = new Array(histogram.length); // normalized histogram\n\n  for (let ih = 0; ih < histogram.length; ih++) {\n    normHisto[ih] = histogram[ih] / total;\n  }\n\n  let P1 = new Array(histogram.length); // cumulative normalized histogram\n\n  let P2 = new Array(histogram.length);\n  P1[0] = normHisto[0];\n  P2[0] = 1.0 - P1[0];\n\n  for (let ih = 1; ih < histogram.length; ih++) {\n    P1[ih] = P1[ih - 1] + normHisto[ih];\n    P2[ih] = 1.0 - P1[ih];\n  }\n  /* Determine the first non-zero bin */\n\n\n  let firstBin = 0;\n\n  for (let ih = 0; ih < histogram.length; ih++) {\n    if (Math.abs(P1[ih]) >= Number.EPSILON) {\n      firstBin = ih;\n      break;\n    }\n  }\n  /* Determine the last non-zero bin */\n\n\n  let lastBin = histogram.length - 1;\n\n  for (let ih = histogram.length - 1; ih >= firstBin; ih--) {\n    if (Math.abs(P2[ih]) >= Number.EPSILON) {\n      lastBin = ih;\n      break;\n    }\n  } // Calculate the total entropy each gray-level\n  // and find the threshold that maximizes it\n\n\n  let threshold = -1;\n  let minEnt = Number.MAX_VALUE; // min entropy\n\n  let term;\n  let totEnt; // total entropy\n\n  let entBack; // entropy of the background pixels at a given threshold\n\n  let entObj; // entropy of the object pixels at a given threshold\n\n  for (let it = firstBin; it <= lastBin; it++) {\n    /* Entropy of the background pixels */\n    entBack = 0.0;\n    term = 0.5 / P1[it];\n\n    for (let ih = 1; ih <= it; ih++) {\n      entBack -= normHisto[ih] * Math.log(1.0 - term * P1[ih - 1]);\n    }\n\n    entBack *= term;\n    /* Entropy of the object pixels */\n\n    entObj = 0.0;\n    term = 0.5 / P2[it];\n\n    for (let ih = it + 1; ih < histogram.length; ih++) {\n      entObj -= normHisto[ih] * Math.log(1.0 - term * P2[ih]);\n    }\n\n    entObj *= term;\n    /* Total entropy */\n\n    totEnt = Math.abs(entBack - entObj);\n\n    if (totEnt < minEnt) {\n      minEnt = totEnt;\n      threshold = it;\n    }\n  }\n\n  return threshold;\n}","map":{"version":3,"sources":["C:/Users/kuent/Documents/FinishDipshit/Creative/Ocean-Weather-Visualization/node_modules/image-js/src/image/transform/mask/shanbhag.js"],"names":["shanbhag","histogram","total","normHisto","Array","length","ih","P1","P2","firstBin","Math","abs","Number","EPSILON","lastBin","threshold","minEnt","MAX_VALUE","term","totEnt","entBack","entObj","it","log"],"mappings":"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","sourcesContent":["// see https://github.com/fiji/Auto_Threshold/blob/master/src/main/java/fiji/threshold/Auto_Threshold.java\n// Shanhbag A.G. (1994) \"Utilization of Information Measure as a Means of\n// Image Thresholding\" Graphical Models and Image Processing, 56(5): 414-419\n// Ported to ImageJ plugin by G.Landini from E Celebi's fourier_0.8 routines\n\nexport default function shanbhag(histogram, total) {\n  let normHisto = new Array(histogram.length); // normalized histogram\n  for (let ih = 0; ih < histogram.length; ih++) {\n    normHisto[ih] = histogram[ih] / total;\n  }\n\n  let P1 = new Array(histogram.length); // cumulative normalized histogram\n  let P2 = new Array(histogram.length);\n  P1[0] = normHisto[0];\n  P2[0] = 1.0 - P1[0];\n  for (let ih = 1; ih < histogram.length; ih++) {\n    P1[ih] = P1[ih - 1] + normHisto[ih];\n    P2[ih] = 1.0 - P1[ih];\n  }\n\n  /* Determine the first non-zero bin */\n  let firstBin = 0;\n  for (let ih = 0; ih < histogram.length; ih++) {\n    if (Math.abs(P1[ih]) >= Number.EPSILON) {\n      firstBin = ih;\n      break;\n    }\n  }\n\n  /* Determine the last non-zero bin */\n  let lastBin = histogram.length - 1;\n  for (let ih = histogram.length - 1; ih >= firstBin; ih--) {\n    if (Math.abs(P2[ih]) >= Number.EPSILON) {\n      lastBin = ih;\n      break;\n    }\n  }\n\n  // Calculate the total entropy each gray-level\n  // and find the threshold that maximizes it\n  let threshold = -1;\n  let minEnt = Number.MAX_VALUE; // min entropy\n\n  let term;\n  let totEnt; // total entropy\n  let entBack; // entropy of the background pixels at a given threshold\n  let entObj; // entropy of the object pixels at a given threshold\n  for (let it = firstBin; it <= lastBin; it++) {\n    /* Entropy of the background pixels */\n    entBack = 0.0;\n    term = 0.5 / P1[it];\n    for (let ih = 1; ih <= it; ih++) {\n      entBack -= normHisto[ih] * Math.log(1.0 - term * P1[ih - 1]);\n    }\n    entBack *= term;\n\n    /* Entropy of the object pixels */\n    entObj = 0.0;\n    term = 0.5 / P2[it];\n    for (let ih = it + 1; ih < histogram.length; ih++) {\n      entObj -= normHisto[ih] * Math.log(1.0 - term * P2[ih]);\n    }\n    entObj *= term;\n\n    /* Total entropy */\n    totEnt = Math.abs(entBack - entObj);\n\n    if (totEnt < minEnt) {\n      minEnt = totEnt;\n      threshold = it;\n    }\n  }\n  return threshold;\n}\n"]},"metadata":{},"sourceType":"module"}