{"ast":null,"code":"/**\n * Apply a gaussian filter to the image.\n * @memberof Image\n * @instance\n * @param {object} options\n * @param {number} [options.radius=1] - Number of pixels around the current pixel.\n * @param {number} [options.sigma] - Sigma parameter for the gaussian.\n * @param {number[]|string[]} [options.channels] - To which channel to apply the filter.\n * @param {string} [options.border='copy']\n * @return {Image}\n */\nexport default function gaussianFilter(options = {}) {\n  let {\n    radius = 1,\n    sigma,\n    channels,\n    border = 'copy'\n  } = options;\n  this.checkProcessable('gaussian', {\n    bitDepth: [8, 16]\n  });\n  const kernel = getKernel(radius, sigma);\n  return this.convolution([kernel, kernel], {\n    border,\n    channels,\n    algorithm: 'separable'\n  });\n}\n\nfunction getKernel(radius, sigma) {\n  const n = radius * 2 + 1;\n  const kernel = new Array(n);\n  const sigmaX = sigma ? sigma : ((n - 1) * 0.5 - 1) * 0.3 + 0.8;\n  const scale2X = -0.5 / (sigmaX * sigmaX);\n  let sum = 0;\n\n  for (let i = 0; i < n; i++) {\n    const x = i - radius;\n    const t = Math.exp(scale2X * x * x);\n    kernel[i] = t;\n    sum += t;\n  }\n\n  for (let i = 0; i < n; i++) {\n    kernel[i] /= sum;\n  }\n\n  return kernel;\n}","map":{"version":3,"sources":["C:/Users/kuent/Documents/FinishDipshit/Creative/Ocean-Weather-Visualization/node_modules/image-js/src/image/filter/gaussianFilter.js"],"names":["gaussianFilter","options","radius","sigma","channels","border","checkProcessable","bitDepth","kernel","getKernel","convolution","algorithm","n","Array","sigmaX","scale2X","sum","i","x","t","Math","exp"],"mappings":"AAAA;;;;;;;;;;;AAWA,eAAe,SAASA,cAAT,CAAwBC,OAAO,GAAG,EAAlC,EAAsC;AACnD,MAAI;AAAEC,IAAAA,MAAM,GAAG,CAAX;AAAcC,IAAAA,KAAd;AAAqBC,IAAAA,QAArB;AAA+BC,IAAAA,MAAM,GAAG;AAAxC,MAAmDJ,OAAvD;AAEA,OAAKK,gBAAL,CAAsB,UAAtB,EAAkC;AAChCC,IAAAA,QAAQ,EAAE,CAAC,CAAD,EAAI,EAAJ;AADsB,GAAlC;AAIA,QAAMC,MAAM,GAAGC,SAAS,CAACP,MAAD,EAASC,KAAT,CAAxB;AACA,SAAO,KAAKO,WAAL,CAAiB,CAACF,MAAD,EAASA,MAAT,CAAjB,EAAmC;AACxCH,IAAAA,MADwC;AAExCD,IAAAA,QAFwC;AAGxCO,IAAAA,SAAS,EAAE;AAH6B,GAAnC,CAAP;AAKD;;AAED,SAASF,SAAT,CAAmBP,MAAnB,EAA2BC,KAA3B,EAAkC;AAChC,QAAMS,CAAC,GAAGV,MAAM,GAAG,CAAT,GAAa,CAAvB;AACA,QAAMM,MAAM,GAAG,IAAIK,KAAJ,CAAUD,CAAV,CAAf;AACA,QAAME,MAAM,GAAGX,KAAK,GAAGA,KAAH,GAAW,CAAC,CAACS,CAAC,GAAG,CAAL,IAAU,GAAV,GAAgB,CAAjB,IAAsB,GAAtB,GAA4B,GAA3D;AACA,QAAMG,OAAO,GAAG,CAAC,GAAD,IAAQD,MAAM,GAAGA,MAAjB,CAAhB;AACA,MAAIE,GAAG,GAAG,CAAV;;AACA,OAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGL,CAApB,EAAuBK,CAAC,EAAxB,EAA4B;AAC1B,UAAMC,CAAC,GAAGD,CAAC,GAAGf,MAAd;AACA,UAAMiB,CAAC,GAAGC,IAAI,CAACC,GAAL,CAASN,OAAO,GAAGG,CAAV,GAAcA,CAAvB,CAAV;AACAV,IAAAA,MAAM,CAACS,CAAD,CAAN,GAAYE,CAAZ;AACAH,IAAAA,GAAG,IAAIG,CAAP;AACD;;AAED,OAAK,IAAIF,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGL,CAApB,EAAuBK,CAAC,EAAxB,EAA4B;AAC1BT,IAAAA,MAAM,CAACS,CAAD,CAAN,IAAaD,GAAb;AACD;;AACD,SAAOR,MAAP;AACD","sourcesContent":["/**\n * Apply a gaussian filter to the image.\n * @memberof Image\n * @instance\n * @param {object} options\n * @param {number} [options.radius=1] - Number of pixels around the current pixel.\n * @param {number} [options.sigma] - Sigma parameter for the gaussian.\n * @param {number[]|string[]} [options.channels] - To which channel to apply the filter.\n * @param {string} [options.border='copy']\n * @return {Image}\n */\nexport default function gaussianFilter(options = {}) {\n  let { radius = 1, sigma, channels, border = 'copy' } = options;\n\n  this.checkProcessable('gaussian', {\n    bitDepth: [8, 16],\n  });\n\n  const kernel = getKernel(radius, sigma);\n  return this.convolution([kernel, kernel], {\n    border,\n    channels,\n    algorithm: 'separable',\n  });\n}\n\nfunction getKernel(radius, sigma) {\n  const n = radius * 2 + 1;\n  const kernel = new Array(n);\n  const sigmaX = sigma ? sigma : ((n - 1) * 0.5 - 1) * 0.3 + 0.8;\n  const scale2X = -0.5 / (sigmaX * sigmaX);\n  let sum = 0;\n  for (let i = 0; i < n; i++) {\n    const x = i - radius;\n    const t = Math.exp(scale2X * x * x);\n    kernel[i] = t;\n    sum += t;\n  }\n\n  for (let i = 0; i < n; i++) {\n    kernel[i] /= sum;\n  }\n  return kernel;\n}\n"]},"metadata":{},"sourceType":"module"}