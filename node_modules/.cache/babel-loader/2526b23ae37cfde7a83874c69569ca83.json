{"ast":null,"code":"const defaultOptions = {\n  lowThreshold: 10,\n  highThreshold: 30,\n  gaussianBlur: 1.1\n};\nconst Gx = [[-1, 0, +1], [-2, 0, +2], [-1, 0, +1]];\nconst Gy = [[-1, -2, -1], [0, 0, 0], [+1, +2, +1]];\nconst convOptions = {\n  bitDepth: 32,\n  mode: 'periodic'\n};\nexport default function cannyEdgeDetector(image, options) {\n  image.checkProcessable('Canny edge detector', {\n    bitDepth: 8,\n    channels: 1,\n    components: 1\n  });\n  options = Object.assign({}, defaultOptions, options);\n  const width = image.width;\n  const height = image.height;\n  const brightness = image.maxValue;\n  const gfOptions = {\n    sigma: options.gaussianBlur,\n    radius: 3\n  };\n  const gf = image.gaussianFilter(gfOptions);\n  const gradientX = gf.convolution(Gy, convOptions);\n  const gradientY = gf.convolution(Gx, convOptions);\n  const G = gradientY.hypotenuse(gradientX);\n  const Image = image.constructor;\n  const nms = new Image(width, height, {\n    kind: 'GREY',\n    bitDepth: 32\n  });\n  const edges = new Image(width, height, {\n    kind: 'GREY',\n    bitDepth: 32\n  });\n  const finalImage = new Image(width, height, {\n    kind: 'GREY'\n  }); // Non-Maximum supression\n\n  for (var i = 1; i < width - 1; i++) {\n    for (var j = 1; j < height - 1; j++) {\n      var dir = (Math.round(Math.atan2(gradientY.getValueXY(i, j, 0), gradientX.getValueXY(i, j, 0)) * (5.0 / Math.PI)) + 5) % 5;\n\n      if (!(dir === 0 && (G.getValueXY(i, j, 0) <= G.getValueXY(i, j - 1, 0) || G.getValueXY(i, j, 0) <= G.getValueXY(i, j + 1, 0)) || dir === 1 && (G.getValueXY(i, j, 0) <= G.getValueXY(i - 1, j + 1, 0) || G.getValueXY(i, j, 0) <= G.getValueXY(i + 1, j - 1, 0)) || dir === 2 && (G.getValueXY(i, j, 0) <= G.getValueXY(i - 1, j, 0) || G.getValueXY(i, j, 0) <= G.getValueXY(i + 1, j, 0)) || dir === 3 && (G.getValueXY(i, j, 0) <= G.getValueXY(i - 1, j - 1, 0) || G.getValueXY(i, j, 0) <= G.getValueXY(i + 1, j + 1, 0)))) {\n        nms.setValueXY(i, j, 0, G.getValueXY(i, j, 0));\n      }\n    }\n  }\n\n  for (i = 0; i < width * height; ++i) {\n    var currentNms = nms.data[i];\n    var currentEdge = 0;\n\n    if (currentNms > options.highThreshold) {\n      currentEdge++;\n      finalImage.data[i] = brightness;\n    }\n\n    if (currentNms > options.lowThreshold) {\n      currentEdge++;\n    }\n\n    edges.data[i] = currentEdge;\n  } // Hysteresis: first pass\n\n\n  var currentPixels = [];\n\n  for (i = 1; i < width - 1; ++i) {\n    for (j = 1; j < height - 1; ++j) {\n      if (edges.getValueXY(i, j, 0) !== 1) {\n        continue;\n      }\n\n      outer: for (var k = i - 1; k < i + 2; ++k) {\n        for (var l = j - 1; l < j + 2; ++l) {\n          if (edges.getValueXY(k, l, 0) === 2) {\n            currentPixels.push([i, j]);\n            finalImage.setValueXY(i, j, 0, brightness);\n            break outer;\n          }\n        }\n      }\n    }\n  } // Hysteresis: second pass\n\n\n  while (currentPixels.length > 0) {\n    var newPixels = [];\n\n    for (i = 0; i < currentPixels.length; ++i) {\n      for (j = -1; j < 2; ++j) {\n        for (k = -1; k < 2; ++k) {\n          if (j === 0 && k === 0) {\n            continue;\n          }\n\n          var row = currentPixels[i][0] + j;\n          var col = currentPixels[i][1] + k;\n\n          if (edges.getValueXY(row, col, 0) === 1 && finalImage.getValueXY(row, col, 0) === 0) {\n            newPixels.push([row, col]);\n            finalImage.setValueXY(row, col, 0, brightness);\n          }\n        }\n      }\n    }\n\n    currentPixels = newPixels;\n  }\n\n  return finalImage;\n}","map":{"version":3,"sources":["C:/Users/kuent/Documents/FinishDipshit/Creative/Ocean-Weather-Visualization/node_modules/canny-edge-detector/src/index.js"],"names":["defaultOptions","lowThreshold","highThreshold","gaussianBlur","Gx","Gy","convOptions","bitDepth","mode","cannyEdgeDetector","image","options","checkProcessable","channels","components","Object","assign","width","height","brightness","maxValue","gfOptions","sigma","radius","gf","gaussianFilter","gradientX","convolution","gradientY","G","hypotenuse","Image","constructor","nms","kind","edges","finalImage","i","j","dir","Math","round","atan2","getValueXY","PI","setValueXY","currentNms","data","currentEdge","currentPixels","outer","k","l","push","length","newPixels","row","col"],"mappings":"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","sourcesContent":["const defaultOptions = {\n    lowThreshold: 10,\n    highThreshold: 30,\n    gaussianBlur: 1.1\n};\n\nconst Gx = [\n    [-1, 0, +1],\n    [-2, 0, +2],\n    [-1, 0, +1]\n];\n\nconst Gy = [\n    [-1, -2, -1],\n    [0, 0, 0],\n    [+1, +2, +1]\n];\n\nconst convOptions = {\n    bitDepth: 32,\n    mode: 'periodic'\n};\n\nexport default function cannyEdgeDetector(image, options) {\n    image.checkProcessable('Canny edge detector', {\n        bitDepth: 8,\n        channels: 1,\n        components: 1\n    });\n\n    options = Object.assign({}, defaultOptions, options);\n\n    const width = image.width;\n    const height = image.height;\n    const brightness = image.maxValue;\n\n    const gfOptions = {\n        sigma: options.gaussianBlur,\n        radius: 3\n    };\n\n    const gf = image.gaussianFilter(gfOptions);\n\n    const gradientX = gf.convolution(Gy, convOptions);\n    const gradientY = gf.convolution(Gx, convOptions);\n\n    const G = gradientY.hypotenuse(gradientX);\n\n    const Image = image.constructor;\n\n    const nms = new Image(width, height, {\n        kind: 'GREY',\n        bitDepth: 32\n    });\n\n    const edges = new Image(width, height, {\n        kind: 'GREY',\n        bitDepth: 32\n    });\n\n    const finalImage = new Image(width, height, {\n        kind: 'GREY'\n    });\n\n    // Non-Maximum supression\n    for (var i = 1; i < width - 1; i++) {\n        for (var j = 1; j < height - 1; j++) {\n\n            var dir = (Math.round(Math.atan2(gradientY.getValueXY(i, j, 0), gradientX.getValueXY(i, j, 0)) * (5.0 / Math.PI)) + 5) % 5;\n\n            if (\n                !((dir === 0 && (G.getValueXY(i, j, 0) <= G.getValueXY(i, j - 1, 0) || G.getValueXY(i, j, 0) <= G.getValueXY(i, j + 1, 0)))\n                    || (dir === 1 && (G.getValueXY(i, j, 0) <= G.getValueXY(i - 1, j + 1, 0) || G.getValueXY(i, j, 0) <= G.getValueXY(i + 1, j - 1, 0)))\n                    || (dir === 2 && (G.getValueXY(i, j, 0) <= G.getValueXY(i - 1, j, 0) || G.getValueXY(i, j, 0) <= G.getValueXY(i + 1, j, 0)))\n                    || (dir === 3 && (G.getValueXY(i, j, 0) <= G.getValueXY(i - 1, j - 1, 0) || G.getValueXY(i, j, 0) <= G.getValueXY(i + 1, j + 1, 0))))\n            ) {\n                nms.setValueXY(i, j, 0, G.getValueXY(i, j, 0));\n            }\n        }\n    }\n\n    for (i = 0; i < width * height; ++i) {\n        var currentNms = nms.data[i];\n        var currentEdge = 0;\n        if (currentNms > options.highThreshold) {\n            currentEdge++;\n            finalImage.data[i] = brightness;\n        }\n        if (currentNms > options.lowThreshold) {\n            currentEdge++;\n        }\n\n        edges.data[i] = currentEdge;\n    }\n\n    // Hysteresis: first pass\n    var currentPixels = [];\n    for (i = 1; i < width - 1; ++i) {\n        for (j = 1; j < height - 1; ++j) {\n            if (edges.getValueXY(i, j, 0) !== 1) {\n                continue;\n            }\n\n            outer: for (var k = i - 1; k < i + 2; ++k) {\n                for (var l = j - 1; l < j + 2; ++l) {\n                    if (edges.getValueXY(k, l, 0) === 2) {\n                        currentPixels.push([i, j]);\n                        finalImage.setValueXY(i, j, 0, brightness);\n                        break outer;\n                    }\n                }\n            }\n        }\n    }\n\n    // Hysteresis: second pass\n    while (currentPixels.length > 0) {\n        var newPixels = [];\n        for (i = 0; i < currentPixels.length; ++i) {\n            for (j = -1; j < 2; ++j) {\n                for (k = -1; k < 2; ++k) {\n                    if (j === 0 && k === 0) {\n                        continue;\n                    }\n                    var row = currentPixels[i][0] + j;\n                    var col = currentPixels[i][1] + k;\n                    if (edges.getValueXY(row, col, 0) === 1 && finalImage.getValueXY(row, col, 0) === 0) {\n                        newPixels.push([row, col]);\n                        finalImage.setValueXY(row, col, 0, brightness);\n                    }\n                }\n            }\n        }\n        currentPixels = newPixels;\n    }\n\n    return finalImage;\n}\n"]},"metadata":{},"sourceType":"module"}