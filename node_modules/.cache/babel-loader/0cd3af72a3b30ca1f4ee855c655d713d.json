{"ast":null,"code":"import array from 'new-array';\n/**\n * This method will change the border\n * @memberof Image\n * @instance\n * @param {object} [options]\n * @param {number} [options.size=0]\n * @param {string} [options.algorithm='copy']\n * @param {number[]} [options.color]\n * @return {this}\n */\n\nexport default function setBorder(options = {}) {\n  let {\n    size = 0,\n    algorithm = 'copy',\n    color\n  } = options;\n  this.checkProcessable('setBorder', {\n    bitDepth: [8, 16, 32, 64]\n  });\n\n  if (algorithm === 'set') {\n    if (color.length !== this.channels) {\n      throw new Error(`setBorder: the color array must have the same length as the number of channels. Here: ${this.channels}`);\n    }\n\n    for (let i = 0; i < color.length; i++) {\n      if (color[i] === 0) {\n        color[i] = 0.001;\n      }\n    }\n  } else {\n    color = array(this.channels, null);\n  }\n\n  if (!Array.isArray(size)) {\n    size = [size, size];\n  }\n\n  let leftRightSize = size[0];\n  let topBottomSize = size[1];\n  let channels = this.channels;\n\n  for (let i = leftRightSize; i < this.width - leftRightSize; i++) {\n    for (let k = 0; k < channels; k++) {\n      let value = color[k] || this.data[(i + this.width * topBottomSize) * channels + k];\n\n      for (let j = 0; j < topBottomSize; j++) {\n        this.data[(j * this.width + i) * channels + k] = value;\n      }\n\n      value = color[k] || this.data[(i + this.width * (this.height - topBottomSize - 1)) * channels + k];\n\n      for (let j = this.height - topBottomSize; j < this.height; j++) {\n        this.data[(j * this.width + i) * channels + k] = value;\n      }\n    }\n  }\n\n  for (let j = 0; j < this.height; j++) {\n    for (let k = 0; k < channels; k++) {\n      let value = color[k] || this.data[(j * this.width + leftRightSize) * channels + k];\n\n      for (let i = 0; i < leftRightSize; i++) {\n        this.data[(j * this.width + i) * channels + k] = value;\n      }\n\n      value = color[k] || this.data[(j * this.width + this.width - leftRightSize - 1) * channels + k];\n\n      for (let i = this.width - leftRightSize; i < this.width; i++) {\n        this.data[(j * this.width + i) * channels + k] = value;\n      }\n    }\n  }\n\n  return this;\n}","map":{"version":3,"sources":["C:/Users/kuent/Documents/FinishDipshit/Creative/Ocean-Weather-Visualization/node_modules/image-js/src/image/utility/setBorder.js"],"names":["array","setBorder","options","size","algorithm","color","checkProcessable","bitDepth","length","channels","Error","i","Array","isArray","leftRightSize","topBottomSize","width","k","value","data","j","height"],"mappings":"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","sourcesContent":["import array from 'new-array';\n\n/**\n * This method will change the border\n * @memberof Image\n * @instance\n * @param {object} [options]\n * @param {number} [options.size=0]\n * @param {string} [options.algorithm='copy']\n * @param {number[]} [options.color]\n * @return {this}\n */\nexport default function setBorder(options = {}) {\n  let { size = 0, algorithm = 'copy', color } = options;\n\n  this.checkProcessable('setBorder', {\n    bitDepth: [8, 16, 32, 64],\n  });\n\n  if (algorithm === 'set') {\n    if (color.length !== this.channels) {\n      throw new Error(\n        `setBorder: the color array must have the same length as the number of channels. Here: ${this.channels}`,\n      );\n    }\n    for (let i = 0; i < color.length; i++) {\n      if (color[i] === 0) {\n        color[i] = 0.001;\n      }\n    }\n  } else {\n    color = array(this.channels, null);\n  }\n\n  if (!Array.isArray(size)) {\n    size = [size, size];\n  }\n\n  let leftRightSize = size[0];\n  let topBottomSize = size[1];\n  let channels = this.channels;\n\n  for (let i = leftRightSize; i < this.width - leftRightSize; i++) {\n    for (let k = 0; k < channels; k++) {\n      let value =\n        color[k] || this.data[(i + this.width * topBottomSize) * channels + k];\n      for (let j = 0; j < topBottomSize; j++) {\n        this.data[(j * this.width + i) * channels + k] = value;\n      }\n      value =\n        color[k] ||\n        this.data[\n          (i + this.width * (this.height - topBottomSize - 1)) * channels + k\n        ];\n      for (let j = this.height - topBottomSize; j < this.height; j++) {\n        this.data[(j * this.width + i) * channels + k] = value;\n      }\n    }\n  }\n\n  for (let j = 0; j < this.height; j++) {\n    for (let k = 0; k < channels; k++) {\n      let value =\n        color[k] || this.data[(j * this.width + leftRightSize) * channels + k];\n      for (let i = 0; i < leftRightSize; i++) {\n        this.data[(j * this.width + i) * channels + k] = value;\n      }\n      value =\n        color[k] ||\n        this.data[\n          (j * this.width + this.width - leftRightSize - 1) * channels + k\n        ];\n      for (let i = this.width - leftRightSize; i < this.width; i++) {\n        this.data[(j * this.width + i) * channels + k] = value;\n      }\n    }\n  }\n\n  return this;\n}\n"]},"metadata":{},"sourceType":"module"}