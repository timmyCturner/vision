{"ast":null,"code":"/**\n * In place modification of the roiMap that joins regions of interest\n * @param {object} [options]\n * @param {string|function(object,number,number)} [options.algorithm='commonBorderLength'] algorithm used to decide which ROIs are merged.\n *      Current implemented algorithms are 'commonBorderLength' that use the parameters\n *      'minCommonBorderLength' and 'maxCommonBorderLength' as well as 'commonBorderRatio' that uses\n *      the parameters 'minCommonBorderRatio' and 'maxCommonBorderRatio'.\n * @param {number} [options.minCommonBorderLength=5] minimal common number of pixels for merging\n * @param {number} [options.maxCommonBorderLength=100] maximal common number of pixels for merging\n * @param {number} [options.minCommonBorderRatio=0.3] minimal common border ratio for merging\n * @param {number} [options.maxCommonBorderRatio=1] maximal common border ratio for merging\n * @return {this}\n * @private\n */\nexport default function mergeRoi(options = {}) {\n  const {\n    algorithm = 'commonBorderLength',\n    minCommonBorderLength = 5,\n    maxCommonBorderLength = 100,\n    minCommonBorderRatio = 0.3,\n    maxCommonBorderRatio = 1\n  } = options;\n\n  let checkFunction = function (currentInfo, currentID, neighbourID) {\n    return currentInfo[neighbourID] >= minCommonBorderLength && currentInfo[neighbourID] <= maxCommonBorderLength;\n  };\n\n  if (typeof algorithm === 'function') {\n    checkFunction = algorithm;\n  }\n\n  if (algorithm.toLowerCase() === 'commonborderratio') {\n    checkFunction = function (currentInfo, currentID, neighbourID) {\n      let ratio = Math.min(currentInfo[neighbourID] / currentInfo[currentID], 1);\n      return ratio >= minCommonBorderRatio && ratio <= maxCommonBorderRatio;\n    };\n  }\n\n  const roiMap = this;\n  const borderLengths = roiMap.commonBorderLength;\n  let newMap = {};\n  let oldToNew = {};\n\n  for (let currentID of Object.keys(borderLengths)) {\n    let currentInfo = borderLengths[currentID];\n    let neighbourIDs = Object.keys(currentInfo);\n\n    for (let neighbourID of neighbourIDs) {\n      if (neighbourID !== currentID) {\n        // it is not myself ...\n        if (checkFunction(currentInfo, currentID, neighbourID)) {\n          // the common border are in the range. We should merge\n          let newNeighbourID = neighbourID;\n          if (oldToNew[neighbourID]) newNeighbourID = oldToNew[neighbourID];\n          let newCurrentID = currentID;\n          if (oldToNew[currentID]) newCurrentID = oldToNew[currentID];\n\n          if (Number(newNeighbourID) !== newCurrentID) {\n            let smallerID = Math.min(newNeighbourID, newCurrentID);\n            let largerID = Math.max(newNeighbourID, newCurrentID);\n\n            if (!newMap[smallerID]) {\n              newMap[smallerID] = {};\n            }\n\n            newMap[smallerID][largerID] = true;\n            oldToNew[largerID] = smallerID;\n\n            if (newMap[largerID]) {\n              // need to put everything to smallerID and remove property\n              for (let id of Object.keys(newMap[largerID])) {\n                newMap[smallerID][id] = true;\n                oldToNew[id] = smallerID;\n              }\n\n              delete newMap[largerID];\n            }\n          }\n        }\n      }\n    }\n  }\n\n  let minMax = roiMap.minMax;\n  let shift = -minMax.min;\n  let max = minMax.max + shift;\n  let oldToNewArray = new Array(max + 1).fill(0);\n\n  for (let key of Object.keys(oldToNew)) {\n    oldToNewArray[Number(key) + shift] = oldToNew[key];\n  } // time to change the roiMap\n\n\n  let data = roiMap.data;\n\n  for (let i = 0; i < data.length; i++) {\n    let currentValue = data[i];\n\n    if (currentValue !== 0) {\n      let newValue = oldToNewArray[currentValue + shift];\n\n      if (newValue !== 0) {\n        data[i] = newValue;\n      }\n    }\n  }\n\n  roiMap.computed = {};\n  return roiMap;\n}","map":{"version":3,"sources":["C:/Users/kuent/Documents/FinishDipshit/Creative/Ocean-Weather-Visualization/node_modules/image-js/src/image/roi/util/mergeRoi.js"],"names":["mergeRoi","options","algorithm","minCommonBorderLength","maxCommonBorderLength","minCommonBorderRatio","maxCommonBorderRatio","checkFunction","currentInfo","currentID","neighbourID","toLowerCase","ratio","Math","min","roiMap","borderLengths","commonBorderLength","newMap","oldToNew","Object","keys","neighbourIDs","newNeighbourID","newCurrentID","Number","smallerID","largerID","max","id","minMax","shift","oldToNewArray","Array","fill","key","data","i","length","currentValue","newValue","computed"],"mappings":"AAAA;;;;;;;;;;;;;;AAcA,eAAe,SAASA,QAAT,CAAkBC,OAAO,GAAG,EAA5B,EAAgC;AAC7C,QAAM;AACJC,IAAAA,SAAS,GAAG,oBADR;AAEJC,IAAAA,qBAAqB,GAAG,CAFpB;AAGJC,IAAAA,qBAAqB,GAAG,GAHpB;AAIJC,IAAAA,oBAAoB,GAAG,GAJnB;AAKJC,IAAAA,oBAAoB,GAAG;AALnB,MAMFL,OANJ;;AAQA,MAAIM,aAAa,GAAG,UAAUC,WAAV,EAAuBC,SAAvB,EAAkCC,WAAlC,EAA+C;AACjE,WACEF,WAAW,CAACE,WAAD,CAAX,IAA4BP,qBAA5B,IACAK,WAAW,CAACE,WAAD,CAAX,IAA4BN,qBAF9B;AAID,GALD;;AAMA,MAAI,OAAOF,SAAP,KAAqB,UAAzB,EAAqC;AACnCK,IAAAA,aAAa,GAAGL,SAAhB;AACD;;AACD,MAAIA,SAAS,CAACS,WAAV,OAA4B,mBAAhC,EAAqD;AACnDJ,IAAAA,aAAa,GAAG,UAAUC,WAAV,EAAuBC,SAAvB,EAAkCC,WAAlC,EAA+C;AAC7D,UAAIE,KAAK,GAAGC,IAAI,CAACC,GAAL,CACVN,WAAW,CAACE,WAAD,CAAX,GAA2BF,WAAW,CAACC,SAAD,CAD5B,EAEV,CAFU,CAAZ;AAIA,aAAOG,KAAK,IAAIP,oBAAT,IAAiCO,KAAK,IAAIN,oBAAjD;AACD,KAND;AAOD;;AACD,QAAMS,MAAM,GAAG,IAAf;AACA,QAAMC,aAAa,GAAGD,MAAM,CAACE,kBAA7B;AACA,MAAIC,MAAM,GAAG,EAAb;AACA,MAAIC,QAAQ,GAAG,EAAf;;AAEA,OAAK,IAAIV,SAAT,IAAsBW,MAAM,CAACC,IAAP,CAAYL,aAAZ,CAAtB,EAAkD;AAChD,QAAIR,WAAW,GAAGQ,aAAa,CAACP,SAAD,CAA/B;AACA,QAAIa,YAAY,GAAGF,MAAM,CAACC,IAAP,CAAYb,WAAZ,CAAnB;;AACA,SAAK,IAAIE,WAAT,IAAwBY,YAAxB,EAAsC;AACpC,UAAIZ,WAAW,KAAKD,SAApB,EAA+B;AAC7B;AACA,YAAIF,aAAa,CAACC,WAAD,EAAcC,SAAd,EAAyBC,WAAzB,CAAjB,EAAwD;AACtD;AACA,cAAIa,cAAc,GAAGb,WAArB;AACA,cAAIS,QAAQ,CAACT,WAAD,CAAZ,EAA2Ba,cAAc,GAAGJ,QAAQ,CAACT,WAAD,CAAzB;AAC3B,cAAIc,YAAY,GAAGf,SAAnB;AACA,cAAIU,QAAQ,CAACV,SAAD,CAAZ,EAAyBe,YAAY,GAAGL,QAAQ,CAACV,SAAD,CAAvB;;AAEzB,cAAIgB,MAAM,CAACF,cAAD,CAAN,KAA2BC,YAA/B,EAA6C;AAC3C,gBAAIE,SAAS,GAAGb,IAAI,CAACC,GAAL,CAASS,cAAT,EAAyBC,YAAzB,CAAhB;AACA,gBAAIG,QAAQ,GAAGd,IAAI,CAACe,GAAL,CAASL,cAAT,EAAyBC,YAAzB,CAAf;;AAEA,gBAAI,CAACN,MAAM,CAACQ,SAAD,CAAX,EAAwB;AACtBR,cAAAA,MAAM,CAACQ,SAAD,CAAN,GAAoB,EAApB;AACD;;AACDR,YAAAA,MAAM,CAACQ,SAAD,CAAN,CAAkBC,QAAlB,IAA8B,IAA9B;AACAR,YAAAA,QAAQ,CAACQ,QAAD,CAAR,GAAqBD,SAArB;;AACA,gBAAIR,MAAM,CAACS,QAAD,CAAV,EAAsB;AACpB;AACA,mBAAK,IAAIE,EAAT,IAAeT,MAAM,CAACC,IAAP,CAAYH,MAAM,CAACS,QAAD,CAAlB,CAAf,EAA8C;AAC5CT,gBAAAA,MAAM,CAACQ,SAAD,CAAN,CAAkBG,EAAlB,IAAwB,IAAxB;AACAV,gBAAAA,QAAQ,CAACU,EAAD,CAAR,GAAeH,SAAf;AACD;;AACD,qBAAOR,MAAM,CAACS,QAAD,CAAb;AACD;AACF;AACF;AACF;AACF;AACF;;AAED,MAAIG,MAAM,GAAGf,MAAM,CAACe,MAApB;AACA,MAAIC,KAAK,GAAG,CAACD,MAAM,CAAChB,GAApB;AACA,MAAIc,GAAG,GAAGE,MAAM,CAACF,GAAP,GAAaG,KAAvB;AACA,MAAIC,aAAa,GAAG,IAAIC,KAAJ,CAAUL,GAAG,GAAG,CAAhB,EAAmBM,IAAnB,CAAwB,CAAxB,CAApB;;AACA,OAAK,IAAIC,GAAT,IAAgBf,MAAM,CAACC,IAAP,CAAYF,QAAZ,CAAhB,EAAuC;AACrCa,IAAAA,aAAa,CAACP,MAAM,CAACU,GAAD,CAAN,GAAcJ,KAAf,CAAb,GAAqCZ,QAAQ,CAACgB,GAAD,CAA7C;AACD,GA1E4C,CA2E7C;;;AACA,MAAIC,IAAI,GAAGrB,MAAM,CAACqB,IAAlB;;AACA,OAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGD,IAAI,CAACE,MAAzB,EAAiCD,CAAC,EAAlC,EAAsC;AACpC,QAAIE,YAAY,GAAGH,IAAI,CAACC,CAAD,CAAvB;;AACA,QAAIE,YAAY,KAAK,CAArB,EAAwB;AACtB,UAAIC,QAAQ,GAAGR,aAAa,CAACO,YAAY,GAAGR,KAAhB,CAA5B;;AACA,UAAIS,QAAQ,KAAK,CAAjB,EAAoB;AAClBJ,QAAAA,IAAI,CAACC,CAAD,CAAJ,GAAUG,QAAV;AACD;AACF;AACF;;AAEDzB,EAAAA,MAAM,CAAC0B,QAAP,GAAkB,EAAlB;AACA,SAAO1B,MAAP;AACD","sourcesContent":["/**\n * In place modification of the roiMap that joins regions of interest\n * @param {object} [options]\n * @param {string|function(object,number,number)} [options.algorithm='commonBorderLength'] algorithm used to decide which ROIs are merged.\n *      Current implemented algorithms are 'commonBorderLength' that use the parameters\n *      'minCommonBorderLength' and 'maxCommonBorderLength' as well as 'commonBorderRatio' that uses\n *      the parameters 'minCommonBorderRatio' and 'maxCommonBorderRatio'.\n * @param {number} [options.minCommonBorderLength=5] minimal common number of pixels for merging\n * @param {number} [options.maxCommonBorderLength=100] maximal common number of pixels for merging\n * @param {number} [options.minCommonBorderRatio=0.3] minimal common border ratio for merging\n * @param {number} [options.maxCommonBorderRatio=1] maximal common border ratio for merging\n * @return {this}\n * @private\n */\nexport default function mergeRoi(options = {}) {\n  const {\n    algorithm = 'commonBorderLength',\n    minCommonBorderLength = 5,\n    maxCommonBorderLength = 100,\n    minCommonBorderRatio = 0.3,\n    maxCommonBorderRatio = 1,\n  } = options;\n\n  let checkFunction = function (currentInfo, currentID, neighbourID) {\n    return (\n      currentInfo[neighbourID] >= minCommonBorderLength &&\n      currentInfo[neighbourID] <= maxCommonBorderLength\n    );\n  };\n  if (typeof algorithm === 'function') {\n    checkFunction = algorithm;\n  }\n  if (algorithm.toLowerCase() === 'commonborderratio') {\n    checkFunction = function (currentInfo, currentID, neighbourID) {\n      let ratio = Math.min(\n        currentInfo[neighbourID] / currentInfo[currentID],\n        1,\n      );\n      return ratio >= minCommonBorderRatio && ratio <= maxCommonBorderRatio;\n    };\n  }\n  const roiMap = this;\n  const borderLengths = roiMap.commonBorderLength;\n  let newMap = {};\n  let oldToNew = {};\n\n  for (let currentID of Object.keys(borderLengths)) {\n    let currentInfo = borderLengths[currentID];\n    let neighbourIDs = Object.keys(currentInfo);\n    for (let neighbourID of neighbourIDs) {\n      if (neighbourID !== currentID) {\n        // it is not myself ...\n        if (checkFunction(currentInfo, currentID, neighbourID)) {\n          // the common border are in the range. We should merge\n          let newNeighbourID = neighbourID;\n          if (oldToNew[neighbourID]) newNeighbourID = oldToNew[neighbourID];\n          let newCurrentID = currentID;\n          if (oldToNew[currentID]) newCurrentID = oldToNew[currentID];\n\n          if (Number(newNeighbourID) !== newCurrentID) {\n            let smallerID = Math.min(newNeighbourID, newCurrentID);\n            let largerID = Math.max(newNeighbourID, newCurrentID);\n\n            if (!newMap[smallerID]) {\n              newMap[smallerID] = {};\n            }\n            newMap[smallerID][largerID] = true;\n            oldToNew[largerID] = smallerID;\n            if (newMap[largerID]) {\n              // need to put everything to smallerID and remove property\n              for (let id of Object.keys(newMap[largerID])) {\n                newMap[smallerID][id] = true;\n                oldToNew[id] = smallerID;\n              }\n              delete newMap[largerID];\n            }\n          }\n        }\n      }\n    }\n  }\n\n  let minMax = roiMap.minMax;\n  let shift = -minMax.min;\n  let max = minMax.max + shift;\n  let oldToNewArray = new Array(max + 1).fill(0);\n  for (let key of Object.keys(oldToNew)) {\n    oldToNewArray[Number(key) + shift] = oldToNew[key];\n  }\n  // time to change the roiMap\n  let data = roiMap.data;\n  for (let i = 0; i < data.length; i++) {\n    let currentValue = data[i];\n    if (currentValue !== 0) {\n      let newValue = oldToNewArray[currentValue + shift];\n      if (newValue !== 0) {\n        data[i] = newValue;\n      }\n    }\n  }\n\n  roiMap.computed = {};\n  return roiMap;\n}\n"]},"metadata":{},"sourceType":"module"}