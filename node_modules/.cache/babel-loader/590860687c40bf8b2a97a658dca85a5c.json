{"ast":null,"code":"// based on https://bgrins.github.io/TinyColor/docs/tinycolor.html\nimport Image from '../Image';\nimport { RGB, HSV } from '../model/model';\n/**\n * Make a copy of the current image and convert the color model to HSV\n * The source image has to be RGB !\n * @memberof Image\n * @instance\n * @return {Image} - New image in HSV color model\n * @example\n * var hsvImage = image.hsv();\n * // we can create one image per channel\n * var channels = hsvImage.split();\n */\n\nexport default function hsv() {\n  this.checkProcessable('hsv', {\n    bitDepth: [8, 16],\n    alpha: [0, 1],\n    colorModel: [RGB]\n  });\n  let newImage = Image.createFrom(this, {\n    colorModel: HSV\n  });\n  let ptr = 0;\n  let data = this.data;\n\n  for (let i = 0; i < data.length; i += this.channels) {\n    let red = data[i];\n    let green = data[i + 1];\n    let blue = data[i + 2];\n    let min = Math.min(red, green, blue);\n    let max = Math.max(red, green, blue);\n    let delta = max - min;\n    let hue = 0;\n    let saturation = max === 0 ? 0 : delta / max;\n    let value = max;\n\n    if (max !== min) {\n      switch (max) {\n        case red:\n          hue = (green - blue) / delta + (green < blue ? 6 : 0);\n          break;\n\n        case green:\n          hue = (blue - red) / delta + 2;\n          break;\n\n        case blue:\n          hue = (red - green) / delta + 4;\n          break;\n\n        default:\n          throw new Error('unreachable');\n      }\n\n      hue /= 6;\n    }\n\n    newImage.data[ptr++] = hue * this.maxValue;\n    newImage.data[ptr++] = saturation * this.maxValue;\n    newImage.data[ptr++] = value;\n\n    if (this.alpha) {\n      newImage.data[ptr++] = data[i + 3];\n    }\n  }\n\n  return newImage;\n}","map":{"version":3,"sources":["C:/Users/kuent/Documents/FinishDipshit/Creative/Ocean-Weather-Visualization/node_modules/image-js/src/image/transform/hsv.js"],"names":["Image","RGB","HSV","hsv","checkProcessable","bitDepth","alpha","colorModel","newImage","createFrom","ptr","data","i","length","channels","red","green","blue","min","Math","max","delta","hue","saturation","value","Error","maxValue"],"mappings":"AAAA;AAEA,OAAOA,KAAP,MAAkB,UAAlB;AACA,SAASC,GAAT,EAAcC,GAAd,QAAyB,gBAAzB;AAEA;;;;;;;;;;;;AAWA,eAAe,SAASC,GAAT,GAAe;AAC5B,OAAKC,gBAAL,CAAsB,KAAtB,EAA6B;AAC3BC,IAAAA,QAAQ,EAAE,CAAC,CAAD,EAAI,EAAJ,CADiB;AAE3BC,IAAAA,KAAK,EAAE,CAAC,CAAD,EAAI,CAAJ,CAFoB;AAG3BC,IAAAA,UAAU,EAAE,CAACN,GAAD;AAHe,GAA7B;AAMA,MAAIO,QAAQ,GAAGR,KAAK,CAACS,UAAN,CAAiB,IAAjB,EAAuB;AACpCF,IAAAA,UAAU,EAAEL;AADwB,GAAvB,CAAf;AAIA,MAAIQ,GAAG,GAAG,CAAV;AACA,MAAIC,IAAI,GAAG,KAAKA,IAAhB;;AACA,OAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGD,IAAI,CAACE,MAAzB,EAAiCD,CAAC,IAAI,KAAKE,QAA3C,EAAqD;AACnD,QAAIC,GAAG,GAAGJ,IAAI,CAACC,CAAD,CAAd;AACA,QAAII,KAAK,GAAGL,IAAI,CAACC,CAAC,GAAG,CAAL,CAAhB;AACA,QAAIK,IAAI,GAAGN,IAAI,CAACC,CAAC,GAAG,CAAL,CAAf;AAEA,QAAIM,GAAG,GAAGC,IAAI,CAACD,GAAL,CAASH,GAAT,EAAcC,KAAd,EAAqBC,IAArB,CAAV;AACA,QAAIG,GAAG,GAAGD,IAAI,CAACC,GAAL,CAASL,GAAT,EAAcC,KAAd,EAAqBC,IAArB,CAAV;AACA,QAAII,KAAK,GAAGD,GAAG,GAAGF,GAAlB;AACA,QAAII,GAAG,GAAG,CAAV;AACA,QAAIC,UAAU,GAAGH,GAAG,KAAK,CAAR,GAAY,CAAZ,GAAgBC,KAAK,GAAGD,GAAzC;AACA,QAAII,KAAK,GAAGJ,GAAZ;;AAEA,QAAIA,GAAG,KAAKF,GAAZ,EAAiB;AACf,cAAQE,GAAR;AACE,aAAKL,GAAL;AACEO,UAAAA,GAAG,GAAG,CAACN,KAAK,GAAGC,IAAT,IAAiBI,KAAjB,IAA0BL,KAAK,GAAGC,IAAR,GAAe,CAAf,GAAmB,CAA7C,CAAN;AACA;;AACF,aAAKD,KAAL;AACEM,UAAAA,GAAG,GAAG,CAACL,IAAI,GAAGF,GAAR,IAAeM,KAAf,GAAuB,CAA7B;AACA;;AACF,aAAKJ,IAAL;AACEK,UAAAA,GAAG,GAAG,CAACP,GAAG,GAAGC,KAAP,IAAgBK,KAAhB,GAAwB,CAA9B;AACA;;AACF;AACE,gBAAM,IAAII,KAAJ,CAAU,aAAV,CAAN;AAXJ;;AAaAH,MAAAA,GAAG,IAAI,CAAP;AACD;;AAEDd,IAAAA,QAAQ,CAACG,IAAT,CAAcD,GAAG,EAAjB,IAAuBY,GAAG,GAAG,KAAKI,QAAlC;AACAlB,IAAAA,QAAQ,CAACG,IAAT,CAAcD,GAAG,EAAjB,IAAuBa,UAAU,GAAG,KAAKG,QAAzC;AACAlB,IAAAA,QAAQ,CAACG,IAAT,CAAcD,GAAG,EAAjB,IAAuBc,KAAvB;;AACA,QAAI,KAAKlB,KAAT,EAAgB;AACdE,MAAAA,QAAQ,CAACG,IAAT,CAAcD,GAAG,EAAjB,IAAuBC,IAAI,CAACC,CAAC,GAAG,CAAL,CAA3B;AACD;AACF;;AAED,SAAOJ,QAAP;AACD","sourcesContent":["// based on https://bgrins.github.io/TinyColor/docs/tinycolor.html\n\nimport Image from '../Image';\nimport { RGB, HSV } from '../model/model';\n\n/**\n * Make a copy of the current image and convert the color model to HSV\n * The source image has to be RGB !\n * @memberof Image\n * @instance\n * @return {Image} - New image in HSV color model\n * @example\n * var hsvImage = image.hsv();\n * // we can create one image per channel\n * var channels = hsvImage.split();\n */\nexport default function hsv() {\n  this.checkProcessable('hsv', {\n    bitDepth: [8, 16],\n    alpha: [0, 1],\n    colorModel: [RGB],\n  });\n\n  let newImage = Image.createFrom(this, {\n    colorModel: HSV,\n  });\n\n  let ptr = 0;\n  let data = this.data;\n  for (let i = 0; i < data.length; i += this.channels) {\n    let red = data[i];\n    let green = data[i + 1];\n    let blue = data[i + 2];\n\n    let min = Math.min(red, green, blue);\n    let max = Math.max(red, green, blue);\n    let delta = max - min;\n    let hue = 0;\n    let saturation = max === 0 ? 0 : delta / max;\n    let value = max;\n\n    if (max !== min) {\n      switch (max) {\n        case red:\n          hue = (green - blue) / delta + (green < blue ? 6 : 0);\n          break;\n        case green:\n          hue = (blue - red) / delta + 2;\n          break;\n        case blue:\n          hue = (red - green) / delta + 4;\n          break;\n        default:\n          throw new Error('unreachable');\n      }\n      hue /= 6;\n    }\n\n    newImage.data[ptr++] = hue * this.maxValue;\n    newImage.data[ptr++] = saturation * this.maxValue;\n    newImage.data[ptr++] = value;\n    if (this.alpha) {\n      newImage.data[ptr++] = data[i + 3];\n    }\n  }\n\n  return newImage;\n}\n"]},"metadata":{},"sourceType":"module"}