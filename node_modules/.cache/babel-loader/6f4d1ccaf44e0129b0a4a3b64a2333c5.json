{"ast":null,"code":"\"use strict\";\n/*\r\n * Copyright 2017 Sam Thorogood. All rights reserved.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\r\n * use this file except in compliance with the License. You may obtain a copy of\r\n * the License at\r\n *\r\n *     http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\r\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\r\n * License for the specific language governing permissions and limitations under\r\n * the License.\r\n */\n\n(function (scope) {\n  'use strict'; // fail early\n\n  if (scope['TextEncoder'] && scope['TextDecoder']) {\n    return false;\n  }\n  /**\r\n   * @constructor\r\n   * @param {string=} utfLabel\r\n   */\n\n\n  function FastTextEncoder(utfLabel = 'utf-8') {\n    if (utfLabel !== 'utf-8') {\n      throw new RangeError(`Failed to construct 'TextEncoder': The encoding label provided ('${utfLabel}') is invalid.`);\n    }\n  }\n\n  Object.defineProperty(FastTextEncoder.prototype, 'encoding', {\n    value: 'utf-8'\n  });\n  /**\r\n   * @param {string} string\r\n   * @param {{stream: boolean}=} options\r\n   * @return {!Uint8Array}\r\n   */\n\n  FastTextEncoder.prototype.encode = function (string, options = {\n    stream: false\n  }) {\n    if (options.stream) {\n      throw new Error(`Failed to encode: the 'stream' option is unsupported.`);\n    }\n\n    let pos = 0;\n    const len = string.length;\n    const out = [];\n    let at = 0; // output position\n\n    let tlen = Math.max(32, len + (len >> 1) + 7); // 1.5x size\n\n    let target = new Uint8Array(tlen >> 3 << 3); // ... but at 8 byte offset\n\n    while (pos < len) {\n      let value = string.charCodeAt(pos++);\n\n      if (value >= 0xd800 && value <= 0xdbff) {\n        // high surrogate\n        if (pos < len) {\n          const extra = string.charCodeAt(pos);\n\n          if ((extra & 0xfc00) === 0xdc00) {\n            ++pos;\n            value = ((value & 0x3ff) << 10) + (extra & 0x3ff) + 0x10000;\n          }\n        }\n\n        if (value >= 0xd800 && value <= 0xdbff) {\n          continue; // drop lone surrogate\n        }\n      } // expand the buffer if we couldn't write 4 bytes\n\n\n      if (at + 4 > target.length) {\n        tlen += 8; // minimum extra\n\n        tlen *= 1.0 + pos / string.length * 2; // take 2x the remaining\n\n        tlen = tlen >> 3 << 3; // 8 byte offset\n\n        const update = new Uint8Array(tlen);\n        update.set(target);\n        target = update;\n      }\n\n      if ((value & 0xffffff80) === 0) {\n        // 1-byte\n        target[at++] = value; // ASCII\n\n        continue;\n      } else if ((value & 0xfffff800) === 0) {\n        // 2-byte\n        target[at++] = value >> 6 & 0x1f | 0xc0;\n      } else if ((value & 0xffff0000) === 0) {\n        // 3-byte\n        target[at++] = value >> 12 & 0x0f | 0xe0;\n        target[at++] = value >> 6 & 0x3f | 0x80;\n      } else if ((value & 0xffe00000) === 0) {\n        // 4-byte\n        target[at++] = value >> 18 & 0x07 | 0xf0;\n        target[at++] = value >> 12 & 0x3f | 0x80;\n        target[at++] = value >> 6 & 0x3f | 0x80;\n      } else {\n        // FIXME: do we care\n        continue;\n      }\n\n      target[at++] = value & 0x3f | 0x80;\n    }\n\n    return target.slice(0, at);\n  };\n  /**\r\n   * @constructor\r\n   * @param {string=} utfLabel\r\n   * @param {{fatal: boolean}=} options\r\n   */\n\n\n  function FastTextDecoder(utfLabel = 'utf-8', options = {\n    fatal: false\n  }) {\n    if (utfLabel !== 'utf-8') {\n      throw new RangeError(`Failed to construct 'TextDecoder': The encoding label provided ('${utfLabel}') is invalid.`);\n    }\n\n    if (options.fatal) {\n      throw new Error(`Failed to construct 'TextDecoder': the 'fatal' option is unsupported.`);\n    }\n  }\n\n  Object.defineProperty(FastTextDecoder.prototype, 'encoding', {\n    value: 'utf-8'\n  });\n  Object.defineProperty(FastTextDecoder.prototype, 'fatal', {\n    value: false\n  });\n  Object.defineProperty(FastTextDecoder.prototype, 'ignoreBOM', {\n    value: false\n  });\n  /**\r\n   * @param {(!ArrayBuffer|!ArrayBufferView)} buffer\r\n   * @param {{stream: boolean}=} options\r\n   */\n\n  FastTextDecoder.prototype.decode = function (buffer, options = {\n    stream: false\n  }) {\n    if (options['stream']) {\n      throw new Error(`Failed to decode: the 'stream' option is unsupported.`);\n    }\n\n    const bytes = new Uint8Array(buffer);\n    let pos = 0;\n    const len = bytes.length;\n    const out = [];\n\n    while (pos < len) {\n      const byte1 = bytes[pos++];\n\n      if (byte1 === 0) {\n        break; // NULL\n      }\n\n      if ((byte1 & 0x80) === 0) {\n        // 1-byte\n        out.push(byte1);\n      } else if ((byte1 & 0xe0) === 0xc0) {\n        // 2-byte\n        const byte2 = bytes[pos++] & 0x3f;\n        out.push((byte1 & 0x1f) << 6 | byte2);\n      } else if ((byte1 & 0xf0) === 0xe0) {\n        const byte2 = bytes[pos++] & 0x3f;\n        const byte3 = bytes[pos++] & 0x3f;\n        out.push((byte1 & 0x1f) << 12 | byte2 << 6 | byte3);\n      } else if ((byte1 & 0xf8) === 0xf0) {\n        const byte2 = bytes[pos++] & 0x3f;\n        const byte3 = bytes[pos++] & 0x3f;\n        const byte4 = bytes[pos++] & 0x3f; // this can be > 0xffff, so possibly generate surrogates\n\n        let codepoint = (byte1 & 0x07) << 0x12 | byte2 << 0x0c | byte3 << 0x06 | byte4;\n\n        if (codepoint > 0xffff) {\n          // codepoint &= ~0x10000;\n          codepoint -= 0x10000;\n          out.push(codepoint >>> 10 & 0x3ff | 0xd800);\n          codepoint = 0xdc00 | codepoint & 0x3ff;\n        }\n\n        out.push(codepoint);\n      } else {// FIXME: we're ignoring this\n      }\n    }\n\n    return String.fromCharCode.apply(null, out);\n  };\n\n  scope['TextEncoder'] = FastTextEncoder;\n  scope['TextDecoder'] = FastTextDecoder;\n})(typeof window !== 'undefined' ? window : typeof self !== 'undefined' ? self : this);","map":{"version":3,"sources":["../src/text-encoding-polyfill.js"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\r\n/*\r\n * Copyright 2017 Sam Thorogood. All rights reserved.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\r\n * use this file except in compliance with the License. You may obtain a copy of\r\n * the License at\r\n *\r\n *     http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\r\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\r\n * License for the specific language governing permissions and limitations under\r\n * the License.\r\n */\r\n(function (scope) {\r\n    'use strict';\r\n    // fail early\r\n    if (scope['TextEncoder'] && scope['TextDecoder']) {\r\n        return false;\r\n    }\r\n    /**\r\n     * @constructor\r\n     * @param {string=} utfLabel\r\n     */\r\n    function FastTextEncoder(utfLabel = 'utf-8') {\r\n        if (utfLabel !== 'utf-8') {\r\n            throw new RangeError(`Failed to construct 'TextEncoder': The encoding label provided ('${utfLabel}') is invalid.`);\r\n        }\r\n    }\r\n    Object.defineProperty(FastTextEncoder.prototype, 'encoding', {\r\n        value: 'utf-8',\r\n    });\r\n    /**\r\n     * @param {string} string\r\n     * @param {{stream: boolean}=} options\r\n     * @return {!Uint8Array}\r\n     */\r\n    FastTextEncoder.prototype.encode = function (string, options = { stream: false }) {\r\n        if (options.stream) {\r\n            throw new Error(`Failed to encode: the 'stream' option is unsupported.`);\r\n        }\r\n        let pos = 0;\r\n        const len = string.length;\r\n        const out = [];\r\n        let at = 0; // output position\r\n        let tlen = Math.max(32, len + (len >> 1) + 7); // 1.5x size\r\n        let target = new Uint8Array((tlen >> 3) << 3); // ... but at 8 byte offset\r\n        while (pos < len) {\r\n            let value = string.charCodeAt(pos++);\r\n            if (value >= 0xd800 && value <= 0xdbff) {\r\n                // high surrogate\r\n                if (pos < len) {\r\n                    const extra = string.charCodeAt(pos);\r\n                    if ((extra & 0xfc00) === 0xdc00) {\r\n                        ++pos;\r\n                        value = ((value & 0x3ff) << 10) + (extra & 0x3ff) + 0x10000;\r\n                    }\r\n                }\r\n                if (value >= 0xd800 && value <= 0xdbff) {\r\n                    continue; // drop lone surrogate\r\n                }\r\n            }\r\n            // expand the buffer if we couldn't write 4 bytes\r\n            if (at + 4 > target.length) {\r\n                tlen += 8; // minimum extra\r\n                tlen *= 1.0 + (pos / string.length) * 2; // take 2x the remaining\r\n                tlen = (tlen >> 3) << 3; // 8 byte offset\r\n                const update = new Uint8Array(tlen);\r\n                update.set(target);\r\n                target = update;\r\n            }\r\n            if ((value & 0xffffff80) === 0) {\r\n                // 1-byte\r\n                target[at++] = value; // ASCII\r\n                continue;\r\n            }\r\n            else if ((value & 0xfffff800) === 0) {\r\n                // 2-byte\r\n                target[at++] = ((value >> 6) & 0x1f) | 0xc0;\r\n            }\r\n            else if ((value & 0xffff0000) === 0) {\r\n                // 3-byte\r\n                target[at++] = ((value >> 12) & 0x0f) | 0xe0;\r\n                target[at++] = ((value >> 6) & 0x3f) | 0x80;\r\n            }\r\n            else if ((value & 0xffe00000) === 0) {\r\n                // 4-byte\r\n                target[at++] = ((value >> 18) & 0x07) | 0xf0;\r\n                target[at++] = ((value >> 12) & 0x3f) | 0x80;\r\n                target[at++] = ((value >> 6) & 0x3f) | 0x80;\r\n            }\r\n            else {\r\n                // FIXME: do we care\r\n                continue;\r\n            }\r\n            target[at++] = (value & 0x3f) | 0x80;\r\n        }\r\n        return target.slice(0, at);\r\n    };\r\n    /**\r\n     * @constructor\r\n     * @param {string=} utfLabel\r\n     * @param {{fatal: boolean}=} options\r\n     */\r\n    function FastTextDecoder(utfLabel = 'utf-8', options = { fatal: false }) {\r\n        if (utfLabel !== 'utf-8') {\r\n            throw new RangeError(`Failed to construct 'TextDecoder': The encoding label provided ('${utfLabel}') is invalid.`);\r\n        }\r\n        if (options.fatal) {\r\n            throw new Error(`Failed to construct 'TextDecoder': the 'fatal' option is unsupported.`);\r\n        }\r\n    }\r\n    Object.defineProperty(FastTextDecoder.prototype, 'encoding', {\r\n        value: 'utf-8',\r\n    });\r\n    Object.defineProperty(FastTextDecoder.prototype, 'fatal', { value: false });\r\n    Object.defineProperty(FastTextDecoder.prototype, 'ignoreBOM', {\r\n        value: false,\r\n    });\r\n    /**\r\n     * @param {(!ArrayBuffer|!ArrayBufferView)} buffer\r\n     * @param {{stream: boolean}=} options\r\n     */\r\n    FastTextDecoder.prototype.decode = function (buffer, options = { stream: false }) {\r\n        if (options['stream']) {\r\n            throw new Error(`Failed to decode: the 'stream' option is unsupported.`);\r\n        }\r\n        const bytes = new Uint8Array(buffer);\r\n        let pos = 0;\r\n        const len = bytes.length;\r\n        const out = [];\r\n        while (pos < len) {\r\n            const byte1 = bytes[pos++];\r\n            if (byte1 === 0) {\r\n                break; // NULL\r\n            }\r\n            if ((byte1 & 0x80) === 0) {\r\n                // 1-byte\r\n                out.push(byte1);\r\n            }\r\n            else if ((byte1 & 0xe0) === 0xc0) {\r\n                // 2-byte\r\n                const byte2 = bytes[pos++] & 0x3f;\r\n                out.push(((byte1 & 0x1f) << 6) | byte2);\r\n            }\r\n            else if ((byte1 & 0xf0) === 0xe0) {\r\n                const byte2 = bytes[pos++] & 0x3f;\r\n                const byte3 = bytes[pos++] & 0x3f;\r\n                out.push(((byte1 & 0x1f) << 12) | (byte2 << 6) | byte3);\r\n            }\r\n            else if ((byte1 & 0xf8) === 0xf0) {\r\n                const byte2 = bytes[pos++] & 0x3f;\r\n                const byte3 = bytes[pos++] & 0x3f;\r\n                const byte4 = bytes[pos++] & 0x3f;\r\n                // this can be > 0xffff, so possibly generate surrogates\r\n                let codepoint = ((byte1 & 0x07) << 0x12) | (byte2 << 0x0c) | (byte3 << 0x06) | byte4;\r\n                if (codepoint > 0xffff) {\r\n                    // codepoint &= ~0x10000;\r\n                    codepoint -= 0x10000;\r\n                    out.push(((codepoint >>> 10) & 0x3ff) | 0xd800);\r\n                    codepoint = 0xdc00 | (codepoint & 0x3ff);\r\n                }\r\n                out.push(codepoint);\r\n            }\r\n            else {\r\n                // FIXME: we're ignoring this\r\n            }\r\n        }\r\n        return String.fromCharCode.apply(null, out);\r\n    };\r\n    scope['TextEncoder'] = FastTextEncoder;\r\n    scope['TextDecoder'] = FastTextDecoder;\r\n})(typeof window !== 'undefined'\r\n    ? window\r\n    : typeof self !== 'undefined'\r\n        ? self\r\n        : this);\r\n//# sourceMappingURL=text-encoding-polyfill.js.map"]},"metadata":{},"sourceType":"script"}