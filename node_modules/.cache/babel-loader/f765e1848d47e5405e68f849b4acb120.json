{"ast":null,"code":"import * as Model from '../image/model/model';\n/**\n * Specify which channels should be processed\n * * undefined : we take all the channels but alpha\n * * number : this specific channel\n * * string : converted to a channel based on rgb, cmyk, hsl or hsv (one letter code)\n * * [number] : array of channels as numbers\n * * [string] : array of channels as one letter string\n * @typedef {undefined|number|string|Array<number>|Array<string>} SelectedChannels\n */\n\nexport function validateArrayOfChannels(image, options = {}) {\n  let {\n    channels,\n    allowAlpha,\n    // are we allowing the selection of an alpha channel ?\n    defaultAlpha // if no channels are selected should we take the alpha channel ?\n\n  } = options;\n\n  if (typeof allowAlpha !== 'boolean') {\n    allowAlpha = true;\n  }\n\n  if (typeof channels === 'undefined') {\n    return allChannels(image, defaultAlpha);\n  } else {\n    return validateChannels(image, channels, allowAlpha);\n  }\n}\n\nfunction allChannels(image, defaultAlpha) {\n  let length = defaultAlpha ? image.channels : image.components;\n  let array = new Array(length);\n\n  for (let i = 0; i < length; i++) {\n    array[i] = i;\n  }\n\n  return array;\n}\n\nfunction validateChannels(image, channels, allowAlpha) {\n  if (!Array.isArray(channels)) {\n    channels = [channels];\n  }\n\n  for (let c = 0; c < channels.length; c++) {\n    channels[c] = validateChannel(image, channels[c], allowAlpha);\n  }\n\n  return channels;\n}\n\nexport function validateChannel(image, channel, allowAlpha = true) {\n  if (channel === undefined) {\n    throw new RangeError(`validateChannel : the channel has to be >=0 and <${image.channels}`);\n  }\n\n  if (typeof channel === 'string') {\n    switch (image.colorModel) {\n      case Model.GREY:\n        break;\n\n      case Model.RGB:\n        if ('rgb'.includes(channel)) {\n          switch (channel) {\n            case 'r':\n              channel = 0;\n              break;\n\n            case 'g':\n              channel = 1;\n              break;\n\n            case 'b':\n              channel = 2;\n              break;\n            // no default\n          }\n        }\n\n        break;\n\n      case Model.HSL:\n        if ('hsl'.includes(channel)) {\n          switch (channel) {\n            case 'h':\n              channel = 0;\n              break;\n\n            case 's':\n              channel = 1;\n              break;\n\n            case 'l':\n              channel = 2;\n              break;\n            // no default\n          }\n        }\n\n        break;\n\n      case Model.HSV:\n        if ('hsv'.includes(channel)) {\n          switch (channel) {\n            case 'h':\n              channel = 0;\n              break;\n\n            case 's':\n              channel = 1;\n              break;\n\n            case 'v':\n              channel = 2;\n              break;\n            // no default\n          }\n        }\n\n        break;\n\n      case Model.CMYK:\n        if ('cmyk'.includes(channel)) {\n          switch (channel) {\n            case 'c':\n              channel = 0;\n              break;\n\n            case 'm':\n              channel = 1;\n              break;\n\n            case 'y':\n              channel = 2;\n              break;\n\n            case 'k':\n              channel = 3;\n              break;\n            // no default\n          }\n        }\n\n        break;\n\n      default:\n        throw new Error(`Unexpected color model: ${image.colorModel}`);\n    }\n\n    if (channel === 'a') {\n      if (!image.alpha) {\n        throw new Error('validateChannel : the image does not contain alpha channel');\n      }\n\n      channel = image.components;\n    }\n\n    if (typeof channel === 'string') {\n      throw new Error(`validateChannel : undefined channel: ${channel}`);\n    }\n  }\n\n  if (channel >= image.channels) {\n    throw new RangeError(`validateChannel : the channel has to be >=0 and <${image.channels}`);\n  }\n\n  if (!allowAlpha && channel >= image.components) {\n    throw new RangeError('validateChannel : alpha channel may not be selected');\n  }\n\n  return channel;\n}","map":{"version":3,"sources":["C:/Users/kuent/Documents/FinishDipshit/Creative/Ocean-Weather-Visualization/node_modules/image-js/src/util/channel.js"],"names":["Model","validateArrayOfChannels","image","options","channels","allowAlpha","defaultAlpha","allChannels","validateChannels","length","components","array","Array","i","isArray","c","validateChannel","channel","undefined","RangeError","colorModel","GREY","RGB","includes","HSL","HSV","CMYK","Error","alpha"],"mappings":"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","sourcesContent":["import * as Model from '../image/model/model';\n\n/**\n * Specify which channels should be processed\n * * undefined : we take all the channels but alpha\n * * number : this specific channel\n * * string : converted to a channel based on rgb, cmyk, hsl or hsv (one letter code)\n * * [number] : array of channels as numbers\n * * [string] : array of channels as one letter string\n * @typedef {undefined|number|string|Array<number>|Array<string>} SelectedChannels\n */\n\nexport function validateArrayOfChannels(image, options = {}) {\n  let {\n    channels,\n    allowAlpha, // are we allowing the selection of an alpha channel ?\n    defaultAlpha, // if no channels are selected should we take the alpha channel ?\n  } = options;\n\n  if (typeof allowAlpha !== 'boolean') {\n    allowAlpha = true;\n  }\n\n  if (typeof channels === 'undefined') {\n    return allChannels(image, defaultAlpha);\n  } else {\n    return validateChannels(image, channels, allowAlpha);\n  }\n}\n\nfunction allChannels(image, defaultAlpha) {\n  let length = defaultAlpha ? image.channels : image.components;\n  let array = new Array(length);\n  for (let i = 0; i < length; i++) {\n    array[i] = i;\n  }\n  return array;\n}\n\nfunction validateChannels(image, channels, allowAlpha) {\n  if (!Array.isArray(channels)) {\n    channels = [channels];\n  }\n  for (let c = 0; c < channels.length; c++) {\n    channels[c] = validateChannel(image, channels[c], allowAlpha);\n  }\n  return channels;\n}\n\nexport function validateChannel(image, channel, allowAlpha = true) {\n  if (channel === undefined) {\n    throw new RangeError(\n      `validateChannel : the channel has to be >=0 and <${image.channels}`,\n    );\n  }\n\n  if (typeof channel === 'string') {\n    switch (image.colorModel) {\n      case Model.GREY:\n        break;\n      case Model.RGB:\n        if ('rgb'.includes(channel)) {\n          switch (channel) {\n            case 'r':\n              channel = 0;\n              break;\n            case 'g':\n              channel = 1;\n              break;\n            case 'b':\n              channel = 2;\n              break;\n            // no default\n          }\n        }\n        break;\n      case Model.HSL:\n        if ('hsl'.includes(channel)) {\n          switch (channel) {\n            case 'h':\n              channel = 0;\n              break;\n            case 's':\n              channel = 1;\n              break;\n            case 'l':\n              channel = 2;\n              break;\n            // no default\n          }\n        }\n        break;\n      case Model.HSV:\n        if ('hsv'.includes(channel)) {\n          switch (channel) {\n            case 'h':\n              channel = 0;\n              break;\n            case 's':\n              channel = 1;\n              break;\n            case 'v':\n              channel = 2;\n              break;\n            // no default\n          }\n        }\n        break;\n      case Model.CMYK:\n        if ('cmyk'.includes(channel)) {\n          switch (channel) {\n            case 'c':\n              channel = 0;\n              break;\n            case 'm':\n              channel = 1;\n              break;\n            case 'y':\n              channel = 2;\n              break;\n            case 'k':\n              channel = 3;\n              break;\n            // no default\n          }\n        }\n        break;\n      default:\n        throw new Error(`Unexpected color model: ${image.colorModel}`);\n    }\n\n    if (channel === 'a') {\n      if (!image.alpha) {\n        throw new Error(\n          'validateChannel : the image does not contain alpha channel',\n        );\n      }\n      channel = image.components;\n    }\n\n    if (typeof channel === 'string') {\n      throw new Error(`validateChannel : undefined channel: ${channel}`);\n    }\n  }\n\n  if (channel >= image.channels) {\n    throw new RangeError(\n      `validateChannel : the channel has to be >=0 and <${image.channels}`,\n    );\n  }\n\n  if (!allowAlpha && channel >= image.components) {\n    throw new RangeError('validateChannel : alpha channel may not be selected');\n  }\n\n  return channel;\n}\n"]},"metadata":{},"sourceType":"module"}