{"ast":null,"code":"import Stack from '../Stack'; // TODO this code seems buggy if it is not 0,0\n\n/**\n * We will try to move a set of images in order to get only the best common part of them.\n * In a stack, we compare 2 consecutive images or directly to a parent.\n * Ignoring border may be dangerous ! If there is a shape on the side of the image there will be a\n * continuous shift if you ignore border. By default it is better to leave it to 0,0\n * Now if the background is not black there will also be no way to shift ...\n * It may therefore be much better to make a background correction before trying to match and crop.\n * @memberof Stack\n * @instance\n * @param {object} [options]\n * @param {string} [options.algorithm='matchToPrevious'] - matchToPrevious or matchToFirst\n * @param {number[]} [options.ignoreBorder=[0, 0]]\n * @return {Stack}\n */\n\nexport default function matchAndCrop(options = {}) {\n  let {\n    algorithm = 'matchToPrevious',\n    ignoreBorder = [0, 0]\n  } = options;\n  this.checkProcessable('matchAndCrop', {\n    bitDepth: [8, 16]\n  });\n  let matchToPrevious = algorithm === 'matchToPrevious';\n  let parent = this[0];\n  let results = [];\n  results[0] = {\n    position: [0, 0],\n    image: this[0]\n  };\n  let relativePosition = [0, 0]; // we calculate the best relative position to the parent image\n\n  for (let i = 1; i < this.length; i++) {\n    let position = parent.getBestMatch(this[i], {\n      border: ignoreBorder\n    });\n    results[i] = {\n      position: [position[0] + relativePosition[0], position[1] + relativePosition[1]],\n      image: this[i]\n    };\n\n    if (matchToPrevious) {\n      relativePosition[0] += position[0];\n      relativePosition[1] += position[1];\n      parent = this[i];\n    }\n  } // now we can calculate the cropping that we need to do\n\n\n  let leftShift = 0;\n  let rightShift = 0;\n  let topShift = 0;\n  let bottomShift = 0;\n\n  for (let i = 0; i < results.length; i++) {\n    let result = results[i];\n\n    if (result.position[0] > leftShift) {\n      leftShift = result.position[0];\n    }\n\n    if (result.position[0] < rightShift) {\n      rightShift = result.position[0];\n    }\n\n    if (result.position[1] > topShift) {\n      topShift = result.position[1];\n    }\n\n    if (result.position[1] < bottomShift) {\n      bottomShift = result.position[1];\n    }\n  }\n\n  rightShift = 0 - rightShift;\n  bottomShift = 0 - bottomShift;\n\n  for (let i = 0; i < results.length; i++) {\n    let result = results[i];\n    result.crop = result.image.crop({\n      x: leftShift - result.position[0],\n      y: topShift - result.position[1],\n      width: parent.width - rightShift - leftShift,\n      height: parent.height - bottomShift - topShift\n    });\n  } // finally we crop and create a new array of images\n\n\n  let newImages = [];\n\n  for (let i = 0; i < results.length; i++) {\n    newImages[i] = results[i].crop;\n  }\n\n  return new Stack(newImages);\n}","map":{"version":3,"sources":["C:/Users/kuent/Documents/FinishDipshit/Creative/Ocean-Weather-Visualization/node_modules/image-js/src/stack/transform/matchAndCrop.js"],"names":["Stack","matchAndCrop","options","algorithm","ignoreBorder","checkProcessable","bitDepth","matchToPrevious","parent","results","position","image","relativePosition","i","length","getBestMatch","border","leftShift","rightShift","topShift","bottomShift","result","crop","x","y","width","height","newImages"],"mappings":"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","sourcesContent":["import Stack from '../Stack';\n\n// TODO this code seems buggy if it is not 0,0\n/**\n * We will try to move a set of images in order to get only the best common part of them.\n * In a stack, we compare 2 consecutive images or directly to a parent.\n * Ignoring border may be dangerous ! If there is a shape on the side of the image there will be a\n * continuous shift if you ignore border. By default it is better to leave it to 0,0\n * Now if the background is not black there will also be no way to shift ...\n * It may therefore be much better to make a background correction before trying to match and crop.\n * @memberof Stack\n * @instance\n * @param {object} [options]\n * @param {string} [options.algorithm='matchToPrevious'] - matchToPrevious or matchToFirst\n * @param {number[]} [options.ignoreBorder=[0, 0]]\n * @return {Stack}\n */\nexport default function matchAndCrop(options = {}) {\n  let { algorithm = 'matchToPrevious', ignoreBorder = [0, 0] } = options;\n\n  this.checkProcessable('matchAndCrop', {\n    bitDepth: [8, 16],\n  });\n\n  let matchToPrevious = algorithm === 'matchToPrevious';\n\n  let parent = this[0];\n  let results = [];\n  results[0] = {\n    position: [0, 0],\n    image: this[0],\n  };\n\n  let relativePosition = [0, 0];\n\n  // we calculate the best relative position to the parent image\n  for (let i = 1; i < this.length; i++) {\n    let position = parent.getBestMatch(this[i], { border: ignoreBorder });\n\n    results[i] = {\n      position: [\n        position[0] + relativePosition[0],\n        position[1] + relativePosition[1],\n      ],\n      image: this[i],\n    };\n    if (matchToPrevious) {\n      relativePosition[0] += position[0];\n      relativePosition[1] += position[1];\n      parent = this[i];\n    }\n  }\n  // now we can calculate the cropping that we need to do\n\n  let leftShift = 0;\n  let rightShift = 0;\n  let topShift = 0;\n  let bottomShift = 0;\n\n  for (let i = 0; i < results.length; i++) {\n    let result = results[i];\n    if (result.position[0] > leftShift) {\n      leftShift = result.position[0];\n    }\n    if (result.position[0] < rightShift) {\n      rightShift = result.position[0];\n    }\n    if (result.position[1] > topShift) {\n      topShift = result.position[1];\n    }\n    if (result.position[1] < bottomShift) {\n      bottomShift = result.position[1];\n    }\n  }\n  rightShift = 0 - rightShift;\n  bottomShift = 0 - bottomShift;\n\n  for (let i = 0; i < results.length; i++) {\n    let result = results[i];\n\n    result.crop = result.image.crop({\n      x: leftShift - result.position[0],\n      y: topShift - result.position[1],\n      width: parent.width - rightShift - leftShift,\n      height: parent.height - bottomShift - topShift,\n    });\n  }\n\n  // finally we crop and create a new array of images\n  let newImages = [];\n  for (let i = 0; i < results.length; i++) {\n    newImages[i] = results[i].crop;\n  }\n\n  return new Stack(newImages);\n}\n"]},"metadata":{},"sourceType":"module"}