{"ast":null,"code":"/**\n * Paint a polyline defined by an array of points.\n * @memberof Image\n * @instance\n * @param {Array<Array<number>>} points - Array of [x,y] points\n * @param {object} [options]\n * @param {Array<number>} [options.color=[max,0,0]] - Array of 3 elements (R, G, B), default is red.\n * @param {boolean} [options.closed=false] - Close the polyline.\n * @return {this} The original painted image\n */\nexport default function paintPolyline(points, options = {}) {\n  let {\n    color = [this.maxValue, 0, 0],\n    closed = false\n  } = options;\n  this.checkProcessable('paintPoints', {\n    bitDepth: [1, 8, 16]\n  });\n  let numberChannels = Math.min(this.channels, color.length);\n\n  for (let i = 0; i < points.length - 1 + closed; i++) {\n    let from = points[i];\n    let to = points[(i + 1) % points.length];\n    let dx = to[0] - from[0];\n    let dy = to[1] - from[1];\n    let steps = Math.max(Math.abs(dx), Math.abs(dy));\n    let xIncrement = dx / steps;\n    let yIncrement = dy / steps;\n    let x = from[0];\n    let y = from[1];\n\n    for (let j = 0; j <= steps; j++) {\n      let xPoint = Math.round(x);\n      let yPoint = Math.round(y);\n\n      if (xPoint >= 0 && yPoint >= 0 && xPoint < this.width && yPoint < this.height) {\n        if (this.bitDepth === 1) {\n          this.setBitXY(xPoint, yPoint);\n        } else {\n          let position = (xPoint + yPoint * this.width) * this.channels;\n\n          for (let channel = 0; channel < numberChannels; channel++) {\n            this.data[position + channel] = color[channel];\n          }\n        }\n      }\n\n      x = x + xIncrement;\n      y = y + yIncrement;\n    }\n  }\n\n  return this;\n}","map":{"version":3,"sources":["C:/Users/kuent/Documents/FinishDipshit/Creative/Ocean-Weather-Visualization/node_modules/image-js/src/image/operator/paintPolyline.js"],"names":["paintPolyline","points","options","color","maxValue","closed","checkProcessable","bitDepth","numberChannels","Math","min","channels","length","i","from","to","dx","dy","steps","max","abs","xIncrement","yIncrement","x","y","j","xPoint","round","yPoint","width","height","setBitXY","position","channel","data"],"mappings":"AAAA;;;;;;;;;;AAUA,eAAe,SAASA,aAAT,CAAuBC,MAAvB,EAA+BC,OAAO,GAAG,EAAzC,EAA6C;AAC1D,MAAI;AAAEC,IAAAA,KAAK,GAAG,CAAC,KAAKC,QAAN,EAAgB,CAAhB,EAAmB,CAAnB,CAAV;AAAiCC,IAAAA,MAAM,GAAG;AAA1C,MAAoDH,OAAxD;AAEA,OAAKI,gBAAL,CAAsB,aAAtB,EAAqC;AACnCC,IAAAA,QAAQ,EAAE,CAAC,CAAD,EAAI,CAAJ,EAAO,EAAP;AADyB,GAArC;AAIA,MAAIC,cAAc,GAAGC,IAAI,CAACC,GAAL,CAAS,KAAKC,QAAd,EAAwBR,KAAK,CAACS,MAA9B,CAArB;;AAEA,OAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGZ,MAAM,CAACW,MAAP,GAAgB,CAAhB,GAAoBP,MAAxC,EAAgDQ,CAAC,EAAjD,EAAqD;AACnD,QAAIC,IAAI,GAAGb,MAAM,CAACY,CAAD,CAAjB;AACA,QAAIE,EAAE,GAAGd,MAAM,CAAC,CAACY,CAAC,GAAG,CAAL,IAAUZ,MAAM,CAACW,MAAlB,CAAf;AAEA,QAAII,EAAE,GAAGD,EAAE,CAAC,CAAD,CAAF,GAAQD,IAAI,CAAC,CAAD,CAArB;AACA,QAAIG,EAAE,GAAGF,EAAE,CAAC,CAAD,CAAF,GAAQD,IAAI,CAAC,CAAD,CAArB;AACA,QAAII,KAAK,GAAGT,IAAI,CAACU,GAAL,CAASV,IAAI,CAACW,GAAL,CAASJ,EAAT,CAAT,EAAuBP,IAAI,CAACW,GAAL,CAASH,EAAT,CAAvB,CAAZ;AAEA,QAAII,UAAU,GAAGL,EAAE,GAAGE,KAAtB;AACA,QAAII,UAAU,GAAGL,EAAE,GAAGC,KAAtB;AAEA,QAAIK,CAAC,GAAGT,IAAI,CAAC,CAAD,CAAZ;AACA,QAAIU,CAAC,GAAGV,IAAI,CAAC,CAAD,CAAZ;;AAEA,SAAK,IAAIW,CAAC,GAAG,CAAb,EAAgBA,CAAC,IAAIP,KAArB,EAA4BO,CAAC,EAA7B,EAAiC;AAC/B,UAAIC,MAAM,GAAGjB,IAAI,CAACkB,KAAL,CAAWJ,CAAX,CAAb;AACA,UAAIK,MAAM,GAAGnB,IAAI,CAACkB,KAAL,CAAWH,CAAX,CAAb;;AACA,UACEE,MAAM,IAAI,CAAV,IACAE,MAAM,IAAI,CADV,IAEAF,MAAM,GAAG,KAAKG,KAFd,IAGAD,MAAM,GAAG,KAAKE,MAJhB,EAKE;AACA,YAAI,KAAKvB,QAAL,KAAkB,CAAtB,EAAyB;AACvB,eAAKwB,QAAL,CAAcL,MAAd,EAAsBE,MAAtB;AACD,SAFD,MAEO;AACL,cAAII,QAAQ,GAAG,CAACN,MAAM,GAAGE,MAAM,GAAG,KAAKC,KAAxB,IAAiC,KAAKlB,QAArD;;AACA,eAAK,IAAIsB,OAAO,GAAG,CAAnB,EAAsBA,OAAO,GAAGzB,cAAhC,EAAgDyB,OAAO,EAAvD,EAA2D;AACzD,iBAAKC,IAAL,CAAUF,QAAQ,GAAGC,OAArB,IAAgC9B,KAAK,CAAC8B,OAAD,CAArC;AACD;AACF;AACF;;AAEDV,MAAAA,CAAC,GAAGA,CAAC,GAAGF,UAAR;AACAG,MAAAA,CAAC,GAAGA,CAAC,GAAGF,UAAR;AACD;AACF;;AAED,SAAO,IAAP;AACD","sourcesContent":["/**\n * Paint a polyline defined by an array of points.\n * @memberof Image\n * @instance\n * @param {Array<Array<number>>} points - Array of [x,y] points\n * @param {object} [options]\n * @param {Array<number>} [options.color=[max,0,0]] - Array of 3 elements (R, G, B), default is red.\n * @param {boolean} [options.closed=false] - Close the polyline.\n * @return {this} The original painted image\n */\nexport default function paintPolyline(points, options = {}) {\n  let { color = [this.maxValue, 0, 0], closed = false } = options;\n\n  this.checkProcessable('paintPoints', {\n    bitDepth: [1, 8, 16],\n  });\n\n  let numberChannels = Math.min(this.channels, color.length);\n\n  for (let i = 0; i < points.length - 1 + closed; i++) {\n    let from = points[i];\n    let to = points[(i + 1) % points.length];\n\n    let dx = to[0] - from[0];\n    let dy = to[1] - from[1];\n    let steps = Math.max(Math.abs(dx), Math.abs(dy));\n\n    let xIncrement = dx / steps;\n    let yIncrement = dy / steps;\n\n    let x = from[0];\n    let y = from[1];\n\n    for (let j = 0; j <= steps; j++) {\n      let xPoint = Math.round(x);\n      let yPoint = Math.round(y);\n      if (\n        xPoint >= 0 &&\n        yPoint >= 0 &&\n        xPoint < this.width &&\n        yPoint < this.height\n      ) {\n        if (this.bitDepth === 1) {\n          this.setBitXY(xPoint, yPoint);\n        } else {\n          let position = (xPoint + yPoint * this.width) * this.channels;\n          for (let channel = 0; channel < numberChannels; channel++) {\n            this.data[position + channel] = color[channel];\n          }\n        }\n      }\n\n      x = x + xIncrement;\n      y = y + yIncrement;\n    }\n  }\n\n  return this;\n}\n"]},"metadata":{},"sourceType":"module"}