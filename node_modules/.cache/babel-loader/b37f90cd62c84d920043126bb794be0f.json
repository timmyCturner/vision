{"ast":null,"code":"import { validateArrayOfChannels } from '../../util/channel';\nimport { checkNumberArray } from '../../util/value';\n/**\n * @memberof Image\n * @instance\n * @param {*} value\n * @param {object} [options]\n * @return {this}\n */\n\nexport default function divide(value, options = {}) {\n  let {\n    channels\n  } = options;\n  this.checkProcessable('divide', {\n    bitDepth: [8, 16]\n  });\n  channels = validateArrayOfChannels(this, {\n    channels: channels\n  });\n  value = checkNumberArray(value);\n\n  if (!isNaN(value)) {\n    for (let j = 0; j < channels.length; j++) {\n      let c = channels[j];\n\n      for (let i = 0; i < this.data.length; i += this.channels) {\n        this.data[i + c] = Math.min(this.maxValue, this.data[i + c] / value >> 0);\n      }\n    }\n  } else {\n    if (this.data.length !== value.length) {\n      throw new Error('divide: the: the data size is different');\n    }\n\n    for (let j = 0; j < channels.length; j++) {\n      let c = channels[j];\n\n      for (let i = 0; i < this.data.length; i += this.channels) {\n        this.data[i + c] = Math.max(0, Math.min(this.maxValue, this.data[i + c] / value[i + c] >> 0));\n      }\n    }\n  }\n\n  return this;\n}","map":{"version":3,"sources":["C:/Users/kuent/Documents/FinishDipshit/Creative/Ocean-Weather-Visualization/node_modules/image-js/src/image/filter/divide.js"],"names":["validateArrayOfChannels","checkNumberArray","divide","value","options","channels","checkProcessable","bitDepth","isNaN","j","length","c","i","data","Math","min","maxValue","Error","max"],"mappings":"AAAA,SAASA,uBAAT,QAAwC,oBAAxC;AACA,SAASC,gBAAT,QAAiC,kBAAjC;AAEA;;;;;;;;AAOA,eAAe,SAASC,MAAT,CAAgBC,KAAhB,EAAuBC,OAAO,GAAG,EAAjC,EAAqC;AAClD,MAAI;AAAEC,IAAAA;AAAF,MAAeD,OAAnB;AACA,OAAKE,gBAAL,CAAsB,QAAtB,EAAgC;AAC9BC,IAAAA,QAAQ,EAAE,CAAC,CAAD,EAAI,EAAJ;AADoB,GAAhC;AAIAF,EAAAA,QAAQ,GAAGL,uBAAuB,CAAC,IAAD,EAAO;AAAEK,IAAAA,QAAQ,EAAEA;AAAZ,GAAP,CAAlC;AACAF,EAAAA,KAAK,GAAGF,gBAAgB,CAACE,KAAD,CAAxB;;AAEA,MAAI,CAACK,KAAK,CAACL,KAAD,CAAV,EAAmB;AACjB,SAAK,IAAIM,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGJ,QAAQ,CAACK,MAA7B,EAAqCD,CAAC,EAAtC,EAA0C;AACxC,UAAIE,CAAC,GAAGN,QAAQ,CAACI,CAAD,CAAhB;;AACA,WAAK,IAAIG,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG,KAAKC,IAAL,CAAUH,MAA9B,EAAsCE,CAAC,IAAI,KAAKP,QAAhD,EAA0D;AACxD,aAAKQ,IAAL,CAAUD,CAAC,GAAGD,CAAd,IAAmBG,IAAI,CAACC,GAAL,CACjB,KAAKC,QADY,EAEhB,KAAKH,IAAL,CAAUD,CAAC,GAAGD,CAAd,IAAmBR,KAApB,IAA8B,CAFb,CAAnB;AAID;AACF;AACF,GAVD,MAUO;AACL,QAAI,KAAKU,IAAL,CAAUH,MAAV,KAAqBP,KAAK,CAACO,MAA/B,EAAuC;AACrC,YAAM,IAAIO,KAAJ,CAAU,yCAAV,CAAN;AACD;;AACD,SAAK,IAAIR,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGJ,QAAQ,CAACK,MAA7B,EAAqCD,CAAC,EAAtC,EAA0C;AACxC,UAAIE,CAAC,GAAGN,QAAQ,CAACI,CAAD,CAAhB;;AACA,WAAK,IAAIG,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG,KAAKC,IAAL,CAAUH,MAA9B,EAAsCE,CAAC,IAAI,KAAKP,QAAhD,EAA0D;AACxD,aAAKQ,IAAL,CAAUD,CAAC,GAAGD,CAAd,IAAmBG,IAAI,CAACI,GAAL,CACjB,CADiB,EAEjBJ,IAAI,CAACC,GAAL,CAAS,KAAKC,QAAd,EAAyB,KAAKH,IAAL,CAAUD,CAAC,GAAGD,CAAd,IAAmBR,KAAK,CAACS,CAAC,GAAGD,CAAL,CAAzB,IAAqC,CAA7D,CAFiB,CAAnB;AAID;AACF;AACF;;AAED,SAAO,IAAP;AACD","sourcesContent":["import { validateArrayOfChannels } from '../../util/channel';\nimport { checkNumberArray } from '../../util/value';\n\n/**\n * @memberof Image\n * @instance\n * @param {*} value\n * @param {object} [options]\n * @return {this}\n */\nexport default function divide(value, options = {}) {\n  let { channels } = options;\n  this.checkProcessable('divide', {\n    bitDepth: [8, 16],\n  });\n\n  channels = validateArrayOfChannels(this, { channels: channels });\n  value = checkNumberArray(value);\n\n  if (!isNaN(value)) {\n    for (let j = 0; j < channels.length; j++) {\n      let c = channels[j];\n      for (let i = 0; i < this.data.length; i += this.channels) {\n        this.data[i + c] = Math.min(\n          this.maxValue,\n          (this.data[i + c] / value) >> 0,\n        );\n      }\n    }\n  } else {\n    if (this.data.length !== value.length) {\n      throw new Error('divide: the: the data size is different');\n    }\n    for (let j = 0; j < channels.length; j++) {\n      let c = channels[j];\n      for (let i = 0; i < this.data.length; i += this.channels) {\n        this.data[i + c] = Math.max(\n          0,\n          Math.min(this.maxValue, (this.data[i + c] / value[i + c]) >> 0),\n        );\n      }\n    }\n  }\n\n  return this;\n}\n"]},"metadata":{},"sourceType":"module"}