{"ast":null,"code":"/**\n * @memberof Image\n * @instance\n * @param {object} [options]\n * @param {number[]} [options.sampling=[10, 10]]\n * @param {boolean} [options.painted=false]\n * @param {Image} [options.mask]\n * @return {object}\n */\nexport default function getPixelsGrid(options = {}) {\n  let {\n    sampling = [10, 10],\n    painted = false,\n    mask\n  } = options;\n  this.checkProcessable('getPixelsGrid', {\n    bitDepth: [8, 16],\n    channels: 1\n  });\n\n  if (!Array.isArray(sampling)) {\n    sampling = [sampling, sampling];\n  }\n\n  const xSampling = sampling[0];\n  const ySampling = sampling[1];\n  const xyS = [];\n  const zS = [];\n  const xStep = this.width / xSampling;\n  const yStep = this.height / ySampling;\n  let currentX = Math.floor(xStep / 2);\n\n  for (let i = 0; i < xSampling; i++) {\n    let currentY = Math.floor(yStep / 2);\n\n    for (let j = 0; j < ySampling; j++) {\n      let x = Math.round(currentX);\n      let y = Math.round(currentY);\n\n      if (!mask || mask.getBitXY(x, y)) {\n        xyS.push([x, y]);\n        zS.push(this.getPixelXY(x, y));\n      }\n\n      currentY += yStep;\n    }\n\n    currentX += xStep;\n  }\n\n  const toReturn = {\n    xyS,\n    zS\n  };\n\n  if (painted) {\n    toReturn.painted = this.rgba8().paintPoints(xyS);\n  }\n\n  return toReturn;\n}","map":{"version":3,"sources":["C:/Users/kuent/Documents/FinishDipshit/Creative/Ocean-Weather-Visualization/node_modules/image-js/src/image/utility/getPixelsGrid.js"],"names":["getPixelsGrid","options","sampling","painted","mask","checkProcessable","bitDepth","channels","Array","isArray","xSampling","ySampling","xyS","zS","xStep","width","yStep","height","currentX","Math","floor","i","currentY","j","x","round","y","getBitXY","push","getPixelXY","toReturn","rgba8","paintPoints"],"mappings":"AAAA;;;;;;;;;AASA,eAAe,SAASA,aAAT,CAAuBC,OAAO,GAAG,EAAjC,EAAqC;AAClD,MAAI;AAAEC,IAAAA,QAAQ,GAAG,CAAC,EAAD,EAAK,EAAL,CAAb;AAAuBC,IAAAA,OAAO,GAAG,KAAjC;AAAwCC,IAAAA;AAAxC,MAAiDH,OAArD;AAEA,OAAKI,gBAAL,CAAsB,eAAtB,EAAuC;AACrCC,IAAAA,QAAQ,EAAE,CAAC,CAAD,EAAI,EAAJ,CAD2B;AAErCC,IAAAA,QAAQ,EAAE;AAF2B,GAAvC;;AAKA,MAAI,CAACC,KAAK,CAACC,OAAN,CAAcP,QAAd,CAAL,EAA8B;AAC5BA,IAAAA,QAAQ,GAAG,CAACA,QAAD,EAAWA,QAAX,CAAX;AACD;;AAED,QAAMQ,SAAS,GAAGR,QAAQ,CAAC,CAAD,CAA1B;AACA,QAAMS,SAAS,GAAGT,QAAQ,CAAC,CAAD,CAA1B;AAEA,QAAMU,GAAG,GAAG,EAAZ;AACA,QAAMC,EAAE,GAAG,EAAX;AAEA,QAAMC,KAAK,GAAG,KAAKC,KAAL,GAAaL,SAA3B;AACA,QAAMM,KAAK,GAAG,KAAKC,MAAL,GAAcN,SAA5B;AACA,MAAIO,QAAQ,GAAGC,IAAI,CAACC,KAAL,CAAWN,KAAK,GAAG,CAAnB,CAAf;;AAEA,OAAK,IAAIO,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGX,SAApB,EAA+BW,CAAC,EAAhC,EAAoC;AAClC,QAAIC,QAAQ,GAAGH,IAAI,CAACC,KAAL,CAAWJ,KAAK,GAAG,CAAnB,CAAf;;AACA,SAAK,IAAIO,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGZ,SAApB,EAA+BY,CAAC,EAAhC,EAAoC;AAClC,UAAIC,CAAC,GAAGL,IAAI,CAACM,KAAL,CAAWP,QAAX,CAAR;AACA,UAAIQ,CAAC,GAAGP,IAAI,CAACM,KAAL,CAAWH,QAAX,CAAR;;AACA,UAAI,CAAClB,IAAD,IAASA,IAAI,CAACuB,QAAL,CAAcH,CAAd,EAAiBE,CAAjB,CAAb,EAAkC;AAChCd,QAAAA,GAAG,CAACgB,IAAJ,CAAS,CAACJ,CAAD,EAAIE,CAAJ,CAAT;AACAb,QAAAA,EAAE,CAACe,IAAH,CAAQ,KAAKC,UAAL,CAAgBL,CAAhB,EAAmBE,CAAnB,CAAR;AACD;;AACDJ,MAAAA,QAAQ,IAAIN,KAAZ;AACD;;AACDE,IAAAA,QAAQ,IAAIJ,KAAZ;AACD;;AAED,QAAMgB,QAAQ,GAAG;AAAElB,IAAAA,GAAF;AAAOC,IAAAA;AAAP,GAAjB;;AAEA,MAAIV,OAAJ,EAAa;AACX2B,IAAAA,QAAQ,CAAC3B,OAAT,GAAmB,KAAK4B,KAAL,GAAaC,WAAb,CAAyBpB,GAAzB,CAAnB;AACD;;AAED,SAAOkB,QAAP;AACD","sourcesContent":["/**\n * @memberof Image\n * @instance\n * @param {object} [options]\n * @param {number[]} [options.sampling=[10, 10]]\n * @param {boolean} [options.painted=false]\n * @param {Image} [options.mask]\n * @return {object}\n */\nexport default function getPixelsGrid(options = {}) {\n  let { sampling = [10, 10], painted = false, mask } = options;\n\n  this.checkProcessable('getPixelsGrid', {\n    bitDepth: [8, 16],\n    channels: 1,\n  });\n\n  if (!Array.isArray(sampling)) {\n    sampling = [sampling, sampling];\n  }\n\n  const xSampling = sampling[0];\n  const ySampling = sampling[1];\n\n  const xyS = [];\n  const zS = [];\n\n  const xStep = this.width / xSampling;\n  const yStep = this.height / ySampling;\n  let currentX = Math.floor(xStep / 2);\n\n  for (let i = 0; i < xSampling; i++) {\n    let currentY = Math.floor(yStep / 2);\n    for (let j = 0; j < ySampling; j++) {\n      let x = Math.round(currentX);\n      let y = Math.round(currentY);\n      if (!mask || mask.getBitXY(x, y)) {\n        xyS.push([x, y]);\n        zS.push(this.getPixelXY(x, y));\n      }\n      currentY += yStep;\n    }\n    currentX += xStep;\n  }\n\n  const toReturn = { xyS, zS };\n\n  if (painted) {\n    toReturn.painted = this.rgba8().paintPoints(xyS);\n  }\n\n  return toReturn;\n}\n"]},"metadata":{},"sourceType":"module"}