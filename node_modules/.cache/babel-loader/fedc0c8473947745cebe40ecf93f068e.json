{"ast":null,"code":"import PriorityQueue from 'js-priority-queue';\nimport { dxs, dys } from '../../../util/dxdy.js';\nimport RoiMap from '../RoiMap';\n/**\n * This method allows to create a ROIMap using the water shed algorithm. By default this algorithm\n * will fill the holes and therefore the lowest value of the image (black zones).\n * If no points are given, the function will look for all the minimal points.\n * If no mask is given the algorithm will completely fill the image.\n * Please take care about the value that has be in the mask ! In order to be coherent with the expected mask,\n * meaning that if it is a dark zone, the mask will be dark the normal behaviour to fill a zone\n * is that the mask pixel is clear (value of 0) !\n * However if you work in the 'invert' mode, the mask value has to be 'set' and the method will look for\n * maxima.\n * @memberof RoiManager\n * @instance\n * @param {object} [options={}]\n * @param {Array<Array<number>>} [options.points] - Array of points [[x1,y1], [x2,y2], ...].\n * @param {number} [options.fillMaxValue] - Limit of filling. By example, we can fill to a maximum value 32000 of a 16 bitDepth image.\n *          If invert this will corresponds to the minimal value\n * @param {Image} [options.image=this] - By default the waterShed will be applied on the current image. However waterShed can only be applied\n *                              on 1 component image. This allows to specify a grey scale image on which to apply waterShed..\n * @param {Image} [options.mask] - A binary image, the same size as the image. The algorithm will fill only if the current pixel in the binary mask is true.\n * @param {boolean} [options.invert=false] - By default we fill the minima\n * @return {RoiMap}\n */\n\nexport default function fromWaterShed(options = {}) {\n  let {\n    points,\n    mask,\n    image,\n    fillMaxValue = this.maxValue,\n    invert = false\n  } = options;\n  let currentImage = image || this;\n  currentImage.checkProcessable('fromWaterShed', {\n    bitDepth: [8, 16],\n    components: 1\n  });\n  /*\n     We need to invert the logic because we are always using method to look for maxima and not minima and\n     here water is expected to fill the minima first ...\n    */\n\n  invert = !invert; // WaterShed is done from points in the image. We can either specify those points in options,\n  // or it is gonna take the minimum locals of the image by default.\n\n  if (!points) {\n    points = currentImage.getLocalMaxima({\n      invert,\n      mask\n    });\n  }\n\n  let maskExpectedValue = invert ? 0 : 1;\n  let data = new Int16Array(currentImage.size);\n  let width = currentImage.width;\n  let height = currentImage.height;\n  let toProcess = new PriorityQueue({\n    comparator: (a, b) => a[2] - b[2],\n    strategy: PriorityQueue.BinaryHeapStrategy\n  });\n\n  for (let i = 0; i < points.length; i++) {\n    let index = points[i][0] + points[i][1] * width;\n    data[index] = i + 1;\n    let intensity = currentImage.data[index];\n\n    if (invert && intensity <= fillMaxValue || !invert && intensity >= fillMaxValue) {\n      toProcess.queue([points[i][0], points[i][1], intensity]);\n    }\n  } // Then we iterate through each points\n\n\n  while (toProcess.length > 0) {\n    let currentPoint = toProcess.dequeue();\n    let currentValueIndex = currentPoint[0] + currentPoint[1] * width;\n\n    for (let dir = 0; dir < 4; dir++) {\n      let newX = currentPoint[0] + dxs[dir];\n      let newY = currentPoint[1] + dys[dir];\n\n      if (newX >= 0 && newY >= 0 && newX < width && newY < height) {\n        let currentNeighbourIndex = newX + newY * width;\n\n        if (!mask || mask.getBit(currentNeighbourIndex) === maskExpectedValue) {\n          let intensity = currentImage.data[currentNeighbourIndex];\n\n          if (invert && intensity <= fillMaxValue || !invert && intensity >= fillMaxValue) {\n            if (data[currentNeighbourIndex] === 0) {\n              data[currentNeighbourIndex] = data[currentValueIndex];\n              toProcess.queue([currentPoint[0] + dxs[dir], currentPoint[1] + dys[dir], intensity]);\n            }\n          }\n        }\n      }\n    }\n  }\n\n  return new RoiMap(currentImage, data);\n}","map":{"version":3,"sources":["C:/Users/kuent/Documents/FinishDipshit/Creative/Ocean-Weather-Visualization/node_modules/image-js/src/image/roi/creator/fromWaterShed.js"],"names":["PriorityQueue","dxs","dys","RoiMap","fromWaterShed","options","points","mask","image","fillMaxValue","maxValue","invert","currentImage","checkProcessable","bitDepth","components","getLocalMaxima","maskExpectedValue","data","Int16Array","size","width","height","toProcess","comparator","a","b","strategy","BinaryHeapStrategy","i","length","index","intensity","queue","currentPoint","dequeue","currentValueIndex","dir","newX","newY","currentNeighbourIndex","getBit"],"mappings":"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","sourcesContent":["import PriorityQueue from 'js-priority-queue';\n\nimport { dxs, dys } from '../../../util/dxdy.js';\nimport RoiMap from '../RoiMap';\n\n/**\n * This method allows to create a ROIMap using the water shed algorithm. By default this algorithm\n * will fill the holes and therefore the lowest value of the image (black zones).\n * If no points are given, the function will look for all the minimal points.\n * If no mask is given the algorithm will completely fill the image.\n * Please take care about the value that has be in the mask ! In order to be coherent with the expected mask,\n * meaning that if it is a dark zone, the mask will be dark the normal behaviour to fill a zone\n * is that the mask pixel is clear (value of 0) !\n * However if you work in the 'invert' mode, the mask value has to be 'set' and the method will look for\n * maxima.\n * @memberof RoiManager\n * @instance\n * @param {object} [options={}]\n * @param {Array<Array<number>>} [options.points] - Array of points [[x1,y1], [x2,y2], ...].\n * @param {number} [options.fillMaxValue] - Limit of filling. By example, we can fill to a maximum value 32000 of a 16 bitDepth image.\n *          If invert this will corresponds to the minimal value\n * @param {Image} [options.image=this] - By default the waterShed will be applied on the current image. However waterShed can only be applied\n *                              on 1 component image. This allows to specify a grey scale image on which to apply waterShed..\n * @param {Image} [options.mask] - A binary image, the same size as the image. The algorithm will fill only if the current pixel in the binary mask is true.\n * @param {boolean} [options.invert=false] - By default we fill the minima\n * @return {RoiMap}\n */\nexport default function fromWaterShed(options = {}) {\n  let {\n    points,\n    mask,\n    image,\n    fillMaxValue = this.maxValue,\n    invert = false,\n  } = options;\n  let currentImage = image || this;\n  currentImage.checkProcessable('fromWaterShed', {\n    bitDepth: [8, 16],\n    components: 1,\n  });\n\n  /*\n     We need to invert the logic because we are always using method to look for maxima and not minima and\n     here water is expected to fill the minima first ...\n    */\n\n  invert = !invert;\n\n  // WaterShed is done from points in the image. We can either specify those points in options,\n  // or it is gonna take the minimum locals of the image by default.\n  if (!points) {\n    points = currentImage.getLocalMaxima({\n      invert,\n      mask,\n    });\n  }\n\n  let maskExpectedValue = invert ? 0 : 1;\n\n  let data = new Int16Array(currentImage.size);\n  let width = currentImage.width;\n  let height = currentImage.height;\n  let toProcess = new PriorityQueue({\n    comparator: (a, b) => a[2] - b[2],\n    strategy: PriorityQueue.BinaryHeapStrategy,\n  });\n  for (let i = 0; i < points.length; i++) {\n    let index = points[i][0] + points[i][1] * width;\n    data[index] = i + 1;\n    let intensity = currentImage.data[index];\n    if (\n      (invert && intensity <= fillMaxValue) ||\n      (!invert && intensity >= fillMaxValue)\n    ) {\n      toProcess.queue([points[i][0], points[i][1], intensity]);\n    }\n  }\n\n  // Then we iterate through each points\n  while (toProcess.length > 0) {\n    let currentPoint = toProcess.dequeue();\n    let currentValueIndex = currentPoint[0] + currentPoint[1] * width;\n\n    for (let dir = 0; dir < 4; dir++) {\n      let newX = currentPoint[0] + dxs[dir];\n      let newY = currentPoint[1] + dys[dir];\n      if (newX >= 0 && newY >= 0 && newX < width && newY < height) {\n        let currentNeighbourIndex = newX + newY * width;\n        if (!mask || mask.getBit(currentNeighbourIndex) === maskExpectedValue) {\n          let intensity = currentImage.data[currentNeighbourIndex];\n          if (\n            (invert && intensity <= fillMaxValue) ||\n            (!invert && intensity >= fillMaxValue)\n          ) {\n            if (data[currentNeighbourIndex] === 0) {\n              data[currentNeighbourIndex] = data[currentValueIndex];\n              toProcess.queue([\n                currentPoint[0] + dxs[dir],\n                currentPoint[1] + dys[dir],\n                intensity,\n              ]);\n            }\n          }\n        }\n      }\n    }\n  }\n\n  return new RoiMap(currentImage, data);\n}\n"]},"metadata":{},"sourceType":"module"}