{"ast":null,"code":"import { validateArrayOfChannels } from '../../util/channel';\nimport Image from '../Image';\n/**\n * Calculate a new image that is the hypotenuse between the current image and the otherImage.\n * @memberof Image\n * @instance\n * @param {Image} otherImage\n * @param {object} [options={}]\n * @param {number} [options.bitDepth=this.bitDepth]\n * @param {number[]|string[]} [options.channels] : to which channel to apply the filter. By default all but alpha.\n * @return {Image}\n */\n\nexport default function hypotenuse(otherImage, options = {}) {\n  let {\n    bitDepth = this.bitDepth,\n    channels\n  } = options;\n  this.checkProcessable('hypotenuse', {\n    bitDepth: [8, 16, 32]\n  });\n\n  if (this.width !== otherImage.width || this.height !== otherImage.height) {\n    throw new Error('hypotenuse: both images must have the same size');\n  }\n\n  if (this.alpha !== otherImage.alpha || this.bitDepth !== otherImage.bitDepth) {\n    throw new Error('hypotenuse: both images must have the same alpha and bitDepth');\n  }\n\n  if (this.channels !== otherImage.channels) {\n    throw new Error('hypotenuse: both images must have the same number of channels');\n  }\n\n  let newImage = Image.createFrom(this, {\n    bitDepth: bitDepth\n  });\n  channels = validateArrayOfChannels(this, {\n    channels: channels\n  });\n  let clamped = newImage.isClamped;\n\n  for (let j = 0; j < channels.length; j++) {\n    let c = channels[j];\n\n    for (let i = c; i < this.data.length; i += this.channels) {\n      let value = Math.hypot(this.data[i], otherImage.data[i]);\n\n      if (clamped) {\n        // we calculate the clamped result\n        newImage.data[i] = Math.min(Math.max(Math.round(value), 0), newImage.maxValue);\n      } else {\n        newImage.data[i] = value;\n      }\n    }\n  }\n\n  return newImage;\n}","map":{"version":3,"sources":["C:/Users/kuent/Documents/FinishDipshit/Creative/Ocean-Weather-Visualization/node_modules/image-js/src/image/filter/hypotenuse.js"],"names":["validateArrayOfChannels","Image","hypotenuse","otherImage","options","bitDepth","channels","checkProcessable","width","height","Error","alpha","newImage","createFrom","clamped","isClamped","j","length","c","i","data","value","Math","hypot","min","max","round","maxValue"],"mappings":"AAAA,SAASA,uBAAT,QAAwC,oBAAxC;AACA,OAAOC,KAAP,MAAkB,UAAlB;AAEA;;;;;;;;;;;AAUA,eAAe,SAASC,UAAT,CAAoBC,UAApB,EAAgCC,OAAO,GAAG,EAA1C,EAA8C;AAC3D,MAAI;AAAEC,IAAAA,QAAQ,GAAG,KAAKA,QAAlB;AAA4BC,IAAAA;AAA5B,MAAyCF,OAA7C;AACA,OAAKG,gBAAL,CAAsB,YAAtB,EAAoC;AAClCF,IAAAA,QAAQ,EAAE,CAAC,CAAD,EAAI,EAAJ,EAAQ,EAAR;AADwB,GAApC;;AAGA,MAAI,KAAKG,KAAL,KAAeL,UAAU,CAACK,KAA1B,IAAmC,KAAKC,MAAL,KAAgBN,UAAU,CAACM,MAAlE,EAA0E;AACxE,UAAM,IAAIC,KAAJ,CAAU,iDAAV,CAAN;AACD;;AACD,MACE,KAAKC,KAAL,KAAeR,UAAU,CAACQ,KAA1B,IACA,KAAKN,QAAL,KAAkBF,UAAU,CAACE,QAF/B,EAGE;AACA,UAAM,IAAIK,KAAJ,CACJ,+DADI,CAAN;AAGD;;AACD,MAAI,KAAKJ,QAAL,KAAkBH,UAAU,CAACG,QAAjC,EAA2C;AACzC,UAAM,IAAII,KAAJ,CACJ,+DADI,CAAN;AAGD;;AAED,MAAIE,QAAQ,GAAGX,KAAK,CAACY,UAAN,CAAiB,IAAjB,EAAuB;AAAER,IAAAA,QAAQ,EAAEA;AAAZ,GAAvB,CAAf;AAEAC,EAAAA,QAAQ,GAAGN,uBAAuB,CAAC,IAAD,EAAO;AAAEM,IAAAA,QAAQ,EAAEA;AAAZ,GAAP,CAAlC;AAEA,MAAIQ,OAAO,GAAGF,QAAQ,CAACG,SAAvB;;AAEA,OAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGV,QAAQ,CAACW,MAA7B,EAAqCD,CAAC,EAAtC,EAA0C;AACxC,QAAIE,CAAC,GAAGZ,QAAQ,CAACU,CAAD,CAAhB;;AACA,SAAK,IAAIG,CAAC,GAAGD,CAAb,EAAgBC,CAAC,GAAG,KAAKC,IAAL,CAAUH,MAA9B,EAAsCE,CAAC,IAAI,KAAKb,QAAhD,EAA0D;AACxD,UAAIe,KAAK,GAAGC,IAAI,CAACC,KAAL,CAAW,KAAKH,IAAL,CAAUD,CAAV,CAAX,EAAyBhB,UAAU,CAACiB,IAAX,CAAgBD,CAAhB,CAAzB,CAAZ;;AACA,UAAIL,OAAJ,EAAa;AACX;AACAF,QAAAA,QAAQ,CAACQ,IAAT,CAAcD,CAAd,IAAmBG,IAAI,CAACE,GAAL,CACjBF,IAAI,CAACG,GAAL,CAASH,IAAI,CAACI,KAAL,CAAWL,KAAX,CAAT,EAA4B,CAA5B,CADiB,EAEjBT,QAAQ,CAACe,QAFQ,CAAnB;AAID,OAND,MAMO;AACLf,QAAAA,QAAQ,CAACQ,IAAT,CAAcD,CAAd,IAAmBE,KAAnB;AACD;AACF;AACF;;AAED,SAAOT,QAAP;AACD","sourcesContent":["import { validateArrayOfChannels } from '../../util/channel';\nimport Image from '../Image';\n\n/**\n * Calculate a new image that is the hypotenuse between the current image and the otherImage.\n * @memberof Image\n * @instance\n * @param {Image} otherImage\n * @param {object} [options={}]\n * @param {number} [options.bitDepth=this.bitDepth]\n * @param {number[]|string[]} [options.channels] : to which channel to apply the filter. By default all but alpha.\n * @return {Image}\n */\nexport default function hypotenuse(otherImage, options = {}) {\n  let { bitDepth = this.bitDepth, channels } = options;\n  this.checkProcessable('hypotenuse', {\n    bitDepth: [8, 16, 32],\n  });\n  if (this.width !== otherImage.width || this.height !== otherImage.height) {\n    throw new Error('hypotenuse: both images must have the same size');\n  }\n  if (\n    this.alpha !== otherImage.alpha ||\n    this.bitDepth !== otherImage.bitDepth\n  ) {\n    throw new Error(\n      'hypotenuse: both images must have the same alpha and bitDepth',\n    );\n  }\n  if (this.channels !== otherImage.channels) {\n    throw new Error(\n      'hypotenuse: both images must have the same number of channels',\n    );\n  }\n\n  let newImage = Image.createFrom(this, { bitDepth: bitDepth });\n\n  channels = validateArrayOfChannels(this, { channels: channels });\n\n  let clamped = newImage.isClamped;\n\n  for (let j = 0; j < channels.length; j++) {\n    let c = channels[j];\n    for (let i = c; i < this.data.length; i += this.channels) {\n      let value = Math.hypot(this.data[i], otherImage.data[i]);\n      if (clamped) {\n        // we calculate the clamped result\n        newImage.data[i] = Math.min(\n          Math.max(Math.round(value), 0),\n          newImage.maxValue,\n        );\n      } else {\n        newImage.data[i] = value;\n      }\n    }\n  }\n\n  return newImage;\n}\n"]},"metadata":{},"sourceType":"module"}