{"ast":null,"code":"import { clamp } from '../internal/clamp';\nimport { getOutputImage } from '../internal/getOutputImage';\nimport { GREY } from '../model/model';\nimport { methods } from './greyAlgorithms';\n/**\n * Call back that converts the RGB channels to grey. It will be clamped after.\n * @callback GreyAlgorithmCallback\n * @param {number} red - value of the red channel\n * @param {number} green - value of the green channel\n * @param {number} blue - value of the blue channel\n * @return {number} value of the grey channel\n */\n\n/**\n * Converts the current image to greyscale.\n * The source image has to be RGB.\n * If there is an alpha channel we need to decide what to do:\n * * keepAlpha : we will keep the alpha channel and you will get a GREY / A image\n * * mergeAlpha : we will multiply each pixel of the image by the alpha\n * @memberof Image\n * @instance\n * @param {object} [options]\n * @param {GreyAlgorithm|GreyAlgorithmCallback} [options.algorithm='luma709'] - Algorithm to get the grey value from RGB values\n * @param {boolean} [options.keepAlpha=false] - If true, the RGB values are treated\n *          separately from the alpha channel and the method returns a GREYA image.\n * @param {boolean} [options.mergeAlpha=true] - If true, the alpha channel will be used to scale the grey pixel.\n * @param {Image} [options.out]\n * @return {Image}\n */\n\nexport default function grey(options = {}) {\n  let {\n    algorithm = 'luma709',\n    keepAlpha = false,\n    mergeAlpha = true\n  } = options;\n\n  if (typeof algorithm !== 'string' && typeof algorithm !== 'function') {\n    throw new TypeError('algorithm must be a string or a function');\n  }\n\n  this.checkProcessable('grey', {\n    bitDepth: [8, 16],\n    alpha: [0, 1]\n  });\n\n  if (this.components === 1) {\n    algorithm = 'red'; // actually we just take the first channel if it is a grey image\n  }\n\n  keepAlpha &= this.alpha;\n  mergeAlpha &= this.alpha;\n\n  if (keepAlpha) {\n    mergeAlpha = false;\n  }\n\n  let newImage = getOutputImage(this, options, {\n    components: 1,\n    alpha: keepAlpha,\n    colorModel: GREY\n  });\n  let method;\n\n  if (typeof algorithm === 'function') {\n    method = algorithm;\n  } else {\n    method = methods[algorithm.toLowerCase()];\n\n    if (!method) {\n      throw new Error(`unsupported grey algorithm: ${algorithm}`);\n    }\n  }\n\n  let ptr = 0;\n\n  for (let i = 0; i < this.data.length; i += this.channels) {\n    if (mergeAlpha) {\n      newImage.data[ptr++] = clamp(method(this.data[i], this.data[i + 1], this.data[i + 2], this) * this.data[i + this.components] / this.maxValue, this);\n    } else {\n      newImage.data[ptr++] = clamp(method(this.data[i], this.data[i + 1], this.data[i + 2], this), this);\n\n      if (newImage.alpha) {\n        newImage.data[ptr++] = this.data[i + this.components];\n      }\n    }\n  }\n\n  return newImage;\n}","map":{"version":3,"sources":["C:/Users/kuent/Documents/FinishDipshit/Creative/Ocean-Weather-Visualization/node_modules/image-js/src/image/transform/grey.js"],"names":["clamp","getOutputImage","GREY","methods","grey","options","algorithm","keepAlpha","mergeAlpha","TypeError","checkProcessable","bitDepth","alpha","components","newImage","colorModel","method","toLowerCase","Error","ptr","i","data","length","channels","maxValue"],"mappings":"AAAA,SAASA,KAAT,QAAsB,mBAAtB;AACA,SAASC,cAAT,QAA+B,4BAA/B;AACA,SAASC,IAAT,QAAqB,gBAArB;AAEA,SAASC,OAAT,QAAwB,kBAAxB;AAEA;;;;;;;;;AASA;;;;;;;;;;;;;;;;;AAgBA,eAAe,SAASC,IAAT,CAAcC,OAAO,GAAG,EAAxB,EAA4B;AACzC,MAAI;AAAEC,IAAAA,SAAS,GAAG,SAAd;AAAyBC,IAAAA,SAAS,GAAG,KAArC;AAA4CC,IAAAA,UAAU,GAAG;AAAzD,MAAkEH,OAAtE;;AAEA,MAAI,OAAOC,SAAP,KAAqB,QAArB,IAAiC,OAAOA,SAAP,KAAqB,UAA1D,EAAsE;AACpE,UAAM,IAAIG,SAAJ,CAAc,0CAAd,CAAN;AACD;;AAED,OAAKC,gBAAL,CAAsB,MAAtB,EAA8B;AAC5BC,IAAAA,QAAQ,EAAE,CAAC,CAAD,EAAI,EAAJ,CADkB;AAE5BC,IAAAA,KAAK,EAAE,CAAC,CAAD,EAAI,CAAJ;AAFqB,GAA9B;;AAKA,MAAI,KAAKC,UAAL,KAAoB,CAAxB,EAA2B;AACzBP,IAAAA,SAAS,GAAG,KAAZ,CADyB,CACN;AACpB;;AAEDC,EAAAA,SAAS,IAAI,KAAKK,KAAlB;AACAJ,EAAAA,UAAU,IAAI,KAAKI,KAAnB;;AACA,MAAIL,SAAJ,EAAe;AACbC,IAAAA,UAAU,GAAG,KAAb;AACD;;AAED,MAAIM,QAAQ,GAAGb,cAAc,CAAC,IAAD,EAAOI,OAAP,EAAgB;AAC3CQ,IAAAA,UAAU,EAAE,CAD+B;AAE3CD,IAAAA,KAAK,EAAEL,SAFoC;AAG3CQ,IAAAA,UAAU,EAAEb;AAH+B,GAAhB,CAA7B;AAMA,MAAIc,MAAJ;;AACA,MAAI,OAAOV,SAAP,KAAqB,UAAzB,EAAqC;AACnCU,IAAAA,MAAM,GAAGV,SAAT;AACD,GAFD,MAEO;AACLU,IAAAA,MAAM,GAAGb,OAAO,CAACG,SAAS,CAACW,WAAV,EAAD,CAAhB;;AACA,QAAI,CAACD,MAAL,EAAa;AACX,YAAM,IAAIE,KAAJ,CAAW,+BAA8BZ,SAAU,EAAnD,CAAN;AACD;AACF;;AAED,MAAIa,GAAG,GAAG,CAAV;;AACA,OAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG,KAAKC,IAAL,CAAUC,MAA9B,EAAsCF,CAAC,IAAI,KAAKG,QAAhD,EAA0D;AACxD,QAAIf,UAAJ,EAAgB;AACdM,MAAAA,QAAQ,CAACO,IAAT,CAAcF,GAAG,EAAjB,IAAuBnB,KAAK,CACzBgB,MAAM,CAAC,KAAKK,IAAL,CAAUD,CAAV,CAAD,EAAe,KAAKC,IAAL,CAAUD,CAAC,GAAG,CAAd,CAAf,EAAiC,KAAKC,IAAL,CAAUD,CAAC,GAAG,CAAd,CAAjC,EAAmD,IAAnD,CAAN,GACC,KAAKC,IAAL,CAAUD,CAAC,GAAG,KAAKP,UAAnB,CADF,GAEE,KAAKW,QAHmB,EAI1B,IAJ0B,CAA5B;AAMD,KAPD,MAOO;AACLV,MAAAA,QAAQ,CAACO,IAAT,CAAcF,GAAG,EAAjB,IAAuBnB,KAAK,CAC1BgB,MAAM,CAAC,KAAKK,IAAL,CAAUD,CAAV,CAAD,EAAe,KAAKC,IAAL,CAAUD,CAAC,GAAG,CAAd,CAAf,EAAiC,KAAKC,IAAL,CAAUD,CAAC,GAAG,CAAd,CAAjC,EAAmD,IAAnD,CADoB,EAE1B,IAF0B,CAA5B;;AAIA,UAAIN,QAAQ,CAACF,KAAb,EAAoB;AAClBE,QAAAA,QAAQ,CAACO,IAAT,CAAcF,GAAG,EAAjB,IAAuB,KAAKE,IAAL,CAAUD,CAAC,GAAG,KAAKP,UAAnB,CAAvB;AACD;AACF;AACF;;AAED,SAAOC,QAAP;AACD","sourcesContent":["import { clamp } from '../internal/clamp';\nimport { getOutputImage } from '../internal/getOutputImage';\nimport { GREY } from '../model/model';\n\nimport { methods } from './greyAlgorithms';\n\n/**\n * Call back that converts the RGB channels to grey. It will be clamped after.\n * @callback GreyAlgorithmCallback\n * @param {number} red - value of the red channel\n * @param {number} green - value of the green channel\n * @param {number} blue - value of the blue channel\n * @return {number} value of the grey channel\n */\n\n/**\n * Converts the current image to greyscale.\n * The source image has to be RGB.\n * If there is an alpha channel we need to decide what to do:\n * * keepAlpha : we will keep the alpha channel and you will get a GREY / A image\n * * mergeAlpha : we will multiply each pixel of the image by the alpha\n * @memberof Image\n * @instance\n * @param {object} [options]\n * @param {GreyAlgorithm|GreyAlgorithmCallback} [options.algorithm='luma709'] - Algorithm to get the grey value from RGB values\n * @param {boolean} [options.keepAlpha=false] - If true, the RGB values are treated\n *          separately from the alpha channel and the method returns a GREYA image.\n * @param {boolean} [options.mergeAlpha=true] - If true, the alpha channel will be used to scale the grey pixel.\n * @param {Image} [options.out]\n * @return {Image}\n */\nexport default function grey(options = {}) {\n  let { algorithm = 'luma709', keepAlpha = false, mergeAlpha = true } = options;\n\n  if (typeof algorithm !== 'string' && typeof algorithm !== 'function') {\n    throw new TypeError('algorithm must be a string or a function');\n  }\n\n  this.checkProcessable('grey', {\n    bitDepth: [8, 16],\n    alpha: [0, 1],\n  });\n\n  if (this.components === 1) {\n    algorithm = 'red'; // actually we just take the first channel if it is a grey image\n  }\n\n  keepAlpha &= this.alpha;\n  mergeAlpha &= this.alpha;\n  if (keepAlpha) {\n    mergeAlpha = false;\n  }\n\n  let newImage = getOutputImage(this, options, {\n    components: 1,\n    alpha: keepAlpha,\n    colorModel: GREY,\n  });\n\n  let method;\n  if (typeof algorithm === 'function') {\n    method = algorithm;\n  } else {\n    method = methods[algorithm.toLowerCase()];\n    if (!method) {\n      throw new Error(`unsupported grey algorithm: ${algorithm}`);\n    }\n  }\n\n  let ptr = 0;\n  for (let i = 0; i < this.data.length; i += this.channels) {\n    if (mergeAlpha) {\n      newImage.data[ptr++] = clamp(\n        (method(this.data[i], this.data[i + 1], this.data[i + 2], this) *\n          this.data[i + this.components]) /\n          this.maxValue,\n        this,\n      );\n    } else {\n      newImage.data[ptr++] = clamp(\n        method(this.data[i], this.data[i + 1], this.data[i + 2], this),\n        this,\n      );\n      if (newImage.alpha) {\n        newImage.data[ptr++] = this.data[i + this.components];\n      }\n    }\n  }\n\n  return newImage;\n}\n"]},"metadata":{},"sourceType":"module"}