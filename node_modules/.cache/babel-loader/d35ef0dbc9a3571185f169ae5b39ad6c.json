{"ast":null,"code":"import FFT from 'fft.js';\nimport nextPOT from 'next-power-of-two';\nexport default function fftConvolution(input, kernel) {\n  const resultLength = input.length + kernel.length - 1;\n  const fftLength = nextPOT(resultLength);\n  const fft = new FFT(fftLength);\n  const {\n    output: fftKernel,\n    input: result\n  } = createPaddedFFt(kernel, fft, fftLength);\n  const {\n    output: fftInput\n  } = createPaddedFFt(input, fft, fftLength); // reuse arrays\n\n  const fftConv = fftInput;\n  const conv = fftKernel;\n\n  for (var i = 0; i < fftConv.length; i += 2) {\n    const tmp = fftInput[i] * fftKernel[i] - fftInput[i + 1] * fftKernel[i + 1];\n    fftConv[i + 1] = fftInput[i] * fftKernel[i + 1] + fftInput[i + 1] * fftKernel[i];\n    fftConv[i] = tmp;\n  }\n\n  fft.inverseTransform(conv, fftConv);\n  return fft.fromComplexArray(conv, result).slice(0, resultLength);\n}\n\nfunction createPaddedFFt(data, fft, length) {\n  const input = new Array(length);\n  var i = 0;\n\n  for (; i < data.length; i++) {\n    input[i] = data[i];\n  }\n\n  for (; i < length; i++) {\n    input[i] = 0;\n  }\n\n  const fftInput = fft.toComplexArray(input);\n  const output = fft.createComplexArray();\n  fft.transform(output, fftInput);\n  return {\n    output,\n    input,\n    fftInput\n  };\n}","map":{"version":3,"sources":["C:/Users/kuent/Documents/FinishDipshit/Creative/Ocean-Weather-Visualization/node_modules/ml-convolution/src/fftConvolution.js"],"names":["FFT","nextPOT","fftConvolution","input","kernel","resultLength","length","fftLength","fft","output","fftKernel","result","createPaddedFFt","fftInput","fftConv","conv","i","tmp","inverseTransform","fromComplexArray","slice","data","Array","toComplexArray","createComplexArray","transform"],"mappings":"AAAA,OAAOA,GAAP,MAAgB,QAAhB;AACA,OAAOC,OAAP,MAAoB,mBAApB;AAEA,eAAe,SAASC,cAAT,CAAwBC,KAAxB,EAA+BC,MAA/B,EAAuC;AAClD,QAAMC,YAAY,GAAGF,KAAK,CAACG,MAAN,GAAeF,MAAM,CAACE,MAAtB,GAA+B,CAApD;AACA,QAAMC,SAAS,GAAGN,OAAO,CAACI,YAAD,CAAzB;AAEA,QAAMG,GAAG,GAAG,IAAIR,GAAJ,CAAQO,SAAR,CAAZ;AAEA,QAAM;AAACE,IAAAA,MAAM,EAAEC,SAAT;AAAoBP,IAAAA,KAAK,EAAEQ;AAA3B,MAAqCC,eAAe,CAACR,MAAD,EAASI,GAAT,EAAcD,SAAd,CAA1D;AACA,QAAM;AAACE,IAAAA,MAAM,EAAEI;AAAT,MAAqBD,eAAe,CAACT,KAAD,EAAQK,GAAR,EAAaD,SAAb,CAA1C,CAPkD,CASlD;;AACA,QAAMO,OAAO,GAAGD,QAAhB;AACA,QAAME,IAAI,GAAGL,SAAb;;AACA,OAAK,IAAIM,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGF,OAAO,CAACR,MAA5B,EAAoCU,CAAC,IAAI,CAAzC,EAA4C;AACxC,UAAMC,GAAG,GAAGJ,QAAQ,CAACG,CAAD,CAAR,GAAcN,SAAS,CAACM,CAAD,CAAvB,GAA6BH,QAAQ,CAACG,CAAC,GAAG,CAAL,CAAR,GAAkBN,SAAS,CAACM,CAAC,GAAG,CAAL,CAApE;AACAF,IAAAA,OAAO,CAACE,CAAC,GAAG,CAAL,CAAP,GAAiBH,QAAQ,CAACG,CAAD,CAAR,GAAcN,SAAS,CAACM,CAAC,GAAG,CAAL,CAAvB,GAAiCH,QAAQ,CAACG,CAAC,GAAG,CAAL,CAAR,GAAkBN,SAAS,CAACM,CAAD,CAA7E;AACAF,IAAAA,OAAO,CAACE,CAAD,CAAP,GAAaC,GAAb;AACH;;AACDT,EAAAA,GAAG,CAACU,gBAAJ,CAAqBH,IAArB,EAA2BD,OAA3B;AACA,SAAON,GAAG,CAACW,gBAAJ,CAAqBJ,IAArB,EAA2BJ,MAA3B,EAAmCS,KAAnC,CAAyC,CAAzC,EAA4Cf,YAA5C,CAAP;AACH;;AAED,SAASO,eAAT,CAAyBS,IAAzB,EAA+Bb,GAA/B,EAAoCF,MAApC,EAA4C;AACxC,QAAMH,KAAK,GAAG,IAAImB,KAAJ,CAAUhB,MAAV,CAAd;AACA,MAAIU,CAAC,GAAG,CAAR;;AACA,SAAOA,CAAC,GAAGK,IAAI,CAACf,MAAhB,EAAwBU,CAAC,EAAzB,EAA6B;AACzBb,IAAAA,KAAK,CAACa,CAAD,CAAL,GAAWK,IAAI,CAACL,CAAD,CAAf;AACH;;AACD,SAAMA,CAAC,GAAGV,MAAV,EAAkBU,CAAC,EAAnB,EAAuB;AACnBb,IAAAA,KAAK,CAACa,CAAD,CAAL,GAAW,CAAX;AACH;;AACD,QAAMH,QAAQ,GAAGL,GAAG,CAACe,cAAJ,CAAmBpB,KAAnB,CAAjB;AACA,QAAMM,MAAM,GAAGD,GAAG,CAACgB,kBAAJ,EAAf;AACAhB,EAAAA,GAAG,CAACiB,SAAJ,CAAchB,MAAd,EAAsBI,QAAtB;AACA,SAAO;AACHJ,IAAAA,MADG;AAEHN,IAAAA,KAFG;AAGHU,IAAAA;AAHG,GAAP;AAKH","sourcesContent":["import FFT from 'fft.js';\nimport nextPOT from 'next-power-of-two';\n\nexport default function fftConvolution(input, kernel) {\n    const resultLength = input.length + kernel.length - 1;\n    const fftLength = nextPOT(resultLength);\n\n    const fft = new FFT(fftLength);\n\n    const {output: fftKernel, input: result} = createPaddedFFt(kernel, fft, fftLength);\n    const {output: fftInput} = createPaddedFFt(input, fft, fftLength);\n\n    // reuse arrays\n    const fftConv = fftInput;\n    const conv = fftKernel;\n    for (var i = 0; i < fftConv.length; i += 2) {\n        const tmp = fftInput[i] * fftKernel[i] - fftInput[i + 1] * fftKernel[i + 1];\n        fftConv[i + 1] = fftInput[i] * fftKernel[i + 1] + fftInput[i + 1] * fftKernel[i];\n        fftConv[i] = tmp;\n    }\n    fft.inverseTransform(conv, fftConv);\n    return fft.fromComplexArray(conv, result).slice(0, resultLength);\n}\n\nfunction createPaddedFFt(data, fft, length) {\n    const input = new Array(length);\n    var i = 0;\n    for (; i < data.length; i++) {\n        input[i] = data[i];\n    }\n    for (;i < length; i++) {\n        input[i] = 0;\n    }\n    const fftInput = fft.toComplexArray(input);\n    const output = fft.createComplexArray();\n    fft.transform(output, fftInput);\n    return {\n        output,\n        input,\n        fftInput\n    };\n}\n"]},"metadata":{},"sourceType":"module"}