{"ast":null,"code":"import RoiMap from '../RoiMap';\n/**\n * @memberof RoiManager\n * @instance\n * @param {Image} mask\n * @param {object} [options]\n * @return {RoiMap}\n */\n\nexport default function fromMask(mask, options = {}) {\n  const {\n    allowCorners = false\n  } = options;\n  const MAX_ARRAY = 0x00ffff; // 65535 should be enough for most of the cases\n  // based on a binary image we will create plenty of small images\n\n  let data = new Int16Array(mask.size); // maxValue: 32767, minValue: -32768\n  // split will always return an array of images\n\n  let positiveID = 0;\n  let negativeID = 0;\n  let xToProcess = new Uint16Array(MAX_ARRAY + 1); // assign dynamically ????\n\n  let yToProcess = new Uint16Array(MAX_ARRAY + 1); // mask +1 is of course mandatory !!!\n\n  for (let x = 0; x < mask.width; x++) {\n    for (let y = 0; y < mask.height; y++) {\n      if (data[y * mask.width + x] === 0) {\n        // need to process the whole surface\n        analyseSurface(x, y);\n      }\n    }\n  }\n\n  function analyseSurface(x, y) {\n    let from = 0;\n    let to = 0;\n    let targetState = mask.getBitXY(x, y);\n    let id = targetState ? ++positiveID : --negativeID;\n\n    if (positiveID > 32767 || negativeID < -32768) {\n      throw new Error('Too many regions of interest');\n    }\n\n    xToProcess[0] = x;\n    yToProcess[0] = y;\n\n    while (from <= to) {\n      let currentX = xToProcess[from & MAX_ARRAY];\n      let currentY = yToProcess[from & MAX_ARRAY];\n      data[currentY * mask.width + currentX] = id; // need to check all around mask pixel\n\n      if (currentX > 0 && data[currentY * mask.width + currentX - 1] === 0 && mask.getBitXY(currentX - 1, currentY) === targetState) {\n        // LEFT\n        to++;\n        xToProcess[to & MAX_ARRAY] = currentX - 1;\n        yToProcess[to & MAX_ARRAY] = currentY;\n        data[currentY * mask.width + currentX - 1] = -32768;\n      }\n\n      if (currentY > 0 && data[(currentY - 1) * mask.width + currentX] === 0 && mask.getBitXY(currentX, currentY - 1) === targetState) {\n        // TOP\n        to++;\n        xToProcess[to & MAX_ARRAY] = currentX;\n        yToProcess[to & MAX_ARRAY] = currentY - 1;\n        data[(currentY - 1) * mask.width + currentX] = -32768;\n      }\n\n      if (currentX < mask.width - 1 && data[currentY * mask.width + currentX + 1] === 0 && mask.getBitXY(currentX + 1, currentY) === targetState) {\n        // RIGHT\n        to++;\n        xToProcess[to & MAX_ARRAY] = currentX + 1;\n        yToProcess[to & MAX_ARRAY] = currentY;\n        data[currentY * mask.width + currentX + 1] = -32768;\n      }\n\n      if (currentY < mask.height - 1 && data[(currentY + 1) * mask.width + currentX] === 0 && mask.getBitXY(currentX, currentY + 1) === targetState) {\n        // BOTTOM\n        to++;\n        xToProcess[to & MAX_ARRAY] = currentX;\n        yToProcess[to & MAX_ARRAY] = currentY + 1;\n        data[(currentY + 1) * mask.width + currentX] = -32768;\n      }\n\n      if (allowCorners) {\n        if (currentX > 0 && currentY > 0 && data[(currentY - 1) * mask.width + currentX - 1] === 0 && mask.getBitXY(currentX - 1, currentY - 1) === targetState) {\n          // TOP LEFT\n          to++;\n          xToProcess[to & MAX_ARRAY] = currentX - 1;\n          yToProcess[to & MAX_ARRAY] = currentY - 1;\n          data[(currentY - 1) * mask.width + currentX - 1] = -32768;\n        }\n\n        if (currentX < mask.width - 1 && currentY > 0 && data[(currentY - 1) * mask.width + currentX + 1] === 0 && mask.getBitXY(currentX + 1, currentY - 1) === targetState) {\n          // TOP RIGHT\n          to++;\n          xToProcess[to & MAX_ARRAY] = currentX + 1;\n          yToProcess[to & MAX_ARRAY] = currentY - 1;\n          data[(currentY - 1) * mask.width + currentX + 1] = -32768;\n        }\n\n        if (currentX > 0 && currentY < mask.height - 1 && data[(currentY + 1) * mask.width + currentX - 1] === 0 && mask.getBitXY(currentX - 1, currentY + 1) === targetState) {\n          // BOTTOM LEFT\n          to++;\n          xToProcess[to & MAX_ARRAY] = currentX - 1;\n          yToProcess[to & MAX_ARRAY] = currentY + 1;\n          data[(currentY + 1) * mask.width + currentX - 1] = -32768;\n        }\n\n        if (currentX < mask.width - 1 && currentY < mask.height - 1 && data[(currentY + 1) * mask.width + currentX + 1] === 0 && mask.getBitXY(currentX + 1, currentY + 1) === targetState) {\n          // BOTTOM RIGHT\n          to++;\n          xToProcess[to & MAX_ARRAY] = currentX + 1;\n          yToProcess[to & MAX_ARRAY] = currentY + 1;\n          data[(currentY + 1) * mask.width + currentX + 1] = -32768;\n        }\n      }\n\n      from++;\n\n      if (to - from > MAX_ARRAY) {\n        throw new Error('analyseMask can not finish, the array to manage internal data is not big enough.' + 'You could improve mask by changing MAX_ARRAY');\n      }\n    }\n  }\n\n  return new RoiMap(mask, data);\n}","map":{"version":3,"sources":["C:/Users/kuent/Documents/FinishDipshit/Creative/Ocean-Weather-Visualization/node_modules/image-js/src/image/roi/creator/fromMask.js"],"names":["RoiMap","fromMask","mask","options","allowCorners","MAX_ARRAY","data","Int16Array","size","positiveID","negativeID","xToProcess","Uint16Array","yToProcess","x","width","y","height","analyseSurface","from","to","targetState","getBitXY","id","Error","currentX","currentY"],"mappings":"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","sourcesContent":["import RoiMap from '../RoiMap';\n\n/**\n * @memberof RoiManager\n * @instance\n * @param {Image} mask\n * @param {object} [options]\n * @return {RoiMap}\n */\nexport default function fromMask(mask, options = {}) {\n  const { allowCorners = false } = options;\n\n  const MAX_ARRAY = 0x00ffff; // 65535 should be enough for most of the cases\n\n  // based on a binary image we will create plenty of small images\n  let data = new Int16Array(mask.size); // maxValue: 32767, minValue: -32768\n\n  // split will always return an array of images\n  let positiveID = 0;\n  let negativeID = 0;\n\n  let xToProcess = new Uint16Array(MAX_ARRAY + 1); // assign dynamically ????\n  let yToProcess = new Uint16Array(MAX_ARRAY + 1); // mask +1 is of course mandatory !!!\n\n  for (let x = 0; x < mask.width; x++) {\n    for (let y = 0; y < mask.height; y++) {\n      if (data[y * mask.width + x] === 0) {\n        // need to process the whole surface\n        analyseSurface(x, y);\n      }\n    }\n  }\n\n  function analyseSurface(x, y) {\n    let from = 0;\n    let to = 0;\n    let targetState = mask.getBitXY(x, y);\n    let id = targetState ? ++positiveID : --negativeID;\n    if (positiveID > 32767 || negativeID < -32768) {\n      throw new Error('Too many regions of interest');\n    }\n    xToProcess[0] = x;\n    yToProcess[0] = y;\n    while (from <= to) {\n      let currentX = xToProcess[from & MAX_ARRAY];\n      let currentY = yToProcess[from & MAX_ARRAY];\n      data[currentY * mask.width + currentX] = id;\n      // need to check all around mask pixel\n      if (\n        currentX > 0 &&\n        data[currentY * mask.width + currentX - 1] === 0 &&\n        mask.getBitXY(currentX - 1, currentY) === targetState\n      ) {\n        // LEFT\n        to++;\n        xToProcess[to & MAX_ARRAY] = currentX - 1;\n        yToProcess[to & MAX_ARRAY] = currentY;\n        data[currentY * mask.width + currentX - 1] = -32768;\n      }\n      if (\n        currentY > 0 &&\n        data[(currentY - 1) * mask.width + currentX] === 0 &&\n        mask.getBitXY(currentX, currentY - 1) === targetState\n      ) {\n        // TOP\n        to++;\n        xToProcess[to & MAX_ARRAY] = currentX;\n        yToProcess[to & MAX_ARRAY] = currentY - 1;\n        data[(currentY - 1) * mask.width + currentX] = -32768;\n      }\n      if (\n        currentX < mask.width - 1 &&\n        data[currentY * mask.width + currentX + 1] === 0 &&\n        mask.getBitXY(currentX + 1, currentY) === targetState\n      ) {\n        // RIGHT\n        to++;\n        xToProcess[to & MAX_ARRAY] = currentX + 1;\n        yToProcess[to & MAX_ARRAY] = currentY;\n        data[currentY * mask.width + currentX + 1] = -32768;\n      }\n      if (\n        currentY < mask.height - 1 &&\n        data[(currentY + 1) * mask.width + currentX] === 0 &&\n        mask.getBitXY(currentX, currentY + 1) === targetState\n      ) {\n        // BOTTOM\n        to++;\n        xToProcess[to & MAX_ARRAY] = currentX;\n        yToProcess[to & MAX_ARRAY] = currentY + 1;\n        data[(currentY + 1) * mask.width + currentX] = -32768;\n      }\n      if (allowCorners) {\n        if (\n          currentX > 0 &&\n          currentY > 0 &&\n          data[(currentY - 1) * mask.width + currentX - 1] === 0 &&\n          mask.getBitXY(currentX - 1, currentY - 1) === targetState\n        ) {\n          // TOP LEFT\n          to++;\n          xToProcess[to & MAX_ARRAY] = currentX - 1;\n          yToProcess[to & MAX_ARRAY] = currentY - 1;\n          data[(currentY - 1) * mask.width + currentX - 1] = -32768;\n        }\n        if (\n          currentX < mask.width - 1 &&\n          currentY > 0 &&\n          data[(currentY - 1) * mask.width + currentX + 1] === 0 &&\n          mask.getBitXY(currentX + 1, currentY - 1) === targetState\n        ) {\n          // TOP RIGHT\n          to++;\n          xToProcess[to & MAX_ARRAY] = currentX + 1;\n          yToProcess[to & MAX_ARRAY] = currentY - 1;\n          data[(currentY - 1) * mask.width + currentX + 1] = -32768;\n        }\n        if (\n          currentX > 0 &&\n          currentY < mask.height - 1 &&\n          data[(currentY + 1) * mask.width + currentX - 1] === 0 &&\n          mask.getBitXY(currentX - 1, currentY + 1) === targetState\n        ) {\n          // BOTTOM LEFT\n          to++;\n          xToProcess[to & MAX_ARRAY] = currentX - 1;\n          yToProcess[to & MAX_ARRAY] = currentY + 1;\n          data[(currentY + 1) * mask.width + currentX - 1] = -32768;\n        }\n        if (\n          currentX < mask.width - 1 &&\n          currentY < mask.height - 1 &&\n          data[(currentY + 1) * mask.width + currentX + 1] === 0 &&\n          mask.getBitXY(currentX + 1, currentY + 1) === targetState\n        ) {\n          // BOTTOM RIGHT\n          to++;\n          xToProcess[to & MAX_ARRAY] = currentX + 1;\n          yToProcess[to & MAX_ARRAY] = currentY + 1;\n          data[(currentY + 1) * mask.width + currentX + 1] = -32768;\n        }\n      }\n\n      from++;\n\n      if (to - from > MAX_ARRAY) {\n        throw new Error(\n          'analyseMask can not finish, the array to manage internal data is not big enough.' +\n            'You could improve mask by changing MAX_ARRAY',\n        );\n      }\n    }\n  }\n  return new RoiMap(mask, data);\n}\n"]},"metadata":{},"sourceType":"module"}