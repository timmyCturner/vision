{"ast":null,"code":"import { getThreshold as convertThreshold } from '../../../util/converter';\nimport Image from '../../Image';\nimport getThreshold from '../../utility/getThreshold';\nconst THRESHOLD = 'threshold';\n/**\n * Creation of binary mask is based on the determination of a threshold\n * You may either choose among the provided algorithm or just specify a threshold value\n * @memberof Image\n * @instance\n * @param {object} [options]\n * @param {ThresholdAlgorithm|'threshold'} [options.algorithm='threshold']\n * @param {number} [options.threshold=0.5] - If the algorithm is 'threshold' specify here the value (0 to 1).\n * @param {boolean} [options.useAlpha=true] - Apply the alpha channel to determine the intensity of the pixel.\n * @param {boolean} [options.invert=false] - Invert the resulting image\n * @return {Image} - Binary image containing the mask\n */\n\nexport default function mask(options = {}) {\n  let {\n    algorithm = THRESHOLD,\n    threshold = 0.5,\n    useAlpha = true,\n    invert = false\n  } = options;\n  this.checkProcessable('mask', {\n    components: 1,\n    bitDepth: [8, 16]\n  });\n\n  if (algorithm === THRESHOLD) {\n    threshold = convertThreshold(threshold, this.maxValue);\n  } else {\n    threshold = getThreshold.call(this, options);\n  }\n\n  let newImage = new Image(this.width, this.height, {\n    kind: 'BINARY',\n    parent: this\n  });\n  let ptr = 0;\n\n  if (this.alpha && useAlpha) {\n    for (let i = 0; i < this.data.length; i += this.channels) {\n      let value = this.data[i] + (this.maxValue - this.data[i]) * (this.maxValue - this.data[i + 1]) / this.maxValue;\n\n      if (invert && value <= threshold || !invert && value >= threshold) {\n        newImage.setBit(ptr);\n      }\n\n      ptr++;\n    }\n  } else {\n    for (let i = 0; i < this.data.length; i += this.channels) {\n      if (invert && this.data[i] <= threshold || !invert && this.data[i] >= threshold) {\n        newImage.setBit(ptr);\n      }\n\n      ptr++;\n    }\n  }\n\n  return newImage;\n}","map":{"version":3,"sources":["C:/Users/kuent/Documents/FinishDipshit/Creative/Ocean-Weather-Visualization/node_modules/image-js/src/image/transform/mask/mask.js"],"names":["getThreshold","convertThreshold","Image","THRESHOLD","mask","options","algorithm","threshold","useAlpha","invert","checkProcessable","components","bitDepth","maxValue","call","newImage","width","height","kind","parent","ptr","alpha","i","data","length","channels","value","setBit"],"mappings":"AAAA,SAASA,YAAY,IAAIC,gBAAzB,QAAiD,yBAAjD;AACA,OAAOC,KAAP,MAAkB,aAAlB;AACA,OAAOF,YAAP,MAAyB,4BAAzB;AAEA,MAAMG,SAAS,GAAG,WAAlB;AAEA;;;;;;;;;;;;;AAYA,eAAe,SAASC,IAAT,CAAcC,OAAO,GAAG,EAAxB,EAA4B;AACzC,MAAI;AACFC,IAAAA,SAAS,GAAGH,SADV;AAEFI,IAAAA,SAAS,GAAG,GAFV;AAGFC,IAAAA,QAAQ,GAAG,IAHT;AAIFC,IAAAA,MAAM,GAAG;AAJP,MAKAJ,OALJ;AAOA,OAAKK,gBAAL,CAAsB,MAAtB,EAA8B;AAC5BC,IAAAA,UAAU,EAAE,CADgB;AAE5BC,IAAAA,QAAQ,EAAE,CAAC,CAAD,EAAI,EAAJ;AAFkB,GAA9B;;AAKA,MAAIN,SAAS,KAAKH,SAAlB,EAA6B;AAC3BI,IAAAA,SAAS,GAAGN,gBAAgB,CAACM,SAAD,EAAY,KAAKM,QAAjB,CAA5B;AACD,GAFD,MAEO;AACLN,IAAAA,SAAS,GAAGP,YAAY,CAACc,IAAb,CAAkB,IAAlB,EAAwBT,OAAxB,CAAZ;AACD;;AAED,MAAIU,QAAQ,GAAG,IAAIb,KAAJ,CAAU,KAAKc,KAAf,EAAsB,KAAKC,MAA3B,EAAmC;AAChDC,IAAAA,IAAI,EAAE,QAD0C;AAEhDC,IAAAA,MAAM,EAAE;AAFwC,GAAnC,CAAf;AAKA,MAAIC,GAAG,GAAG,CAAV;;AACA,MAAI,KAAKC,KAAL,IAAcb,QAAlB,EAA4B;AAC1B,SAAK,IAAIc,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG,KAAKC,IAAL,CAAUC,MAA9B,EAAsCF,CAAC,IAAI,KAAKG,QAAhD,EAA0D;AACxD,UAAIC,KAAK,GACP,KAAKH,IAAL,CAAUD,CAAV,IACC,CAAC,KAAKT,QAAL,GAAgB,KAAKU,IAAL,CAAUD,CAAV,CAAjB,KAAkC,KAAKT,QAAL,GAAgB,KAAKU,IAAL,CAAUD,CAAC,GAAG,CAAd,CAAlD,CAAD,GACE,KAAKT,QAHT;;AAIA,UAAKJ,MAAM,IAAIiB,KAAK,IAAInB,SAApB,IAAmC,CAACE,MAAD,IAAWiB,KAAK,IAAInB,SAA3D,EAAuE;AACrEQ,QAAAA,QAAQ,CAACY,MAAT,CAAgBP,GAAhB;AACD;;AACDA,MAAAA,GAAG;AACJ;AACF,GAXD,MAWO;AACL,SAAK,IAAIE,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG,KAAKC,IAAL,CAAUC,MAA9B,EAAsCF,CAAC,IAAI,KAAKG,QAAhD,EAA0D;AACxD,UACGhB,MAAM,IAAI,KAAKc,IAAL,CAAUD,CAAV,KAAgBf,SAA3B,IACC,CAACE,MAAD,IAAW,KAAKc,IAAL,CAAUD,CAAV,KAAgBf,SAF9B,EAGE;AACAQ,QAAAA,QAAQ,CAACY,MAAT,CAAgBP,GAAhB;AACD;;AACDA,MAAAA,GAAG;AACJ;AACF;;AAED,SAAOL,QAAP;AACD","sourcesContent":["import { getThreshold as convertThreshold } from '../../../util/converter';\nimport Image from '../../Image';\nimport getThreshold from '../../utility/getThreshold';\n\nconst THRESHOLD = 'threshold';\n\n/**\n * Creation of binary mask is based on the determination of a threshold\n * You may either choose among the provided algorithm or just specify a threshold value\n * @memberof Image\n * @instance\n * @param {object} [options]\n * @param {ThresholdAlgorithm|'threshold'} [options.algorithm='threshold']\n * @param {number} [options.threshold=0.5] - If the algorithm is 'threshold' specify here the value (0 to 1).\n * @param {boolean} [options.useAlpha=true] - Apply the alpha channel to determine the intensity of the pixel.\n * @param {boolean} [options.invert=false] - Invert the resulting image\n * @return {Image} - Binary image containing the mask\n */\nexport default function mask(options = {}) {\n  let {\n    algorithm = THRESHOLD,\n    threshold = 0.5,\n    useAlpha = true,\n    invert = false,\n  } = options;\n\n  this.checkProcessable('mask', {\n    components: 1,\n    bitDepth: [8, 16],\n  });\n\n  if (algorithm === THRESHOLD) {\n    threshold = convertThreshold(threshold, this.maxValue);\n  } else {\n    threshold = getThreshold.call(this, options);\n  }\n\n  let newImage = new Image(this.width, this.height, {\n    kind: 'BINARY',\n    parent: this,\n  });\n\n  let ptr = 0;\n  if (this.alpha && useAlpha) {\n    for (let i = 0; i < this.data.length; i += this.channels) {\n      let value =\n        this.data[i] +\n        ((this.maxValue - this.data[i]) * (this.maxValue - this.data[i + 1])) /\n          this.maxValue;\n      if ((invert && value <= threshold) || (!invert && value >= threshold)) {\n        newImage.setBit(ptr);\n      }\n      ptr++;\n    }\n  } else {\n    for (let i = 0; i < this.data.length; i += this.channels) {\n      if (\n        (invert && this.data[i] <= threshold) ||\n        (!invert && this.data[i] >= threshold)\n      ) {\n        newImage.setBit(ptr);\n      }\n      ptr++;\n    }\n  }\n\n  return newImage;\n}\n"]},"metadata":{},"sourceType":"module"}