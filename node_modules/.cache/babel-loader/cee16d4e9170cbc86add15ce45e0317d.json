{"ast":null,"code":"import { canvasToBlob } from 'blob-util';\nimport { encode as encodeBmp } from 'fast-bmp';\nimport { encode as realEncodePng } from 'fast-png';\nimport { encode as realEncodeJpeg } from 'jpeg-js';\nimport { toBase64URL } from '../../util/base64';\nimport { ImageData, createCanvas, createWriteStream, writeFile } from './environment';\nimport { getType } from './mediaTypes';\n\nfunction encodeJpeg(image, options = {}) {\n  const data = {\n    width: image.width,\n    height: image.height,\n    data: image.getRGBAData()\n  };\n  return realEncodeJpeg(data, options.quality).data;\n}\n\nfunction encodePng(image, options) {\n  const data = {\n    width: image.width,\n    height: image.height,\n    channels: image.channels,\n    depth: image.bitDepth,\n    data: image.data\n  };\n\n  if (data.depth === 1 || data.depth === 32) {\n    data.depth = 8;\n    data.channels = 4;\n    data.data = image.getRGBAData();\n  }\n\n  return realEncodePng(data, options);\n}\n\nconst exportMethods = {\n  /**\n   * Save the image to disk (Node.js only)\n   * @memberof Image\n   * @instance\n   * @param {string} path\n   * @param {object} [options]\n   * @param {string} [options.format] - One of: png, jpg, bmp (limited support for bmp). If not specified will try to infer from filename\n   * @param {boolean} [options.useCanvas=false] - Force use of the canvas API to save the image instead of a JavaScript implementation\n   * @param {object} [options.encoder] - Specify options for the encoder if applicable.\n   * @return {Promise} - Resolves when the file is fully written\n   */\n  save(path, options = {}) {\n    const {\n      useCanvas = false,\n      encoder: encoderOptions = undefined\n    } = options;\n    let {\n      format\n    } = options;\n\n    if (!format) {\n      // try to infer format from filename\n      const m = /\\.([a-zA-Z]+)$/.exec(path);\n\n      if (m) {\n        format = m[1].toLowerCase();\n      }\n    }\n\n    if (!format) {\n      throw new Error('file format not provided');\n    }\n\n    return new Promise((resolve, reject) => {\n      let stream, buffer;\n\n      switch (format.toLowerCase()) {\n        case 'png':\n          {\n            if (useCanvas) {\n              stream = this.getCanvas().pngStream();\n            } else {\n              buffer = encodePng(this, encoderOptions);\n            }\n\n            break;\n          }\n\n        case 'jpg':\n        case 'jpeg':\n          if (useCanvas) {\n            stream = this.getCanvas().jpegStream();\n          } else {\n            buffer = encodeJpeg(this, encoderOptions);\n          }\n\n          break;\n\n        case 'bmp':\n          buffer = encodeBmp(this, encoderOptions);\n          break;\n\n        default:\n          throw new RangeError(`invalid output format: ${format}`);\n      }\n\n      if (stream) {\n        let out = createWriteStream(path);\n        out.on('finish', resolve);\n        out.on('error', reject);\n        stream.pipe(out);\n      } else if (buffer) {\n        writeFile(path, buffer, err => {\n          if (err) {\n            reject(err);\n            return;\n          }\n\n          resolve();\n        });\n      }\n    });\n  },\n\n  /**\n   * Creates a dataURL string from the image.\n   * @memberof Image\n   * @instance\n   * @param {string} [type='image/png']\n   * @param {object} [options]\n   * @param {boolean} [options.useCanvas=false] - Force use of the canvas API to save the image instead of JavaScript implementation.\n   * @param {object} [options.encoder] - Specify options for the encoder if applicable.\n   * @return {string|Promise<string>}\n   */\n  toDataURL(type = 'image/png', options = {}) {\n    if (typeof type === 'object') {\n      options = type;\n      type = 'image/png';\n    }\n\n    const {\n      useCanvas = false,\n      encoder: encoderOptions = undefined\n    } = options;\n    type = getType(type);\n\n    function dataUrl(encoder, ctx) {\n      const u8 = encoder(ctx, encoderOptions);\n      return toBase64URL(u8, type);\n    }\n\n    if (type === 'image/bmp') {\n      return dataUrl(encodeBmp, this);\n    } else if (type === 'image/png' && !useCanvas) {\n      return dataUrl(encodePng, this);\n    } else if (type === 'image/jpeg' && !useCanvas) {\n      return dataUrl(encodeJpeg, this);\n    } else {\n      return this.getCanvas().toDataURL(type);\n    }\n  },\n\n  /**\n   * Encodes the image and returns a buffer\n   * @memberof Image\n   * @instance\n   * @param {object} [options]\n   * @param {string} [options.format='png']\n   * @param {object} [options.encoder] - Specify options for the encoder if applicable.\n   * @return {Uint8Array}\n   */\n  toBuffer(options = {}) {\n    const {\n      format = 'png',\n      encoder: encoderOptions = undefined\n    } = options;\n\n    switch (format.toLowerCase()) {\n      case 'png':\n        return encodePng(this, encoderOptions);\n\n      case 'jpeg':\n      case 'jpg':\n        return encodeJpeg(this, encoderOptions);\n\n      case 'bmp':\n        return encodeBmp(this, encoderOptions);\n\n      default:\n        throw new RangeError(`invalid output format: ${format}`);\n    }\n  },\n\n  /**\n   * Creates a base64 string from the image.\n   * @memberof Image\n   * @instance\n   * @param {string} [type='image/png']\n   * @param {object} [options] - Same options as toDataURL\n   * @return {string|Promise<string>}\n   */\n  toBase64(type = 'image/png', options = {}) {\n    if (options.async) {\n      return this.toDataURL(type, options).then(function (dataURL) {\n        return dataURL.substring(dataURL.indexOf(',') + 1);\n      });\n    } else {\n      const dataURL = this.toDataURL(type, options);\n      return dataURL.substring(dataURL.indexOf(',') + 1);\n    }\n  },\n\n  /**\n   * Creates a blob from the image and return a Promise.\n   * This function is only available in the browser.\n   * @memberof Image\n   * @instance\n   * @param {string} [type='image/png'] A String indicating the image format. The default type is image/png.\n   * @param {string} [quality=0.8] A Number between 0 and 1 indicating image quality if the requested type is image/jpeg or image/webp. If this argument is anything else, the default value for image quality is used. Other arguments are ignored.\n   * @return {Promise}\n   */\n  toBlob(type = 'image/png', quality = 0.8) {\n    return canvasToBlob(this.getCanvas(), type, quality);\n  },\n\n  /**\n   * Creates a new canvas element and draw the image inside it\n   * @memberof Image\n   * @instance\n   * @return {Canvas}\n   */\n  getCanvas() {\n    const data = new ImageData(this.getRGBAData({\n      clamped: true\n    }), this.width, this.height);\n    let canvas = createCanvas(this.width, this.height);\n    let ctx = canvas.getContext('2d');\n    ctx.putImageData(data, 0, 0);\n    return canvas;\n  }\n\n};\nexport default function setExportMethods(Image) {\n  for (const i in exportMethods) {\n    Image.prototype[i] = exportMethods[i];\n  }\n}","map":{"version":3,"sources":["C:/Users/kuent/Documents/FinishDipshit/Creative/Ocean-Weather-Visualization/node_modules/image-js/src/image/core/export.js"],"names":["canvasToBlob","encode","encodeBmp","realEncodePng","realEncodeJpeg","toBase64URL","ImageData","createCanvas","createWriteStream","writeFile","getType","encodeJpeg","image","options","data","width","height","getRGBAData","quality","encodePng","channels","depth","bitDepth","exportMethods","save","path","useCanvas","encoder","encoderOptions","undefined","format","m","exec","toLowerCase","Error","Promise","resolve","reject","stream","buffer","getCanvas","pngStream","jpegStream","RangeError","out","on","pipe","err","toDataURL","type","dataUrl","ctx","u8","toBuffer","toBase64","async","then","dataURL","substring","indexOf","toBlob","clamped","canvas","getContext","putImageData","setExportMethods","Image","i","prototype"],"mappings":"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","sourcesContent":["import { canvasToBlob } from 'blob-util';\nimport { encode as encodeBmp } from 'fast-bmp';\nimport { encode as realEncodePng } from 'fast-png';\nimport { encode as realEncodeJpeg } from 'jpeg-js';\n\nimport { toBase64URL } from '../../util/base64';\n\nimport {\n  ImageData,\n  createCanvas,\n  createWriteStream,\n  writeFile,\n} from './environment';\nimport { getType } from './mediaTypes';\n\nfunction encodeJpeg(image, options = {}) {\n  const data = {\n    width: image.width,\n    height: image.height,\n    data: image.getRGBAData(),\n  };\n  return realEncodeJpeg(data, options.quality).data;\n}\n\nfunction encodePng(image, options) {\n  const data = {\n    width: image.width,\n    height: image.height,\n    channels: image.channels,\n    depth: image.bitDepth,\n    data: image.data,\n  };\n\n  if (data.depth === 1 || data.depth === 32) {\n    data.depth = 8;\n    data.channels = 4;\n    data.data = image.getRGBAData();\n  }\n\n  return realEncodePng(data, options);\n}\n\nconst exportMethods = {\n  /**\n   * Save the image to disk (Node.js only)\n   * @memberof Image\n   * @instance\n   * @param {string} path\n   * @param {object} [options]\n   * @param {string} [options.format] - One of: png, jpg, bmp (limited support for bmp). If not specified will try to infer from filename\n   * @param {boolean} [options.useCanvas=false] - Force use of the canvas API to save the image instead of a JavaScript implementation\n   * @param {object} [options.encoder] - Specify options for the encoder if applicable.\n   * @return {Promise} - Resolves when the file is fully written\n   */\n  save(path, options = {}) {\n    const { useCanvas = false, encoder: encoderOptions = undefined } = options;\n\n    let { format } = options;\n    if (!format) {\n      // try to infer format from filename\n      const m = /\\.([a-zA-Z]+)$/.exec(path);\n      if (m) {\n        format = m[1].toLowerCase();\n      }\n    }\n    if (!format) {\n      throw new Error('file format not provided');\n    }\n    return new Promise((resolve, reject) => {\n      let stream, buffer;\n      switch (format.toLowerCase()) {\n        case 'png': {\n          if (useCanvas) {\n            stream = this.getCanvas().pngStream();\n          } else {\n            buffer = encodePng(this, encoderOptions);\n          }\n          break;\n        }\n        case 'jpg':\n        case 'jpeg':\n          if (useCanvas) {\n            stream = this.getCanvas().jpegStream();\n          } else {\n            buffer = encodeJpeg(this, encoderOptions);\n          }\n          break;\n        case 'bmp':\n          buffer = encodeBmp(this, encoderOptions);\n          break;\n        default:\n          throw new RangeError(`invalid output format: ${format}`);\n      }\n      if (stream) {\n        let out = createWriteStream(path);\n        out.on('finish', resolve);\n        out.on('error', reject);\n        stream.pipe(out);\n      } else if (buffer) {\n        writeFile(path, buffer, (err) => {\n          if (err) {\n            reject(err);\n            return;\n          }\n          resolve();\n        });\n      }\n    });\n  },\n\n  /**\n   * Creates a dataURL string from the image.\n   * @memberof Image\n   * @instance\n   * @param {string} [type='image/png']\n   * @param {object} [options]\n   * @param {boolean} [options.useCanvas=false] - Force use of the canvas API to save the image instead of JavaScript implementation.\n   * @param {object} [options.encoder] - Specify options for the encoder if applicable.\n   * @return {string|Promise<string>}\n   */\n  toDataURL(type = 'image/png', options = {}) {\n    if (typeof type === 'object') {\n      options = type;\n      type = 'image/png';\n    }\n    const { useCanvas = false, encoder: encoderOptions = undefined } = options;\n    type = getType(type);\n    function dataUrl(encoder, ctx) {\n      const u8 = encoder(ctx, encoderOptions);\n      return toBase64URL(u8, type);\n    }\n    if (type === 'image/bmp') {\n      return dataUrl(encodeBmp, this);\n    } else if (type === 'image/png' && !useCanvas) {\n      return dataUrl(encodePng, this);\n    } else if (type === 'image/jpeg' && !useCanvas) {\n      return dataUrl(encodeJpeg, this);\n    } else {\n      return this.getCanvas().toDataURL(type);\n    }\n  },\n\n  /**\n   * Encodes the image and returns a buffer\n   * @memberof Image\n   * @instance\n   * @param {object} [options]\n   * @param {string} [options.format='png']\n   * @param {object} [options.encoder] - Specify options for the encoder if applicable.\n   * @return {Uint8Array}\n   */\n  toBuffer(options = {}) {\n    const { format = 'png', encoder: encoderOptions = undefined } = options;\n    switch (format.toLowerCase()) {\n      case 'png':\n        return encodePng(this, encoderOptions);\n      case 'jpeg':\n      case 'jpg':\n        return encodeJpeg(this, encoderOptions);\n      case 'bmp':\n        return encodeBmp(this, encoderOptions);\n      default:\n        throw new RangeError(`invalid output format: ${format}`);\n    }\n  },\n\n  /**\n   * Creates a base64 string from the image.\n   * @memberof Image\n   * @instance\n   * @param {string} [type='image/png']\n   * @param {object} [options] - Same options as toDataURL\n   * @return {string|Promise<string>}\n   */\n  toBase64(type = 'image/png', options = {}) {\n    if (options.async) {\n      return this.toDataURL(type, options).then(function (dataURL) {\n        return dataURL.substring(dataURL.indexOf(',') + 1);\n      });\n    } else {\n      const dataURL = this.toDataURL(type, options);\n      return dataURL.substring(dataURL.indexOf(',') + 1);\n    }\n  },\n\n  /**\n   * Creates a blob from the image and return a Promise.\n   * This function is only available in the browser.\n   * @memberof Image\n   * @instance\n   * @param {string} [type='image/png'] A String indicating the image format. The default type is image/png.\n   * @param {string} [quality=0.8] A Number between 0 and 1 indicating image quality if the requested type is image/jpeg or image/webp. If this argument is anything else, the default value for image quality is used. Other arguments are ignored.\n   * @return {Promise}\n   */\n  toBlob(type = 'image/png', quality = 0.8) {\n    return canvasToBlob(this.getCanvas(), type, quality);\n  },\n\n  /**\n   * Creates a new canvas element and draw the image inside it\n   * @memberof Image\n   * @instance\n   * @return {Canvas}\n   */\n  getCanvas() {\n    const data = new ImageData(\n      this.getRGBAData({ clamped: true }),\n      this.width,\n      this.height,\n    );\n    let canvas = createCanvas(this.width, this.height);\n    let ctx = canvas.getContext('2d');\n    ctx.putImageData(data, 0, 0);\n    return canvas;\n  },\n};\n\nexport default function setExportMethods(Image) {\n  for (const i in exportMethods) {\n    Image.prototype[i] = exportMethods[i];\n  }\n}\n"]},"metadata":{},"sourceType":"module"}