{"ast":null,"code":"import RoiMap from '../RoiMap';\n/**\n * @memberof RoiManager\n * @instance\n * @param {object} [options]\n * @param {boolean} [options.allowCorner=true]\n * @param {boolean} [options.onlyTop=false]\n * @param {boolean} [options.invert=false]\n * @return {RoiMap}\n */\n\nexport default function fromMaxima(options = {}) {\n  let {\n    allowCorner = true,\n    onlyTop = false,\n    invert = false\n  } = options;\n  let image = this;\n  image.checkProcessable('fromMaxima', {\n    components: [1]\n  });\n  const PROCESS_TOP = 1;\n  const PROCESS_NORMAL = 2; // split will always return an array of images\n\n  let positiveID = 0;\n  let negativeID = 0;\n  let data = new Int16Array(image.size); // maxValue: 32767, minValue: -32768\n\n  let processed = new Int8Array(image.size);\n  let variations = new Float32Array(image.size);\n  let MAX_ARRAY = 0x0fffff; // should be enough for most of the cases\n\n  let xToProcess = new Uint16Array(MAX_ARRAY + 1); // assign dynamically ????\n\n  let yToProcess = new Uint16Array(MAX_ARRAY + 1); // mask +1 is of course mandatory !!!\n\n  let from = 0;\n  let to = 0;\n  let xToProcessTop = new Uint16Array(MAX_ARRAY + 1); // assign dynamically ????\n\n  let yToProcessTop = new Uint16Array(MAX_ARRAY + 1); // mask +1 is of course mandatory !!!\n\n  let fromTop = 0;\n  let toTop = 0;\n  appendMaxima(image, {\n    maxima: !invert\n  });\n\n  while (from < to) {\n    let currentX = xToProcess[from & MAX_ARRAY];\n    let currentY = yToProcess[from & MAX_ARRAY];\n    process(currentX, currentY, PROCESS_NORMAL);\n    from++;\n  }\n\n  return new RoiMap(image, data); // we will look for the maxima (or minima) that is present in the picture\n  // a maxima is a point that is surrounded by lower values\n  // should deal with allowCorner and invert\n\n  function appendMaxima({\n    maxima = true\n  }) {\n    for (let y = 1; y < image.height - 1; y++) {\n      for (let x = 1; x < image.width - 1; x++) {\n        let index = x + y * image.width;\n\n        if (processed[index] === 0) {\n          let currentValue = maxima ? image.data[index] : -image.data[x + y * image.width];\n\n          if (image.data[y * image.width + x - 1] > currentValue) {\n            // LEFT\n            continue;\n          }\n\n          if (image.data[y * image.width + x + 1] > currentValue) {\n            // RIGHT\n            continue;\n          }\n\n          if (image.data[(y - 1) * image.width + x] > currentValue) {\n            // TOP\n            continue;\n          }\n\n          if (image.data[(y + 1) * image.width + x] > currentValue) {\n            // BOTTOM\n            continue;\n          }\n\n          if (allowCorner) {\n            if (image.data[(y - 1) * image.width + x - 1] > currentValue) {\n              // LEFT TOP\n              continue;\n            }\n\n            if (image.data[(y - 1) * image.width + x + 1] > currentValue) {\n              // RIGHT TOP\n              continue;\n            }\n\n            if (image.data[(y + 1) * image.width + x - 1] > currentValue) {\n              // LEFT BOTTOM\n              continue;\n            }\n\n            if (image.data[(y + 1) * image.width + x + 1] > currentValue) {\n              // RIGHT BOTTOM\n              continue;\n            }\n          }\n\n          data[index] = maxima ? ++positiveID : --negativeID;\n          let valid = processTop(x, y, PROCESS_TOP);\n\n          if (!valid) {\n            if (maxima) {\n              --positiveID;\n            } else {\n              ++negativeID;\n            }\n          }\n        }\n      }\n    }\n  } // we will try to get all the points of the top (same value)\n  // and to check if the whole group is surrounded by lower value\n  // as soon as one of them if not part we need to reverse the process\n  // and just for get those points\n\n\n  function processTop(xToProcess, yToProcess) {\n    let currentTo = to; // in case if fails we come back\n\n    fromTop = 0;\n    toTop = 1;\n    xToProcessTop[0] = xToProcess;\n    yToProcessTop[0] = yToProcess;\n    let valid = true;\n\n    while (fromTop < toTop) {\n      let currentX = xToProcessTop[fromTop & MAX_ARRAY];\n      let currentY = yToProcessTop[fromTop & MAX_ARRAY];\n      valid &= process(currentX, currentY, PROCESS_TOP);\n      fromTop++;\n    }\n\n    if (!valid) {\n      // need to clear all the calculated data because the top is not surrounded by negative values\n      for (let i = 0; i < toTop; i++) {\n        let currentX = xToProcessTop[i & MAX_ARRAY];\n        let currentY = yToProcessTop[i & MAX_ARRAY];\n        let index = currentY * image.width + currentX;\n        data[index] = 0;\n      }\n\n      to = currentTo;\n    }\n\n    return valid;\n  }\n  /*\n     For a specific point we will check the points around, increase the area of interests and add\n     them to the processing list\n     type=0 : top\n     type=1 : normal\n     */\n\n\n  function process(xCenter, yCenter, type) {\n    let currentID = data[yCenter * image.width + xCenter];\n    let currentValue = image.data[yCenter * image.width + xCenter];\n\n    for (let y = yCenter - 1; y <= yCenter + 1; y++) {\n      for (let x = xCenter - 1; x <= xCenter + 1; x++) {\n        let index = y * image.width + x;\n\n        if (processed[index] === 0) {\n          processed[index] = 1; // we store the variation compare to the parent pixel\n\n          variations[index] = image.data[index] - currentValue;\n\n          switch (type) {\n            case PROCESS_TOP:\n              if (variations[index] === 0) {\n                // we look for maxima\n                // if we are next to a border ... it is not surrounded !\n                if (x === 0 || y === 0 || x === image.width - 1 || y === image.height - 1) {\n                  return false;\n                }\n\n                data[index] = currentID;\n                xToProcessTop[toTop & MAX_ARRAY] = x;\n                yToProcessTop[toTop & MAX_ARRAY] = y;\n                toTop++;\n              } else if (variations[index] > 0) {\n                // not a global maximum\n                return false;\n              } else {\n                // a point we will have to process\n                if (!onlyTop) {\n                  data[index] = currentID;\n                  xToProcess[to & MAX_ARRAY] = x;\n                  yToProcess[to & MAX_ARRAY] = y;\n                  to++;\n                }\n              }\n\n              break;\n\n            case PROCESS_NORMAL:\n              if (variations[index] <= 0) {\n                // we look for maxima\n                data[index] = currentID;\n                xToProcess[to & MAX_ARRAY] = x;\n                yToProcess[to & MAX_ARRAY] = y;\n                to++;\n              }\n\n              break;\n\n            default:\n              throw new Error('unreachable');\n          }\n        }\n      }\n    }\n\n    return true;\n  }\n}","map":{"version":3,"sources":["C:/Users/kuent/Documents/FinishDipshit/Creative/Ocean-Weather-Visualization/node_modules/image-js/src/image/roi/creator/fromMaxima.js"],"names":["RoiMap","fromMaxima","options","allowCorner","onlyTop","invert","image","checkProcessable","components","PROCESS_TOP","PROCESS_NORMAL","positiveID","negativeID","data","Int16Array","size","processed","Int8Array","variations","Float32Array","MAX_ARRAY","xToProcess","Uint16Array","yToProcess","from","to","xToProcessTop","yToProcessTop","fromTop","toTop","appendMaxima","maxima","currentX","currentY","process","y","height","x","width","index","currentValue","valid","processTop","currentTo","i","xCenter","yCenter","type","currentID","Error"],"mappings":"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","sourcesContent":["import RoiMap from '../RoiMap';\n\n/**\n * @memberof RoiManager\n * @instance\n * @param {object} [options]\n * @param {boolean} [options.allowCorner=true]\n * @param {boolean} [options.onlyTop=false]\n * @param {boolean} [options.invert=false]\n * @return {RoiMap}\n */\nexport default function fromMaxima(options = {}) {\n  let { allowCorner = true, onlyTop = false, invert = false } = options;\n\n  let image = this;\n  image.checkProcessable('fromMaxima', { components: [1] });\n\n  const PROCESS_TOP = 1;\n  const PROCESS_NORMAL = 2;\n\n  // split will always return an array of images\n  let positiveID = 0;\n  let negativeID = 0;\n\n  let data = new Int16Array(image.size); // maxValue: 32767, minValue: -32768\n  let processed = new Int8Array(image.size);\n  let variations = new Float32Array(image.size);\n\n  let MAX_ARRAY = 0x0fffff; // should be enough for most of the cases\n  let xToProcess = new Uint16Array(MAX_ARRAY + 1); // assign dynamically ????\n  let yToProcess = new Uint16Array(MAX_ARRAY + 1); // mask +1 is of course mandatory !!!\n\n  let from = 0;\n  let to = 0;\n\n  let xToProcessTop = new Uint16Array(MAX_ARRAY + 1); // assign dynamically ????\n  let yToProcessTop = new Uint16Array(MAX_ARRAY + 1); // mask +1 is of course mandatory !!!\n\n  let fromTop = 0;\n  let toTop = 0;\n\n  appendMaxima(image, { maxima: !invert });\n\n  while (from < to) {\n    let currentX = xToProcess[from & MAX_ARRAY];\n    let currentY = yToProcess[from & MAX_ARRAY];\n    process(currentX, currentY, PROCESS_NORMAL);\n    from++;\n  }\n\n  return new RoiMap(image, data);\n\n  // we will look for the maxima (or minima) that is present in the picture\n  // a maxima is a point that is surrounded by lower values\n  // should deal with allowCorner and invert\n  function appendMaxima({ maxima = true }) {\n    for (let y = 1; y < image.height - 1; y++) {\n      for (let x = 1; x < image.width - 1; x++) {\n        let index = x + y * image.width;\n        if (processed[index] === 0) {\n          let currentValue = maxima\n            ? image.data[index]\n            : -image.data[x + y * image.width];\n          if (image.data[y * image.width + x - 1] > currentValue) {\n            // LEFT\n            continue;\n          }\n          if (image.data[y * image.width + x + 1] > currentValue) {\n            // RIGHT\n            continue;\n          }\n          if (image.data[(y - 1) * image.width + x] > currentValue) {\n            // TOP\n            continue;\n          }\n          if (image.data[(y + 1) * image.width + x] > currentValue) {\n            // BOTTOM\n            continue;\n          }\n          if (allowCorner) {\n            if (image.data[(y - 1) * image.width + x - 1] > currentValue) {\n              // LEFT TOP\n              continue;\n            }\n            if (image.data[(y - 1) * image.width + x + 1] > currentValue) {\n              // RIGHT TOP\n              continue;\n            }\n            if (image.data[(y + 1) * image.width + x - 1] > currentValue) {\n              // LEFT BOTTOM\n              continue;\n            }\n            if (image.data[(y + 1) * image.width + x + 1] > currentValue) {\n              // RIGHT BOTTOM\n              continue;\n            }\n          }\n\n          data[index] = maxima ? ++positiveID : --negativeID;\n\n          let valid = processTop(x, y, PROCESS_TOP);\n          if (!valid) {\n            if (maxima) {\n              --positiveID;\n            } else {\n              ++negativeID;\n            }\n          }\n        }\n      }\n    }\n  }\n\n  // we will try to get all the points of the top (same value)\n  // and to check if the whole group is surrounded by lower value\n  // as soon as one of them if not part we need to reverse the process\n  // and just for get those points\n  function processTop(xToProcess, yToProcess) {\n    let currentTo = to; // in case if fails we come back\n    fromTop = 0;\n    toTop = 1;\n    xToProcessTop[0] = xToProcess;\n    yToProcessTop[0] = yToProcess;\n    let valid = true;\n    while (fromTop < toTop) {\n      let currentX = xToProcessTop[fromTop & MAX_ARRAY];\n      let currentY = yToProcessTop[fromTop & MAX_ARRAY];\n      valid &= process(currentX, currentY, PROCESS_TOP);\n      fromTop++;\n    }\n    if (!valid) {\n      // need to clear all the calculated data because the top is not surrounded by negative values\n      for (let i = 0; i < toTop; i++) {\n        let currentX = xToProcessTop[i & MAX_ARRAY];\n        let currentY = yToProcessTop[i & MAX_ARRAY];\n        let index = currentY * image.width + currentX;\n        data[index] = 0;\n      }\n      to = currentTo;\n    }\n    return valid;\n  }\n\n  /*\n     For a specific point we will check the points around, increase the area of interests and add\n     them to the processing list\n     type=0 : top\n     type=1 : normal\n     */\n  function process(xCenter, yCenter, type) {\n    let currentID = data[yCenter * image.width + xCenter];\n    let currentValue = image.data[yCenter * image.width + xCenter];\n    for (let y = yCenter - 1; y <= yCenter + 1; y++) {\n      for (let x = xCenter - 1; x <= xCenter + 1; x++) {\n        let index = y * image.width + x;\n        if (processed[index] === 0) {\n          processed[index] = 1;\n          // we store the variation compare to the parent pixel\n          variations[index] = image.data[index] - currentValue;\n          switch (type) {\n            case PROCESS_TOP:\n              if (variations[index] === 0) {\n                // we look for maxima\n                // if we are next to a border ... it is not surrounded !\n                if (\n                  x === 0 ||\n                  y === 0 ||\n                  x === image.width - 1 ||\n                  y === image.height - 1\n                ) {\n                  return false;\n                }\n                data[index] = currentID;\n                xToProcessTop[toTop & MAX_ARRAY] = x;\n                yToProcessTop[toTop & MAX_ARRAY] = y;\n                toTop++;\n              } else if (variations[index] > 0) {\n                // not a global maximum\n                return false;\n              } else {\n                // a point we will have to process\n                if (!onlyTop) {\n                  data[index] = currentID;\n                  xToProcess[to & MAX_ARRAY] = x;\n                  yToProcess[to & MAX_ARRAY] = y;\n                  to++;\n                }\n              }\n              break;\n            case PROCESS_NORMAL:\n              if (variations[index] <= 0) {\n                // we look for maxima\n                data[index] = currentID;\n                xToProcess[to & MAX_ARRAY] = x;\n                yToProcess[to & MAX_ARRAY] = y;\n                to++;\n              }\n              break;\n            default:\n              throw new Error('unreachable');\n          }\n        }\n      }\n    }\n    return true;\n  }\n}\n"]},"metadata":{},"sourceType":"module"}