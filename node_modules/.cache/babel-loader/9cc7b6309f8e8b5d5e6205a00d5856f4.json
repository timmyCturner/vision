{"ast":null,"code":"import Matrix from '../../util/matrix';\n/**\n * Try to match the current pictures with another one\n * @memberof Image\n * @instance\n * @param {Image} image - Other image to match\n * @param {object} [options]\n * @return {number[]}\n */\n\nexport default function getBestMatch(image, options = {}) {\n  let {\n    border\n  } = options;\n  this.checkProcessable('getChannel', {\n    bitDepth: [8, 16]\n  });\n\n  if (this.bitDepth !== image.bitDepth) {\n    throw new Error('Both images must have the same bitDepth');\n  }\n\n  if (this.channels !== image.channels) {\n    throw new Error('Both images must have the same number of channels');\n  }\n\n  if (this.colorModel !== image.colorModel) {\n    throw new Error('Both images must have the same colorModel');\n  } // there could be many names\n\n\n  let similarityMatrix = new Matrix(image.width, image.height, -Infinity);\n  let currentX = Math.floor(image.width / 2);\n  let currentY = Math.floor(image.height / 2);\n  let middleX = currentX;\n  let middleY = currentY;\n  let theEnd = false;\n\n  while (!theEnd) {\n    let toCalculatePositions = similarityMatrix.localSearch(currentX, currentY, -Infinity);\n\n    for (let i = 0; i < toCalculatePositions.length; i++) {\n      let position = toCalculatePositions[i];\n      let similarity = this.getSimilarity(image, {\n        border: border,\n        shift: [middleX - position[0], middleY - position[1]]\n      });\n      similarityMatrix[position[0]][position[1]] = similarity;\n    }\n\n    let max = similarityMatrix.localMax(currentX, currentY);\n\n    if (max.position[0] !== currentX || max.position[1] !== currentY) {\n      currentX = max.position[0];\n      currentY = max.position[1];\n    } else {\n      theEnd = true;\n    }\n  }\n\n  return [currentX - middleX, currentY - middleY];\n}","map":{"version":3,"sources":["C:/Users/kuent/Documents/FinishDipshit/Creative/Ocean-Weather-Visualization/node_modules/image-js/src/image/utility/getBestMatch.js"],"names":["Matrix","getBestMatch","image","options","border","checkProcessable","bitDepth","Error","channels","colorModel","similarityMatrix","width","height","Infinity","currentX","Math","floor","currentY","middleX","middleY","theEnd","toCalculatePositions","localSearch","i","length","position","similarity","getSimilarity","shift","max","localMax"],"mappings":"AAAA,OAAOA,MAAP,MAAmB,mBAAnB;AAEA;;;;;;;;;AAQA,eAAe,SAASC,YAAT,CAAsBC,KAAtB,EAA6BC,OAAO,GAAG,EAAvC,EAA2C;AACxD,MAAI;AAAEC,IAAAA;AAAF,MAAaD,OAAjB;AAEA,OAAKE,gBAAL,CAAsB,YAAtB,EAAoC;AAClCC,IAAAA,QAAQ,EAAE,CAAC,CAAD,EAAI,EAAJ;AADwB,GAApC;;AAIA,MAAI,KAAKA,QAAL,KAAkBJ,KAAK,CAACI,QAA5B,EAAsC;AACpC,UAAM,IAAIC,KAAJ,CAAU,yCAAV,CAAN;AACD;;AACD,MAAI,KAAKC,QAAL,KAAkBN,KAAK,CAACM,QAA5B,EAAsC;AACpC,UAAM,IAAID,KAAJ,CAAU,mDAAV,CAAN;AACD;;AACD,MAAI,KAAKE,UAAL,KAAoBP,KAAK,CAACO,UAA9B,EAA0C;AACxC,UAAM,IAAIF,KAAJ,CAAU,2CAAV,CAAN;AACD,GAfuD,CAiBxD;;;AACA,MAAIG,gBAAgB,GAAG,IAAIV,MAAJ,CAAWE,KAAK,CAACS,KAAjB,EAAwBT,KAAK,CAACU,MAA9B,EAAsC,CAACC,QAAvC,CAAvB;AAEA,MAAIC,QAAQ,GAAGC,IAAI,CAACC,KAAL,CAAWd,KAAK,CAACS,KAAN,GAAc,CAAzB,CAAf;AACA,MAAIM,QAAQ,GAAGF,IAAI,CAACC,KAAL,CAAWd,KAAK,CAACU,MAAN,GAAe,CAA1B,CAAf;AACA,MAAIM,OAAO,GAAGJ,QAAd;AACA,MAAIK,OAAO,GAAGF,QAAd;AACA,MAAIG,MAAM,GAAG,KAAb;;AAEA,SAAO,CAACA,MAAR,EAAgB;AACd,QAAIC,oBAAoB,GAAGX,gBAAgB,CAACY,WAAjB,CACzBR,QADyB,EAEzBG,QAFyB,EAGzB,CAACJ,QAHwB,CAA3B;;AAKA,SAAK,IAAIU,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGF,oBAAoB,CAACG,MAAzC,EAAiDD,CAAC,EAAlD,EAAsD;AACpD,UAAIE,QAAQ,GAAGJ,oBAAoB,CAACE,CAAD,CAAnC;AACA,UAAIG,UAAU,GAAG,KAAKC,aAAL,CAAmBzB,KAAnB,EAA0B;AACzCE,QAAAA,MAAM,EAAEA,MADiC;AAEzCwB,QAAAA,KAAK,EAAE,CAACV,OAAO,GAAGO,QAAQ,CAAC,CAAD,CAAnB,EAAwBN,OAAO,GAAGM,QAAQ,CAAC,CAAD,CAA1C;AAFkC,OAA1B,CAAjB;AAIAf,MAAAA,gBAAgB,CAACe,QAAQ,CAAC,CAAD,CAAT,CAAhB,CAA8BA,QAAQ,CAAC,CAAD,CAAtC,IAA6CC,UAA7C;AACD;;AAED,QAAIG,GAAG,GAAGnB,gBAAgB,CAACoB,QAAjB,CAA0BhB,QAA1B,EAAoCG,QAApC,CAAV;;AACA,QAAIY,GAAG,CAACJ,QAAJ,CAAa,CAAb,MAAoBX,QAApB,IAAgCe,GAAG,CAACJ,QAAJ,CAAa,CAAb,MAAoBR,QAAxD,EAAkE;AAChEH,MAAAA,QAAQ,GAAGe,GAAG,CAACJ,QAAJ,CAAa,CAAb,CAAX;AACAR,MAAAA,QAAQ,GAAGY,GAAG,CAACJ,QAAJ,CAAa,CAAb,CAAX;AACD,KAHD,MAGO;AACLL,MAAAA,MAAM,GAAG,IAAT;AACD;AACF;;AAED,SAAO,CAACN,QAAQ,GAAGI,OAAZ,EAAqBD,QAAQ,GAAGE,OAAhC,CAAP;AACD","sourcesContent":["import Matrix from '../../util/matrix';\n\n/**\n * Try to match the current pictures with another one\n * @memberof Image\n * @instance\n * @param {Image} image - Other image to match\n * @param {object} [options]\n * @return {number[]}\n */\nexport default function getBestMatch(image, options = {}) {\n  let { border } = options;\n\n  this.checkProcessable('getChannel', {\n    bitDepth: [8, 16],\n  });\n\n  if (this.bitDepth !== image.bitDepth) {\n    throw new Error('Both images must have the same bitDepth');\n  }\n  if (this.channels !== image.channels) {\n    throw new Error('Both images must have the same number of channels');\n  }\n  if (this.colorModel !== image.colorModel) {\n    throw new Error('Both images must have the same colorModel');\n  }\n\n  // there could be many names\n  let similarityMatrix = new Matrix(image.width, image.height, -Infinity);\n\n  let currentX = Math.floor(image.width / 2);\n  let currentY = Math.floor(image.height / 2);\n  let middleX = currentX;\n  let middleY = currentY;\n  let theEnd = false;\n\n  while (!theEnd) {\n    let toCalculatePositions = similarityMatrix.localSearch(\n      currentX,\n      currentY,\n      -Infinity,\n    );\n    for (let i = 0; i < toCalculatePositions.length; i++) {\n      let position = toCalculatePositions[i];\n      let similarity = this.getSimilarity(image, {\n        border: border,\n        shift: [middleX - position[0], middleY - position[1]],\n      });\n      similarityMatrix[position[0]][position[1]] = similarity;\n    }\n\n    let max = similarityMatrix.localMax(currentX, currentY);\n    if (max.position[0] !== currentX || max.position[1] !== currentY) {\n      currentX = max.position[0];\n      currentY = max.position[1];\n    } else {\n      theEnd = true;\n    }\n  }\n\n  return [currentX - middleX, currentY - middleY];\n}\n"]},"metadata":{},"sourceType":"module"}