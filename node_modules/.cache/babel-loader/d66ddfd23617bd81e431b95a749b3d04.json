{"ast":null,"code":"import { IOBuffer } from 'iobuffer';\nconst CLEAR_CODE = 256;\nconst EOI_CODE = 257; // 0-255 from the table + 256 for clear code + 257 for end of information code.\n\nconst TABLE_START = 258;\nconst MIN_BIT_LENGTH = 9;\nconst stringTable = [];\n\nfor (let i = 0; i < 256; i++) {\n  stringTable.push([i]);\n} // Fill the table with dummy data.\n// Elements at indices > 257 will be replaced during decompression.\n\n\nconst dummyString = [0];\n\nfor (let i = 256; i < 4096; i++) {\n  stringTable.push(dummyString);\n}\n\nclass LzwDecoder {\n  constructor(data) {\n    this.stripArray = new Uint8Array(data.buffer, data.byteOffset, data.byteLength);\n    const table = new Map();\n\n    for (let i = 0; i < 256; i++) {\n      table.set(i, [i]);\n    }\n\n    this.currentBit = 0;\n    this.tableLength = TABLE_START;\n    this.currentBitLength = MIN_BIT_LENGTH;\n    this.outData = new IOBuffer(data.byteLength);\n  }\n\n  decode() {\n    let code = 0;\n    let oldCode = 0;\n\n    while ((code = this.getNextCode()) !== EOI_CODE) {\n      if (code === CLEAR_CODE) {\n        this.initializeTable();\n        code = this.getNextCode();\n\n        if (code === EOI_CODE) {\n          break;\n        }\n\n        this.writeString(this.stringFromCode(code));\n        oldCode = code;\n      } else if (this.isInTable(code)) {\n        this.writeString(this.stringFromCode(code));\n        this.addStringToTable(this.stringFromCode(oldCode).concat(this.stringFromCode(code)[0]));\n        oldCode = code;\n      } else {\n        const outString = this.stringFromCode(oldCode).concat(this.stringFromCode(oldCode)[0]);\n        this.writeString(outString);\n        this.addStringToTable(outString);\n        oldCode = code;\n      }\n    }\n\n    const outArray = this.outData.toArray();\n    return new DataView(outArray.buffer, outArray.byteOffset, outArray.byteLength);\n  }\n\n  initializeTable() {\n    this.tableLength = TABLE_START;\n    this.currentBitLength = MIN_BIT_LENGTH;\n  }\n\n  writeString(string) {\n    this.outData.writeBytes(string);\n  }\n\n  stringFromCode(code) {\n    // At this point, `code` must be defined in the table.\n    return stringTable[code];\n  }\n\n  isInTable(code) {\n    return code < this.tableLength;\n  }\n\n  addStringToTable(string) {\n    stringTable[this.tableLength++] = string;\n\n    if (this.tableLength + 1 === 2 ** this.currentBitLength) {\n      this.currentBitLength++;\n    }\n  }\n\n  getNextCode() {\n    const d = this.currentBit % 8;\n    const a = this.currentBit >>> 3;\n    const de = 8 - d;\n    const ef = this.currentBit + this.currentBitLength - (a + 1) * 8;\n    let fg = 8 * (a + 2) - (this.currentBit + this.currentBitLength);\n    const dg = (a + 2) * 8 - this.currentBit;\n    fg = Math.max(0, fg);\n    let chunk1 = this.stripArray[a] & 2 ** (8 - d) - 1;\n    chunk1 <<= this.currentBitLength - de;\n    let chunks = chunk1;\n\n    if (a + 1 < this.stripArray.length) {\n      let chunk2 = this.stripArray[a + 1] >>> fg;\n      chunk2 <<= Math.max(0, this.currentBitLength - dg);\n      chunks += chunk2;\n    }\n\n    if (ef > 8 && a + 2 < this.stripArray.length) {\n      const hi = (a + 3) * 8 - (this.currentBit + this.currentBitLength);\n      const chunk3 = this.stripArray[a + 2] >>> hi;\n      chunks += chunk3;\n    }\n\n    this.currentBit += this.currentBitLength;\n    return chunks;\n  }\n\n}\n\nexport function decompressLzw(stripData) {\n  return new LzwDecoder(stripData).decode();\n}","map":{"version":3,"sources":["../src/lzw.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { IOBuffer } from 'iobuffer';\r\nconst CLEAR_CODE = 256;\r\nconst EOI_CODE = 257;\r\n// 0-255 from the table + 256 for clear code + 257 for end of information code.\r\nconst TABLE_START = 258;\r\nconst MIN_BIT_LENGTH = 9;\r\nconst stringTable = [];\r\nfor (let i = 0; i < 256; i++) {\r\n    stringTable.push([i]);\r\n}\r\n// Fill the table with dummy data.\r\n// Elements at indices > 257 will be replaced during decompression.\r\nconst dummyString = [0];\r\nfor (let i = 256; i < 4096; i++) {\r\n    stringTable.push(dummyString);\r\n}\r\nclass LzwDecoder {\r\n    constructor(data) {\r\n        this.stripArray = new Uint8Array(data.buffer, data.byteOffset, data.byteLength);\r\n        const table = new Map();\r\n        for (let i = 0; i < 256; i++) {\r\n            table.set(i, [i]);\r\n        }\r\n        this.currentBit = 0;\r\n        this.tableLength = TABLE_START;\r\n        this.currentBitLength = MIN_BIT_LENGTH;\r\n        this.outData = new IOBuffer(data.byteLength);\r\n    }\r\n    decode() {\r\n        let code = 0;\r\n        let oldCode = 0;\r\n        while ((code = this.getNextCode()) !== EOI_CODE) {\r\n            if (code === CLEAR_CODE) {\r\n                this.initializeTable();\r\n                code = this.getNextCode();\r\n                if (code === EOI_CODE) {\r\n                    break;\r\n                }\r\n                this.writeString(this.stringFromCode(code));\r\n                oldCode = code;\r\n            }\r\n            else if (this.isInTable(code)) {\r\n                this.writeString(this.stringFromCode(code));\r\n                this.addStringToTable(this.stringFromCode(oldCode).concat(this.stringFromCode(code)[0]));\r\n                oldCode = code;\r\n            }\r\n            else {\r\n                const outString = this.stringFromCode(oldCode).concat(this.stringFromCode(oldCode)[0]);\r\n                this.writeString(outString);\r\n                this.addStringToTable(outString);\r\n                oldCode = code;\r\n            }\r\n        }\r\n        const outArray = this.outData.toArray();\r\n        return new DataView(outArray.buffer, outArray.byteOffset, outArray.byteLength);\r\n    }\r\n    initializeTable() {\r\n        this.tableLength = TABLE_START;\r\n        this.currentBitLength = MIN_BIT_LENGTH;\r\n    }\r\n    writeString(string) {\r\n        this.outData.writeBytes(string);\r\n    }\r\n    stringFromCode(code) {\r\n        // At this point, `code` must be defined in the table.\r\n        return stringTable[code];\r\n    }\r\n    isInTable(code) {\r\n        return code < this.tableLength;\r\n    }\r\n    addStringToTable(string) {\r\n        stringTable[this.tableLength++] = string;\r\n        if (this.tableLength + 1 === 2 ** this.currentBitLength) {\r\n            this.currentBitLength++;\r\n        }\r\n    }\r\n    getNextCode() {\r\n        const d = this.currentBit % 8;\r\n        const a = this.currentBit >>> 3;\r\n        const de = 8 - d;\r\n        const ef = this.currentBit + this.currentBitLength - (a + 1) * 8;\r\n        let fg = 8 * (a + 2) - (this.currentBit + this.currentBitLength);\r\n        const dg = (a + 2) * 8 - this.currentBit;\r\n        fg = Math.max(0, fg);\r\n        let chunk1 = this.stripArray[a] & (2 ** (8 - d) - 1);\r\n        chunk1 <<= this.currentBitLength - de;\r\n        let chunks = chunk1;\r\n        if (a + 1 < this.stripArray.length) {\r\n            let chunk2 = this.stripArray[a + 1] >>> fg;\r\n            chunk2 <<= Math.max(0, this.currentBitLength - dg);\r\n            chunks += chunk2;\r\n        }\r\n        if (ef > 8 && a + 2 < this.stripArray.length) {\r\n            const hi = (a + 3) * 8 - (this.currentBit + this.currentBitLength);\r\n            const chunk3 = this.stripArray[a + 2] >>> hi;\r\n            chunks += chunk3;\r\n        }\r\n        this.currentBit += this.currentBitLength;\r\n        return chunks;\r\n    }\r\n}\r\nexport function decompressLzw(stripData) {\r\n    return new LzwDecoder(stripData).decode();\r\n}\r\n//# sourceMappingURL=lzw.js.map"]},"metadata":{},"sourceType":"module"}