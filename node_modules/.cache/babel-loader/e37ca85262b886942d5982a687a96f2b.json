{"ast":null,"code":"// see https://github.com/fiji/Auto_Threshold/blob/master/src/main/java/fiji/threshold/Auto_Threshold.java\n// Zack, G. W., Rogers, W. E. and Latt, S. A., 1977,\n// Automatic Measurement of Sister Chromatid Exchange Frequency,\n// Journal of Histochemistry and Cytochemistry 25 (7), pp. 741-753\n//\n//  modified from Johannes Schindelin plugin\nexport default function triangle(histogram) {\n  // find min and max\n  let min = 0;\n  let dmax = 0;\n  let max = 0;\n  let min2 = 0;\n\n  for (let i = 0; i < histogram.length; i++) {\n    if (histogram[i] > 0) {\n      min = i;\n      break;\n    }\n  }\n\n  if (min > 0) {\n    // line to the (p==0) point, not to histogram[min]\n    min--;\n  } // The Triangle algorithm cannot tell whether the data is skewed to one side or another.\n  // This causes a problem as there are 2 possible thresholds between the max and the 2 extremes\n  // of the histogram.\n  // Here I propose to find out to which side of the max point the data is furthest, and use that as\n  //  the other extreme.\n\n\n  for (let i = histogram.length - 1; i > 0; i--) {\n    if (histogram[i] > 0) {\n      min2 = i;\n      break;\n    }\n  }\n\n  if (min2 < histogram.length - 1) {\n    // line to the (p==0) point, not to data[min]\n    min2++;\n  }\n\n  for (let i = 0; i < histogram.length; i++) {\n    if (histogram[i] > dmax) {\n      max = i;\n      dmax = histogram[i];\n    }\n  } // find which is the furthest side\n\n\n  let inverted = false;\n\n  if (max - min < min2 - max) {\n    // reverse the histogram\n    inverted = true;\n    let left = 0; // index of leftmost element\n\n    let right = histogram.length - 1; // index of rightmost element\n\n    while (left < right) {\n      // exchange the left and right elements\n      let temp = histogram[left];\n      histogram[left] = histogram[right];\n      histogram[right] = temp; // move the bounds toward the center\n\n      left++;\n      right--;\n    }\n\n    min = histogram.length - 1 - min2;\n    max = histogram.length - 1 - max;\n  }\n\n  if (min === max) {\n    return min;\n  } // describe line by nx * x + ny * y - d = 0\n\n\n  let nx, ny, d; // nx is just the max frequency as the other point has freq=0\n\n  nx = histogram[max]; // -min; // data[min]; //  lowest value bmin = (p=0)% in the image\n\n  ny = min - max;\n  d = Math.sqrt(nx * nx + ny * ny);\n  nx /= d;\n  ny /= d;\n  d = nx * min + ny * histogram[min]; // find split point\n\n  let split = min;\n  let splitDistance = 0;\n\n  for (let i = min + 1; i <= max; i++) {\n    let newDistance = nx * i + ny * histogram[i] - d;\n\n    if (newDistance > splitDistance) {\n      split = i;\n      splitDistance = newDistance;\n    }\n  }\n\n  split--;\n\n  if (inverted) {\n    // The histogram might be used for something else, so let's reverse it back\n    let left = 0;\n    let right = histogram.length - 1;\n\n    while (left < right) {\n      let temp = histogram[left];\n      histogram[left] = histogram[right];\n      histogram[right] = temp;\n      left++;\n      right--;\n    }\n\n    return histogram.length - 1 - split;\n  } else {\n    return split;\n  }\n}","map":{"version":3,"sources":["C:/Users/kuent/Documents/FinishDipshit/Creative/Ocean-Weather-Visualization/node_modules/image-js/src/image/transform/mask/triangle.js"],"names":["triangle","histogram","min","dmax","max","min2","i","length","inverted","left","right","temp","nx","ny","d","Math","sqrt","split","splitDistance","newDistance"],"mappings":"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","sourcesContent":["// see https://github.com/fiji/Auto_Threshold/blob/master/src/main/java/fiji/threshold/Auto_Threshold.java\n// Zack, G. W., Rogers, W. E. and Latt, S. A., 1977,\n// Automatic Measurement of Sister Chromatid Exchange Frequency,\n// Journal of Histochemistry and Cytochemistry 25 (7), pp. 741-753\n//\n//  modified from Johannes Schindelin plugin\nexport default function triangle(histogram) {\n  // find min and max\n  let min = 0;\n  let dmax = 0;\n  let max = 0;\n  let min2 = 0;\n  for (let i = 0; i < histogram.length; i++) {\n    if (histogram[i] > 0) {\n      min = i;\n      break;\n    }\n  }\n  if (min > 0) {\n    // line to the (p==0) point, not to histogram[min]\n    min--;\n  }\n\n  // The Triangle algorithm cannot tell whether the data is skewed to one side or another.\n  // This causes a problem as there are 2 possible thresholds between the max and the 2 extremes\n  // of the histogram.\n  // Here I propose to find out to which side of the max point the data is furthest, and use that as\n  //  the other extreme.\n  for (let i = histogram.length - 1; i > 0; i--) {\n    if (histogram[i] > 0) {\n      min2 = i;\n      break;\n    }\n  }\n  if (min2 < histogram.length - 1) {\n    // line to the (p==0) point, not to data[min]\n    min2++;\n  }\n\n  for (let i = 0; i < histogram.length; i++) {\n    if (histogram[i] > dmax) {\n      max = i;\n      dmax = histogram[i];\n    }\n  }\n\n  // find which is the furthest side\n  let inverted = false;\n  if (max - min < min2 - max) {\n    // reverse the histogram\n    inverted = true;\n    let left = 0; // index of leftmost element\n    let right = histogram.length - 1; // index of rightmost element\n    while (left < right) {\n      // exchange the left and right elements\n      let temp = histogram[left];\n      histogram[left] = histogram[right];\n      histogram[right] = temp;\n      // move the bounds toward the center\n      left++;\n      right--;\n    }\n    min = histogram.length - 1 - min2;\n    max = histogram.length - 1 - max;\n  }\n\n  if (min === max) {\n    return min;\n  }\n\n  // describe line by nx * x + ny * y - d = 0\n  let nx, ny, d;\n  // nx is just the max frequency as the other point has freq=0\n  nx = histogram[max]; // -min; // data[min]; //  lowest value bmin = (p=0)% in the image\n  ny = min - max;\n  d = Math.sqrt(nx * nx + ny * ny);\n  nx /= d;\n  ny /= d;\n  d = nx * min + ny * histogram[min];\n\n  // find split point\n  let split = min;\n  let splitDistance = 0;\n  for (let i = min + 1; i <= max; i++) {\n    let newDistance = nx * i + ny * histogram[i] - d;\n    if (newDistance > splitDistance) {\n      split = i;\n      splitDistance = newDistance;\n    }\n  }\n  split--;\n\n  if (inverted) {\n    // The histogram might be used for something else, so let's reverse it back\n    let left = 0;\n    let right = histogram.length - 1;\n    while (left < right) {\n      let temp = histogram[left];\n      histogram[left] = histogram[right];\n      histogram[right] = temp;\n      left++;\n      right--;\n    }\n    return histogram.length - 1 - split;\n  } else {\n    return split;\n  }\n}\n"]},"metadata":{},"sourceType":"module"}