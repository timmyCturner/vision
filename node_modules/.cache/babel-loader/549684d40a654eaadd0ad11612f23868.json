{"ast":null,"code":"import { decode, encode } from './utf8';\nconst defaultByteLength = 1024 * 8;\nexport class IOBuffer {\n  /**\r\n   * @param data - The data to construct the IOBuffer with.\r\n   * If data is a number, it will be the new buffer's length<br>\r\n   * If data is `undefined`, the buffer will be initialized with a default length of 8Kb<br>\r\n   * If data is an ArrayBuffer, SharedArrayBuffer, an ArrayBufferView (Typed Array), an IOBuffer instance,\r\n   * or a Node.js Buffer, a view will be created over the underlying ArrayBuffer.\r\n   * @param options\r\n   */\n  constructor(data = defaultByteLength, options = {}) {\n    let dataIsGiven = false;\n\n    if (typeof data === 'number') {\n      data = new ArrayBuffer(data);\n    } else {\n      dataIsGiven = true;\n      this.lastWrittenByte = data.byteLength;\n    }\n\n    const offset = options.offset ? options.offset >>> 0 : 0;\n    const byteLength = data.byteLength - offset;\n    let dvOffset = offset;\n\n    if (ArrayBuffer.isView(data) || data instanceof IOBuffer) {\n      if (data.byteLength !== data.buffer.byteLength) {\n        dvOffset = data.byteOffset + offset;\n      }\n\n      data = data.buffer;\n    }\n\n    if (dataIsGiven) {\n      this.lastWrittenByte = byteLength;\n    } else {\n      this.lastWrittenByte = 0;\n    }\n\n    this.buffer = data;\n    this.length = byteLength;\n    this.byteLength = byteLength;\n    this.byteOffset = dvOffset;\n    this.offset = 0;\n    this.littleEndian = true;\n    this._data = new DataView(this.buffer, dvOffset, byteLength);\n    this._mark = 0;\n    this._marks = [];\n  }\n  /**\r\n   * Checks if the memory allocated to the buffer is sufficient to store more\r\n   * bytes after the offset.\r\n   * @param byteLength - The needed memory in bytes.\r\n   * @returns `true` if there is sufficient space and `false` otherwise.\r\n   */\n\n\n  available(byteLength = 1) {\n    return this.offset + byteLength <= this.length;\n  }\n  /**\r\n   * Check if little-endian mode is used for reading and writing multi-byte\r\n   * values.\r\n   * @returns `true` if little-endian mode is used, `false` otherwise.\r\n   */\n\n\n  isLittleEndian() {\n    return this.littleEndian;\n  }\n  /**\r\n   * Set little-endian mode for reading and writing multi-byte values.\r\n   */\n\n\n  setLittleEndian() {\n    this.littleEndian = true;\n    return this;\n  }\n  /**\r\n   * Check if big-endian mode is used for reading and writing multi-byte values.\r\n   * @returns `true` if big-endian mode is used, `false` otherwise.\r\n   */\n\n\n  isBigEndian() {\n    return !this.littleEndian;\n  }\n  /**\r\n   * Switches to big-endian mode for reading and writing multi-byte values.\r\n   */\n\n\n  setBigEndian() {\n    this.littleEndian = false;\n    return this;\n  }\n  /**\r\n   * Move the pointer n bytes forward.\r\n   * @param n - Number of bytes to skip.\r\n   */\n\n\n  skip(n = 1) {\n    this.offset += n;\n    return this;\n  }\n  /**\r\n   * Move the pointer to the given offset.\r\n   * @param offset\r\n   */\n\n\n  seek(offset) {\n    this.offset = offset;\n    return this;\n  }\n  /**\r\n   * Store the current pointer offset.\r\n   * @see {@link IOBuffer#reset}\r\n   */\n\n\n  mark() {\n    this._mark = this.offset;\n    return this;\n  }\n  /**\r\n   * Move the pointer back to the last pointer offset set by mark.\r\n   * @see {@link IOBuffer#mark}\r\n   */\n\n\n  reset() {\n    this.offset = this._mark;\n    return this;\n  }\n  /**\r\n   * Push the current pointer offset to the mark stack.\r\n   * @see {@link IOBuffer#popMark}\r\n   */\n\n\n  pushMark() {\n    this._marks.push(this.offset);\n\n    return this;\n  }\n  /**\r\n   * Pop the last pointer offset from the mark stack, and set the current\r\n   * pointer offset to the popped value.\r\n   * @see {@link IOBuffer#pushMark}\r\n   */\n\n\n  popMark() {\n    const offset = this._marks.pop();\n\n    if (offset === undefined) {\n      throw new Error('Mark stack empty');\n    }\n\n    this.seek(offset);\n    return this;\n  }\n  /**\r\n   * Move the pointer offset back to 0.\r\n   */\n\n\n  rewind() {\n    this.offset = 0;\n    return this;\n  }\n  /**\r\n   * Make sure the buffer has sufficient memory to write a given byteLength at\r\n   * the current pointer offset.\r\n   * If the buffer's memory is insufficient, this method will create a new\r\n   * buffer (a copy) with a length that is twice (byteLength + current offset).\r\n   * @param byteLength\r\n   */\n\n\n  ensureAvailable(byteLength = 1) {\n    if (!this.available(byteLength)) {\n      const lengthNeeded = this.offset + byteLength;\n      const newLength = lengthNeeded * 2;\n      const newArray = new Uint8Array(newLength);\n      newArray.set(new Uint8Array(this.buffer));\n      this.buffer = newArray.buffer;\n      this.length = this.byteLength = newLength;\n      this._data = new DataView(this.buffer);\n    }\n\n    return this;\n  }\n  /**\r\n   * Read a byte and return false if the byte's value is 0, or true otherwise.\r\n   * Moves pointer forward by one byte.\r\n   */\n\n\n  readBoolean() {\n    return this.readUint8() !== 0;\n  }\n  /**\r\n   * Read a signed 8-bit integer and move pointer forward by 1 byte.\r\n   */\n\n\n  readInt8() {\n    return this._data.getInt8(this.offset++);\n  }\n  /**\r\n   * Read an unsigned 8-bit integer and move pointer forward by 1 byte.\r\n   */\n\n\n  readUint8() {\n    return this._data.getUint8(this.offset++);\n  }\n  /**\r\n   * Alias for {@link IOBuffer#readUint8}.\r\n   */\n\n\n  readByte() {\n    return this.readUint8();\n  }\n  /**\r\n   * Read `n` bytes and move pointer forward by `n` bytes.\r\n   */\n\n\n  readBytes(n = 1) {\n    const bytes = new Uint8Array(n);\n\n    for (let i = 0; i < n; i++) {\n      bytes[i] = this.readByte();\n    }\n\n    return bytes;\n  }\n  /**\r\n   * Read a 16-bit signed integer and move pointer forward by 2 bytes.\r\n   */\n\n\n  readInt16() {\n    const value = this._data.getInt16(this.offset, this.littleEndian);\n\n    this.offset += 2;\n    return value;\n  }\n  /**\r\n   * Read a 16-bit unsigned integer and move pointer forward by 2 bytes.\r\n   */\n\n\n  readUint16() {\n    const value = this._data.getUint16(this.offset, this.littleEndian);\n\n    this.offset += 2;\n    return value;\n  }\n  /**\r\n   * Read a 32-bit signed integer and move pointer forward by 4 bytes.\r\n   */\n\n\n  readInt32() {\n    const value = this._data.getInt32(this.offset, this.littleEndian);\n\n    this.offset += 4;\n    return value;\n  }\n  /**\r\n   * Read a 32-bit unsigned integer and move pointer forward by 4 bytes.\r\n   */\n\n\n  readUint32() {\n    const value = this._data.getUint32(this.offset, this.littleEndian);\n\n    this.offset += 4;\n    return value;\n  }\n  /**\r\n   * Read a 32-bit floating number and move pointer forward by 4 bytes.\r\n   */\n\n\n  readFloat32() {\n    const value = this._data.getFloat32(this.offset, this.littleEndian);\n\n    this.offset += 4;\n    return value;\n  }\n  /**\r\n   * Read a 64-bit floating number and move pointer forward by 8 bytes.\r\n   */\n\n\n  readFloat64() {\n    const value = this._data.getFloat64(this.offset, this.littleEndian);\n\n    this.offset += 8;\n    return value;\n  }\n  /**\r\n   * Read a 1-byte ASCII character and move pointer forward by 1 byte.\r\n   */\n\n\n  readChar() {\n    return String.fromCharCode(this.readInt8());\n  }\n  /**\r\n   * Read `n` 1-byte ASCII characters and move pointer forward by `n` bytes.\r\n   */\n\n\n  readChars(n = 1) {\n    let result = '';\n\n    for (let i = 0; i < n; i++) {\n      result += this.readChar();\n    }\n\n    return result;\n  }\n  /**\r\n   * Read the next `n` bytes, return a UTF-8 decoded string and move pointer\r\n   * forward by `n` bytes.\r\n   */\n\n\n  readUtf8(n = 1) {\n    return decode(this.readBytes(n));\n  }\n  /**\r\n   * Write 0xff if the passed value is truthy, 0x00 otherwise and move pointer\r\n   * forward by 1 byte.\r\n   */\n\n\n  writeBoolean(value) {\n    this.writeUint8(value ? 0xff : 0x00);\n    return this;\n  }\n  /**\r\n   * Write `value` as an 8-bit signed integer and move pointer forward by 1 byte.\r\n   */\n\n\n  writeInt8(value) {\n    this.ensureAvailable(1);\n\n    this._data.setInt8(this.offset++, value);\n\n    this._updateLastWrittenByte();\n\n    return this;\n  }\n  /**\r\n   * Write `value` as an 8-bit unsigned integer and move pointer forward by 1\r\n   * byte.\r\n   */\n\n\n  writeUint8(value) {\n    this.ensureAvailable(1);\n\n    this._data.setUint8(this.offset++, value);\n\n    this._updateLastWrittenByte();\n\n    return this;\n  }\n  /**\r\n   * An alias for {@link IOBuffer#writeUint8}.\r\n   */\n\n\n  writeByte(value) {\n    return this.writeUint8(value);\n  }\n  /**\r\n   * Write all elements of `bytes` as uint8 values and move pointer forward by\r\n   * `bytes.length` bytes.\r\n   */\n\n\n  writeBytes(bytes) {\n    this.ensureAvailable(bytes.length);\n\n    for (let i = 0; i < bytes.length; i++) {\n      this._data.setUint8(this.offset++, bytes[i]);\n    }\n\n    this._updateLastWrittenByte();\n\n    return this;\n  }\n  /**\r\n   * Write `value` as a 16-bit signed integer and move pointer forward by 2\r\n   * bytes.\r\n   */\n\n\n  writeInt16(value) {\n    this.ensureAvailable(2);\n\n    this._data.setInt16(this.offset, value, this.littleEndian);\n\n    this.offset += 2;\n\n    this._updateLastWrittenByte();\n\n    return this;\n  }\n  /**\r\n   * Write `value` as a 16-bit unsigned integer and move pointer forward by 2\r\n   * bytes.\r\n   */\n\n\n  writeUint16(value) {\n    this.ensureAvailable(2);\n\n    this._data.setUint16(this.offset, value, this.littleEndian);\n\n    this.offset += 2;\n\n    this._updateLastWrittenByte();\n\n    return this;\n  }\n  /**\r\n   * Write `value` as a 32-bit signed integer and move pointer forward by 4\r\n   * bytes.\r\n   */\n\n\n  writeInt32(value) {\n    this.ensureAvailable(4);\n\n    this._data.setInt32(this.offset, value, this.littleEndian);\n\n    this.offset += 4;\n\n    this._updateLastWrittenByte();\n\n    return this;\n  }\n  /**\r\n   * Write `value` as a 32-bit unsigned integer and move pointer forward by 4\r\n   * bytes.\r\n   */\n\n\n  writeUint32(value) {\n    this.ensureAvailable(4);\n\n    this._data.setUint32(this.offset, value, this.littleEndian);\n\n    this.offset += 4;\n\n    this._updateLastWrittenByte();\n\n    return this;\n  }\n  /**\r\n   * Write `value` as a 32-bit floating number and move pointer forward by 4\r\n   * bytes.\r\n   */\n\n\n  writeFloat32(value) {\n    this.ensureAvailable(4);\n\n    this._data.setFloat32(this.offset, value, this.littleEndian);\n\n    this.offset += 4;\n\n    this._updateLastWrittenByte();\n\n    return this;\n  }\n  /**\r\n   * Write `value` as a 64-bit floating number and move pointer forward by 8\r\n   * bytes.\r\n   */\n\n\n  writeFloat64(value) {\n    this.ensureAvailable(8);\n\n    this._data.setFloat64(this.offset, value, this.littleEndian);\n\n    this.offset += 8;\n\n    this._updateLastWrittenByte();\n\n    return this;\n  }\n  /**\r\n   * Write the charCode of `str`'s first character as an 8-bit unsigned integer\r\n   * and move pointer forward by 1 byte.\r\n   */\n\n\n  writeChar(str) {\n    return this.writeUint8(str.charCodeAt(0));\n  }\n  /**\r\n   * Write the charCodes of all `str`'s characters as 8-bit unsigned integers\r\n   * and move pointer forward by `str.length` bytes.\r\n   */\n\n\n  writeChars(str) {\n    for (let i = 0; i < str.length; i++) {\n      this.writeUint8(str.charCodeAt(i));\n    }\n\n    return this;\n  }\n  /**\r\n   * UTF-8 encode and write `str` to the current pointer offset and move pointer\r\n   * forward according to the encoded length.\r\n   */\n\n\n  writeUtf8(str) {\n    return this.writeBytes(encode(str));\n  }\n  /**\r\n   * Export a Uint8Array view of the internal buffer.\r\n   * The view starts at the byte offset and its length\r\n   * is calculated to stop at the last written byte or the original length.\r\n   */\n\n\n  toArray() {\n    return new Uint8Array(this.buffer, this.byteOffset, this.lastWrittenByte);\n  }\n  /**\r\n   * Update the last written byte offset\r\n   * @private\r\n   */\n\n\n  _updateLastWrittenByte() {\n    if (this.offset > this.lastWrittenByte) {\n      this.lastWrittenByte = this.offset;\n    }\n  }\n\n}","map":{"version":3,"sources":["../src/IOBuffer.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { decode, encode } from './utf8';\r\nconst defaultByteLength = 1024 * 8;\r\nexport class IOBuffer {\r\n    /**\r\n     * @param data - The data to construct the IOBuffer with.\r\n     * If data is a number, it will be the new buffer's length<br>\r\n     * If data is `undefined`, the buffer will be initialized with a default length of 8Kb<br>\r\n     * If data is an ArrayBuffer, SharedArrayBuffer, an ArrayBufferView (Typed Array), an IOBuffer instance,\r\n     * or a Node.js Buffer, a view will be created over the underlying ArrayBuffer.\r\n     * @param options\r\n     */\r\n    constructor(data = defaultByteLength, options = {}) {\r\n        let dataIsGiven = false;\r\n        if (typeof data === 'number') {\r\n            data = new ArrayBuffer(data);\r\n        }\r\n        else {\r\n            dataIsGiven = true;\r\n            this.lastWrittenByte = data.byteLength;\r\n        }\r\n        const offset = options.offset ? options.offset >>> 0 : 0;\r\n        const byteLength = data.byteLength - offset;\r\n        let dvOffset = offset;\r\n        if (ArrayBuffer.isView(data) || data instanceof IOBuffer) {\r\n            if (data.byteLength !== data.buffer.byteLength) {\r\n                dvOffset = data.byteOffset + offset;\r\n            }\r\n            data = data.buffer;\r\n        }\r\n        if (dataIsGiven) {\r\n            this.lastWrittenByte = byteLength;\r\n        }\r\n        else {\r\n            this.lastWrittenByte = 0;\r\n        }\r\n        this.buffer = data;\r\n        this.length = byteLength;\r\n        this.byteLength = byteLength;\r\n        this.byteOffset = dvOffset;\r\n        this.offset = 0;\r\n        this.littleEndian = true;\r\n        this._data = new DataView(this.buffer, dvOffset, byteLength);\r\n        this._mark = 0;\r\n        this._marks = [];\r\n    }\r\n    /**\r\n     * Checks if the memory allocated to the buffer is sufficient to store more\r\n     * bytes after the offset.\r\n     * @param byteLength - The needed memory in bytes.\r\n     * @returns `true` if there is sufficient space and `false` otherwise.\r\n     */\r\n    available(byteLength = 1) {\r\n        return this.offset + byteLength <= this.length;\r\n    }\r\n    /**\r\n     * Check if little-endian mode is used for reading and writing multi-byte\r\n     * values.\r\n     * @returns `true` if little-endian mode is used, `false` otherwise.\r\n     */\r\n    isLittleEndian() {\r\n        return this.littleEndian;\r\n    }\r\n    /**\r\n     * Set little-endian mode for reading and writing multi-byte values.\r\n     */\r\n    setLittleEndian() {\r\n        this.littleEndian = true;\r\n        return this;\r\n    }\r\n    /**\r\n     * Check if big-endian mode is used for reading and writing multi-byte values.\r\n     * @returns `true` if big-endian mode is used, `false` otherwise.\r\n     */\r\n    isBigEndian() {\r\n        return !this.littleEndian;\r\n    }\r\n    /**\r\n     * Switches to big-endian mode for reading and writing multi-byte values.\r\n     */\r\n    setBigEndian() {\r\n        this.littleEndian = false;\r\n        return this;\r\n    }\r\n    /**\r\n     * Move the pointer n bytes forward.\r\n     * @param n - Number of bytes to skip.\r\n     */\r\n    skip(n = 1) {\r\n        this.offset += n;\r\n        return this;\r\n    }\r\n    /**\r\n     * Move the pointer to the given offset.\r\n     * @param offset\r\n     */\r\n    seek(offset) {\r\n        this.offset = offset;\r\n        return this;\r\n    }\r\n    /**\r\n     * Store the current pointer offset.\r\n     * @see {@link IOBuffer#reset}\r\n     */\r\n    mark() {\r\n        this._mark = this.offset;\r\n        return this;\r\n    }\r\n    /**\r\n     * Move the pointer back to the last pointer offset set by mark.\r\n     * @see {@link IOBuffer#mark}\r\n     */\r\n    reset() {\r\n        this.offset = this._mark;\r\n        return this;\r\n    }\r\n    /**\r\n     * Push the current pointer offset to the mark stack.\r\n     * @see {@link IOBuffer#popMark}\r\n     */\r\n    pushMark() {\r\n        this._marks.push(this.offset);\r\n        return this;\r\n    }\r\n    /**\r\n     * Pop the last pointer offset from the mark stack, and set the current\r\n     * pointer offset to the popped value.\r\n     * @see {@link IOBuffer#pushMark}\r\n     */\r\n    popMark() {\r\n        const offset = this._marks.pop();\r\n        if (offset === undefined) {\r\n            throw new Error('Mark stack empty');\r\n        }\r\n        this.seek(offset);\r\n        return this;\r\n    }\r\n    /**\r\n     * Move the pointer offset back to 0.\r\n     */\r\n    rewind() {\r\n        this.offset = 0;\r\n        return this;\r\n    }\r\n    /**\r\n     * Make sure the buffer has sufficient memory to write a given byteLength at\r\n     * the current pointer offset.\r\n     * If the buffer's memory is insufficient, this method will create a new\r\n     * buffer (a copy) with a length that is twice (byteLength + current offset).\r\n     * @param byteLength\r\n     */\r\n    ensureAvailable(byteLength = 1) {\r\n        if (!this.available(byteLength)) {\r\n            const lengthNeeded = this.offset + byteLength;\r\n            const newLength = lengthNeeded * 2;\r\n            const newArray = new Uint8Array(newLength);\r\n            newArray.set(new Uint8Array(this.buffer));\r\n            this.buffer = newArray.buffer;\r\n            this.length = this.byteLength = newLength;\r\n            this._data = new DataView(this.buffer);\r\n        }\r\n        return this;\r\n    }\r\n    /**\r\n     * Read a byte and return false if the byte's value is 0, or true otherwise.\r\n     * Moves pointer forward by one byte.\r\n     */\r\n    readBoolean() {\r\n        return this.readUint8() !== 0;\r\n    }\r\n    /**\r\n     * Read a signed 8-bit integer and move pointer forward by 1 byte.\r\n     */\r\n    readInt8() {\r\n        return this._data.getInt8(this.offset++);\r\n    }\r\n    /**\r\n     * Read an unsigned 8-bit integer and move pointer forward by 1 byte.\r\n     */\r\n    readUint8() {\r\n        return this._data.getUint8(this.offset++);\r\n    }\r\n    /**\r\n     * Alias for {@link IOBuffer#readUint8}.\r\n     */\r\n    readByte() {\r\n        return this.readUint8();\r\n    }\r\n    /**\r\n     * Read `n` bytes and move pointer forward by `n` bytes.\r\n     */\r\n    readBytes(n = 1) {\r\n        const bytes = new Uint8Array(n);\r\n        for (let i = 0; i < n; i++) {\r\n            bytes[i] = this.readByte();\r\n        }\r\n        return bytes;\r\n    }\r\n    /**\r\n     * Read a 16-bit signed integer and move pointer forward by 2 bytes.\r\n     */\r\n    readInt16() {\r\n        const value = this._data.getInt16(this.offset, this.littleEndian);\r\n        this.offset += 2;\r\n        return value;\r\n    }\r\n    /**\r\n     * Read a 16-bit unsigned integer and move pointer forward by 2 bytes.\r\n     */\r\n    readUint16() {\r\n        const value = this._data.getUint16(this.offset, this.littleEndian);\r\n        this.offset += 2;\r\n        return value;\r\n    }\r\n    /**\r\n     * Read a 32-bit signed integer and move pointer forward by 4 bytes.\r\n     */\r\n    readInt32() {\r\n        const value = this._data.getInt32(this.offset, this.littleEndian);\r\n        this.offset += 4;\r\n        return value;\r\n    }\r\n    /**\r\n     * Read a 32-bit unsigned integer and move pointer forward by 4 bytes.\r\n     */\r\n    readUint32() {\r\n        const value = this._data.getUint32(this.offset, this.littleEndian);\r\n        this.offset += 4;\r\n        return value;\r\n    }\r\n    /**\r\n     * Read a 32-bit floating number and move pointer forward by 4 bytes.\r\n     */\r\n    readFloat32() {\r\n        const value = this._data.getFloat32(this.offset, this.littleEndian);\r\n        this.offset += 4;\r\n        return value;\r\n    }\r\n    /**\r\n     * Read a 64-bit floating number and move pointer forward by 8 bytes.\r\n     */\r\n    readFloat64() {\r\n        const value = this._data.getFloat64(this.offset, this.littleEndian);\r\n        this.offset += 8;\r\n        return value;\r\n    }\r\n    /**\r\n     * Read a 1-byte ASCII character and move pointer forward by 1 byte.\r\n     */\r\n    readChar() {\r\n        return String.fromCharCode(this.readInt8());\r\n    }\r\n    /**\r\n     * Read `n` 1-byte ASCII characters and move pointer forward by `n` bytes.\r\n     */\r\n    readChars(n = 1) {\r\n        let result = '';\r\n        for (let i = 0; i < n; i++) {\r\n            result += this.readChar();\r\n        }\r\n        return result;\r\n    }\r\n    /**\r\n     * Read the next `n` bytes, return a UTF-8 decoded string and move pointer\r\n     * forward by `n` bytes.\r\n     */\r\n    readUtf8(n = 1) {\r\n        return decode(this.readBytes(n));\r\n    }\r\n    /**\r\n     * Write 0xff if the passed value is truthy, 0x00 otherwise and move pointer\r\n     * forward by 1 byte.\r\n     */\r\n    writeBoolean(value) {\r\n        this.writeUint8(value ? 0xff : 0x00);\r\n        return this;\r\n    }\r\n    /**\r\n     * Write `value` as an 8-bit signed integer and move pointer forward by 1 byte.\r\n     */\r\n    writeInt8(value) {\r\n        this.ensureAvailable(1);\r\n        this._data.setInt8(this.offset++, value);\r\n        this._updateLastWrittenByte();\r\n        return this;\r\n    }\r\n    /**\r\n     * Write `value` as an 8-bit unsigned integer and move pointer forward by 1\r\n     * byte.\r\n     */\r\n    writeUint8(value) {\r\n        this.ensureAvailable(1);\r\n        this._data.setUint8(this.offset++, value);\r\n        this._updateLastWrittenByte();\r\n        return this;\r\n    }\r\n    /**\r\n     * An alias for {@link IOBuffer#writeUint8}.\r\n     */\r\n    writeByte(value) {\r\n        return this.writeUint8(value);\r\n    }\r\n    /**\r\n     * Write all elements of `bytes` as uint8 values and move pointer forward by\r\n     * `bytes.length` bytes.\r\n     */\r\n    writeBytes(bytes) {\r\n        this.ensureAvailable(bytes.length);\r\n        for (let i = 0; i < bytes.length; i++) {\r\n            this._data.setUint8(this.offset++, bytes[i]);\r\n        }\r\n        this._updateLastWrittenByte();\r\n        return this;\r\n    }\r\n    /**\r\n     * Write `value` as a 16-bit signed integer and move pointer forward by 2\r\n     * bytes.\r\n     */\r\n    writeInt16(value) {\r\n        this.ensureAvailable(2);\r\n        this._data.setInt16(this.offset, value, this.littleEndian);\r\n        this.offset += 2;\r\n        this._updateLastWrittenByte();\r\n        return this;\r\n    }\r\n    /**\r\n     * Write `value` as a 16-bit unsigned integer and move pointer forward by 2\r\n     * bytes.\r\n     */\r\n    writeUint16(value) {\r\n        this.ensureAvailable(2);\r\n        this._data.setUint16(this.offset, value, this.littleEndian);\r\n        this.offset += 2;\r\n        this._updateLastWrittenByte();\r\n        return this;\r\n    }\r\n    /**\r\n     * Write `value` as a 32-bit signed integer and move pointer forward by 4\r\n     * bytes.\r\n     */\r\n    writeInt32(value) {\r\n        this.ensureAvailable(4);\r\n        this._data.setInt32(this.offset, value, this.littleEndian);\r\n        this.offset += 4;\r\n        this._updateLastWrittenByte();\r\n        return this;\r\n    }\r\n    /**\r\n     * Write `value` as a 32-bit unsigned integer and move pointer forward by 4\r\n     * bytes.\r\n     */\r\n    writeUint32(value) {\r\n        this.ensureAvailable(4);\r\n        this._data.setUint32(this.offset, value, this.littleEndian);\r\n        this.offset += 4;\r\n        this._updateLastWrittenByte();\r\n        return this;\r\n    }\r\n    /**\r\n     * Write `value` as a 32-bit floating number and move pointer forward by 4\r\n     * bytes.\r\n     */\r\n    writeFloat32(value) {\r\n        this.ensureAvailable(4);\r\n        this._data.setFloat32(this.offset, value, this.littleEndian);\r\n        this.offset += 4;\r\n        this._updateLastWrittenByte();\r\n        return this;\r\n    }\r\n    /**\r\n     * Write `value` as a 64-bit floating number and move pointer forward by 8\r\n     * bytes.\r\n     */\r\n    writeFloat64(value) {\r\n        this.ensureAvailable(8);\r\n        this._data.setFloat64(this.offset, value, this.littleEndian);\r\n        this.offset += 8;\r\n        this._updateLastWrittenByte();\r\n        return this;\r\n    }\r\n    /**\r\n     * Write the charCode of `str`'s first character as an 8-bit unsigned integer\r\n     * and move pointer forward by 1 byte.\r\n     */\r\n    writeChar(str) {\r\n        return this.writeUint8(str.charCodeAt(0));\r\n    }\r\n    /**\r\n     * Write the charCodes of all `str`'s characters as 8-bit unsigned integers\r\n     * and move pointer forward by `str.length` bytes.\r\n     */\r\n    writeChars(str) {\r\n        for (let i = 0; i < str.length; i++) {\r\n            this.writeUint8(str.charCodeAt(i));\r\n        }\r\n        return this;\r\n    }\r\n    /**\r\n     * UTF-8 encode and write `str` to the current pointer offset and move pointer\r\n     * forward according to the encoded length.\r\n     */\r\n    writeUtf8(str) {\r\n        return this.writeBytes(encode(str));\r\n    }\r\n    /**\r\n     * Export a Uint8Array view of the internal buffer.\r\n     * The view starts at the byte offset and its length\r\n     * is calculated to stop at the last written byte or the original length.\r\n     */\r\n    toArray() {\r\n        return new Uint8Array(this.buffer, this.byteOffset, this.lastWrittenByte);\r\n    }\r\n    /**\r\n     * Update the last written byte offset\r\n     * @private\r\n     */\r\n    _updateLastWrittenByte() {\r\n        if (this.offset > this.lastWrittenByte) {\r\n            this.lastWrittenByte = this.offset;\r\n        }\r\n    }\r\n}\r\n//# sourceMappingURL=IOBuffer.js.map"]},"metadata":{},"sourceType":"module"}