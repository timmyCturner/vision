{"ast":null,"code":"import { IOBuffer } from 'iobuffer';\nimport { Inflate as Inflator } from 'pako';\nimport { pngSignature, crc } from './common';\nimport { ColorType, CompressionMethod, FilterMethod, InterlaceMethod } from './internalTypes';\nconst empty = new Uint8Array(0);\nconst NULL = '\\0';\nconst uint16 = new Uint16Array([0x00ff]);\nconst uint8 = new Uint8Array(uint16.buffer);\nconst osIsLittleEndian = uint8[0] === 0xff;\nexport default class PNGDecoder extends IOBuffer {\n  constructor(data, options = {}) {\n    super(data);\n    const {\n      checkCrc = false\n    } = options;\n    this._checkCrc = checkCrc;\n    this._inflator = new Inflator();\n    this._png = {\n      width: -1,\n      height: -1,\n      channels: -1,\n      data: new Uint8Array(0),\n      depth: 1,\n      text: {}\n    };\n    this._end = false;\n    this._hasPalette = false;\n    this._palette = [];\n    this._compressionMethod = CompressionMethod.UNKNOWN;\n    this._filterMethod = FilterMethod.UNKNOWN;\n    this._interlaceMethod = InterlaceMethod.UNKNOWN;\n    this._colorType = -1; // PNG is always big endian\n    // https://www.w3.org/TR/PNG/#7Integers-and-byte-order\n\n    this.setBigEndian();\n  }\n\n  decode() {\n    this.decodeSignature();\n\n    while (!this._end) {\n      this.decodeChunk();\n    }\n\n    this.decodeImage();\n    return this._png;\n  } // https://www.w3.org/TR/PNG/#5PNG-file-signature\n\n\n  decodeSignature() {\n    for (let i = 0; i < pngSignature.length; i++) {\n      if (this.readUint8() !== pngSignature[i]) {\n        throw new Error(`wrong PNG signature. Byte at ${i} should be ${pngSignature[i]}.`);\n      }\n    }\n  } // https://www.w3.org/TR/PNG/#5Chunk-layout\n\n\n  decodeChunk() {\n    const length = this.readUint32();\n    const type = this.readChars(4);\n    const offset = this.offset;\n\n    switch (type) {\n      // 11.2 Critical chunks\n      case 'IHDR':\n        // 11.2.2 IHDR Image header\n        this.decodeIHDR();\n        break;\n\n      case 'PLTE':\n        // 11.2.3 PLTE Palette\n        this.decodePLTE(length);\n        break;\n\n      case 'IDAT':\n        // 11.2.4 IDAT Image data\n        this.decodeIDAT(length);\n        break;\n\n      case 'IEND':\n        // 11.2.5 IEND Image trailer\n        this._end = true;\n        break;\n      // 11.3 Ancillary chunks\n\n      case 'tRNS':\n        // 11.3.2.1 tRNS Transparency\n        this.decodetRNS(length);\n        break;\n\n      case 'tEXt':\n        // 11.3.4.3 tEXt Textual data\n        this.decodetEXt(length);\n        break;\n\n      case 'pHYs':\n        // 11.3.5.3 pHYs Physical pixel dimensions\n        this.decodepHYs();\n        break;\n\n      default:\n        this.skip(length);\n        break;\n    }\n\n    if (this.offset - offset !== length) {\n      throw new Error(`Length mismatch while decoding chunk ${type}`);\n    }\n\n    if (this._checkCrc) {\n      const expectedCrc = this.readUint32();\n      const crcLength = length + 4; // includes type\n\n      const actualCrc = crc(new Uint8Array(this.buffer, this.byteOffset + this.offset - crcLength - 4, crcLength), crcLength); // \"- 4\" because we already advanced by reading the CRC\n\n      if (actualCrc !== expectedCrc) {\n        throw new Error(`CRC mismatch for chunk ${type}. Expected ${expectedCrc}, found ${actualCrc}`);\n      }\n    } else {\n      this.skip(4);\n    }\n  } // https://www.w3.org/TR/PNG/#11IHDR\n\n\n  decodeIHDR() {\n    const image = this._png;\n    image.width = this.readUint32();\n    image.height = this.readUint32();\n    image.depth = checkBitDepth(this.readUint8());\n    const colorType = this.readUint8();\n    this._colorType = colorType;\n    let channels;\n\n    switch (colorType) {\n      case ColorType.GREYSCALE:\n        channels = 1;\n        break;\n\n      case ColorType.TRUECOLOUR:\n        channels = 3;\n        break;\n\n      case ColorType.INDEXED_COLOUR:\n        channels = 1;\n        break;\n\n      case ColorType.GREYSCALE_ALPHA:\n        channels = 2;\n        break;\n\n      case ColorType.TRUECOLOUR_ALPHA:\n        channels = 4;\n        break;\n\n      default:\n        throw new Error(`Unknown color type: ${colorType}`);\n    }\n\n    this._png.channels = channels;\n    this._compressionMethod = this.readUint8();\n\n    if (this._compressionMethod !== CompressionMethod.DEFLATE) {\n      throw new Error(`Unsupported compression method: ${this._compressionMethod}`);\n    }\n\n    this._filterMethod = this.readUint8();\n    this._interlaceMethod = this.readUint8();\n  } // https://www.w3.org/TR/PNG/#11PLTE\n\n\n  decodePLTE(length) {\n    if (length % 3 !== 0) {\n      throw new RangeError(`PLTE field length must be a multiple of 3. Got ${length}`);\n    }\n\n    const l = length / 3;\n    this._hasPalette = true;\n    const palette = [];\n    this._palette = palette;\n\n    for (let i = 0; i < l; i++) {\n      palette.push([this.readUint8(), this.readUint8(), this.readUint8()]);\n    }\n  } // https://www.w3.org/TR/PNG/#11IDAT\n\n\n  decodeIDAT(length) {\n    this._inflator.push(new Uint8Array(this.buffer, this.offset + this.byteOffset, length), false);\n\n    this.skip(length);\n  } // https://www.w3.org/TR/PNG/#11tRNS\n\n\n  decodetRNS(length) {\n    // TODO: support other color types.\n    if (this._colorType === 3) {\n      if (length > this._palette.length) {\n        throw new Error(`tRNS chunk contains more alpha values than there are palette colors (${length} vs ${this._palette.length})`);\n      }\n\n      let i = 0;\n\n      for (; i < length; i++) {\n        const alpha = this.readByte();\n\n        this._palette[i].push(alpha);\n      }\n\n      for (; i < this._palette.length; i++) {\n        this._palette[i].push(255);\n      }\n    }\n  } // https://www.w3.org/TR/PNG/#11tEXt\n\n\n  decodetEXt(length) {\n    let keyword = '';\n    let char;\n\n    while ((char = this.readChar()) !== NULL) {\n      keyword += char;\n    }\n\n    this._png.text[keyword] = this.readChars(length - keyword.length - 1);\n  } // https://www.w3.org/TR/PNG/#11pHYs\n\n\n  decodepHYs() {\n    const ppuX = this.readUint32();\n    const ppuY = this.readUint32();\n    const unitSpecifier = this.readByte();\n    this._png.resolution = {\n      x: ppuX,\n      y: ppuY,\n      unit: unitSpecifier\n    };\n  }\n\n  decodeImage() {\n    this._inflator.push(empty, true);\n\n    if (this._inflator.err) {\n      throw new Error(`Error while decompressing the data: ${this._inflator.err}`);\n    }\n\n    const data = this._inflator.result;\n\n    if (this._filterMethod !== FilterMethod.ADAPTIVE) {\n      throw new Error(`Filter method ${this._filterMethod} not supported`);\n    }\n\n    if (this._interlaceMethod === InterlaceMethod.NO_INTERLACE) {\n      this.decodeInterlaceNull(data);\n    } else {\n      throw new Error(`Interlace method ${this._interlaceMethod} not supported`);\n    }\n  }\n\n  decodeInterlaceNull(data) {\n    const height = this._png.height;\n    const bytesPerPixel = this._png.channels * this._png.depth / 8;\n    const bytesPerLine = this._png.width * bytesPerPixel;\n    const newData = new Uint8Array(this._png.height * bytesPerLine);\n    let prevLine = empty;\n    let offset = 0;\n    let currentLine;\n    let newLine;\n\n    for (let i = 0; i < height; i++) {\n      currentLine = data.subarray(offset + 1, offset + 1 + bytesPerLine);\n      newLine = newData.subarray(i * bytesPerLine, (i + 1) * bytesPerLine);\n\n      switch (data[offset]) {\n        case 0:\n          unfilterNone(currentLine, newLine, bytesPerLine);\n          break;\n\n        case 1:\n          unfilterSub(currentLine, newLine, bytesPerLine, bytesPerPixel);\n          break;\n\n        case 2:\n          unfilterUp(currentLine, newLine, prevLine, bytesPerLine);\n          break;\n\n        case 3:\n          unfilterAverage(currentLine, newLine, prevLine, bytesPerLine, bytesPerPixel);\n          break;\n\n        case 4:\n          unfilterPaeth(currentLine, newLine, prevLine, bytesPerLine, bytesPerPixel);\n          break;\n\n        default:\n          throw new Error(`Unsupported filter: ${data[offset]}`);\n      }\n\n      prevLine = newLine;\n      offset += bytesPerLine + 1;\n    }\n\n    if (this._hasPalette) {\n      this._png.palette = this._palette;\n    }\n\n    if (this._png.depth === 16) {\n      const uint16Data = new Uint16Array(newData.buffer);\n\n      if (osIsLittleEndian) {\n        for (let k = 0; k < uint16Data.length; k++) {\n          // PNG is always big endian. Swap the bytes.\n          uint16Data[k] = swap16(uint16Data[k]);\n        }\n      }\n\n      this._png.data = uint16Data;\n    } else {\n      this._png.data = newData;\n    }\n  }\n\n}\n\nfunction unfilterNone(currentLine, newLine, bytesPerLine) {\n  for (let i = 0; i < bytesPerLine; i++) {\n    newLine[i] = currentLine[i];\n  }\n}\n\nfunction unfilterSub(currentLine, newLine, bytesPerLine, bytesPerPixel) {\n  let i = 0;\n\n  for (; i < bytesPerPixel; i++) {\n    // just copy first bytes\n    newLine[i] = currentLine[i];\n  }\n\n  for (; i < bytesPerLine; i++) {\n    newLine[i] = currentLine[i] + newLine[i - bytesPerPixel] & 0xff;\n  }\n}\n\nfunction unfilterUp(currentLine, newLine, prevLine, bytesPerLine) {\n  let i = 0;\n\n  if (prevLine.length === 0) {\n    // just copy bytes for first line\n    for (; i < bytesPerLine; i++) {\n      newLine[i] = currentLine[i];\n    }\n  } else {\n    for (; i < bytesPerLine; i++) {\n      newLine[i] = currentLine[i] + prevLine[i] & 0xff;\n    }\n  }\n}\n\nfunction unfilterAverage(currentLine, newLine, prevLine, bytesPerLine, bytesPerPixel) {\n  let i = 0;\n\n  if (prevLine.length === 0) {\n    for (; i < bytesPerPixel; i++) {\n      newLine[i] = currentLine[i];\n    }\n\n    for (; i < bytesPerLine; i++) {\n      newLine[i] = currentLine[i] + (newLine[i - bytesPerPixel] >> 1) & 0xff;\n    }\n  } else {\n    for (; i < bytesPerPixel; i++) {\n      newLine[i] = currentLine[i] + (prevLine[i] >> 1) & 0xff;\n    }\n\n    for (; i < bytesPerLine; i++) {\n      newLine[i] = currentLine[i] + (newLine[i - bytesPerPixel] + prevLine[i] >> 1) & 0xff;\n    }\n  }\n}\n\nfunction unfilterPaeth(currentLine, newLine, prevLine, bytesPerLine, bytesPerPixel) {\n  let i = 0;\n\n  if (prevLine.length === 0) {\n    for (; i < bytesPerPixel; i++) {\n      newLine[i] = currentLine[i];\n    }\n\n    for (; i < bytesPerLine; i++) {\n      newLine[i] = currentLine[i] + newLine[i - bytesPerPixel] & 0xff;\n    }\n  } else {\n    for (; i < bytesPerPixel; i++) {\n      newLine[i] = currentLine[i] + prevLine[i] & 0xff;\n    }\n\n    for (; i < bytesPerLine; i++) {\n      newLine[i] = currentLine[i] + paethPredictor(newLine[i - bytesPerPixel], prevLine[i], prevLine[i - bytesPerPixel]) & 0xff;\n    }\n  }\n}\n\nfunction paethPredictor(a, b, c) {\n  const p = a + b - c;\n  const pa = Math.abs(p - a);\n  const pb = Math.abs(p - b);\n  const pc = Math.abs(p - c);\n  if (pa <= pb && pa <= pc) return a;else if (pb <= pc) return b;else return c;\n}\n\nfunction swap16(val) {\n  return (val & 0xff) << 8 | val >> 8 & 0xff;\n}\n\nfunction checkBitDepth(value) {\n  if (value !== 1 && value !== 2 && value !== 4 && value !== 8 && value !== 16) {\n    throw new Error(`invalid bit depth: ${value}`);\n  }\n\n  return value;\n}","map":{"version":3,"sources":["../src/PNGDecoder.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { IOBuffer } from 'iobuffer';\r\nimport { Inflate as Inflator } from 'pako';\r\nimport { pngSignature, crc } from './common';\r\nimport { ColorType, CompressionMethod, FilterMethod, InterlaceMethod, } from './internalTypes';\r\nconst empty = new Uint8Array(0);\r\nconst NULL = '\\0';\r\nconst uint16 = new Uint16Array([0x00ff]);\r\nconst uint8 = new Uint8Array(uint16.buffer);\r\nconst osIsLittleEndian = uint8[0] === 0xff;\r\nexport default class PNGDecoder extends IOBuffer {\r\n    constructor(data, options = {}) {\r\n        super(data);\r\n        const { checkCrc = false } = options;\r\n        this._checkCrc = checkCrc;\r\n        this._inflator = new Inflator();\r\n        this._png = {\r\n            width: -1,\r\n            height: -1,\r\n            channels: -1,\r\n            data: new Uint8Array(0),\r\n            depth: 1,\r\n            text: {},\r\n        };\r\n        this._end = false;\r\n        this._hasPalette = false;\r\n        this._palette = [];\r\n        this._compressionMethod = CompressionMethod.UNKNOWN;\r\n        this._filterMethod = FilterMethod.UNKNOWN;\r\n        this._interlaceMethod = InterlaceMethod.UNKNOWN;\r\n        this._colorType = -1;\r\n        // PNG is always big endian\r\n        // https://www.w3.org/TR/PNG/#7Integers-and-byte-order\r\n        this.setBigEndian();\r\n    }\r\n    decode() {\r\n        this.decodeSignature();\r\n        while (!this._end) {\r\n            this.decodeChunk();\r\n        }\r\n        this.decodeImage();\r\n        return this._png;\r\n    }\r\n    // https://www.w3.org/TR/PNG/#5PNG-file-signature\r\n    decodeSignature() {\r\n        for (let i = 0; i < pngSignature.length; i++) {\r\n            if (this.readUint8() !== pngSignature[i]) {\r\n                throw new Error(`wrong PNG signature. Byte at ${i} should be ${pngSignature[i]}.`);\r\n            }\r\n        }\r\n    }\r\n    // https://www.w3.org/TR/PNG/#5Chunk-layout\r\n    decodeChunk() {\r\n        const length = this.readUint32();\r\n        const type = this.readChars(4);\r\n        const offset = this.offset;\r\n        switch (type) {\r\n            // 11.2 Critical chunks\r\n            case 'IHDR': // 11.2.2 IHDR Image header\r\n                this.decodeIHDR();\r\n                break;\r\n            case 'PLTE': // 11.2.3 PLTE Palette\r\n                this.decodePLTE(length);\r\n                break;\r\n            case 'IDAT': // 11.2.4 IDAT Image data\r\n                this.decodeIDAT(length);\r\n                break;\r\n            case 'IEND': // 11.2.5 IEND Image trailer\r\n                this._end = true;\r\n                break;\r\n            // 11.3 Ancillary chunks\r\n            case 'tRNS': // 11.3.2.1 tRNS Transparency\r\n                this.decodetRNS(length);\r\n                break;\r\n            case 'tEXt': // 11.3.4.3 tEXt Textual data\r\n                this.decodetEXt(length);\r\n                break;\r\n            case 'pHYs': // 11.3.5.3 pHYs Physical pixel dimensions\r\n                this.decodepHYs();\r\n                break;\r\n            default:\r\n                this.skip(length);\r\n                break;\r\n        }\r\n        if (this.offset - offset !== length) {\r\n            throw new Error(`Length mismatch while decoding chunk ${type}`);\r\n        }\r\n        if (this._checkCrc) {\r\n            const expectedCrc = this.readUint32();\r\n            const crcLength = length + 4; // includes type\r\n            const actualCrc = crc(new Uint8Array(this.buffer, this.byteOffset + this.offset - crcLength - 4, crcLength), crcLength); // \"- 4\" because we already advanced by reading the CRC\r\n            if (actualCrc !== expectedCrc) {\r\n                throw new Error(`CRC mismatch for chunk ${type}. Expected ${expectedCrc}, found ${actualCrc}`);\r\n            }\r\n        }\r\n        else {\r\n            this.skip(4);\r\n        }\r\n    }\r\n    // https://www.w3.org/TR/PNG/#11IHDR\r\n    decodeIHDR() {\r\n        const image = this._png;\r\n        image.width = this.readUint32();\r\n        image.height = this.readUint32();\r\n        image.depth = checkBitDepth(this.readUint8());\r\n        const colorType = this.readUint8();\r\n        this._colorType = colorType;\r\n        let channels;\r\n        switch (colorType) {\r\n            case ColorType.GREYSCALE:\r\n                channels = 1;\r\n                break;\r\n            case ColorType.TRUECOLOUR:\r\n                channels = 3;\r\n                break;\r\n            case ColorType.INDEXED_COLOUR:\r\n                channels = 1;\r\n                break;\r\n            case ColorType.GREYSCALE_ALPHA:\r\n                channels = 2;\r\n                break;\r\n            case ColorType.TRUECOLOUR_ALPHA:\r\n                channels = 4;\r\n                break;\r\n            default:\r\n                throw new Error(`Unknown color type: ${colorType}`);\r\n        }\r\n        this._png.channels = channels;\r\n        this._compressionMethod = this.readUint8();\r\n        if (this._compressionMethod !== CompressionMethod.DEFLATE) {\r\n            throw new Error(`Unsupported compression method: ${this._compressionMethod}`);\r\n        }\r\n        this._filterMethod = this.readUint8();\r\n        this._interlaceMethod = this.readUint8();\r\n    }\r\n    // https://www.w3.org/TR/PNG/#11PLTE\r\n    decodePLTE(length) {\r\n        if (length % 3 !== 0) {\r\n            throw new RangeError(`PLTE field length must be a multiple of 3. Got ${length}`);\r\n        }\r\n        const l = length / 3;\r\n        this._hasPalette = true;\r\n        const palette = [];\r\n        this._palette = palette;\r\n        for (let i = 0; i < l; i++) {\r\n            palette.push([this.readUint8(), this.readUint8(), this.readUint8()]);\r\n        }\r\n    }\r\n    // https://www.w3.org/TR/PNG/#11IDAT\r\n    decodeIDAT(length) {\r\n        this._inflator.push(new Uint8Array(this.buffer, this.offset + this.byteOffset, length), false);\r\n        this.skip(length);\r\n    }\r\n    // https://www.w3.org/TR/PNG/#11tRNS\r\n    decodetRNS(length) {\r\n        // TODO: support other color types.\r\n        if (this._colorType === 3) {\r\n            if (length > this._palette.length) {\r\n                throw new Error(`tRNS chunk contains more alpha values than there are palette colors (${length} vs ${this._palette.length})`);\r\n            }\r\n            let i = 0;\r\n            for (; i < length; i++) {\r\n                const alpha = this.readByte();\r\n                this._palette[i].push(alpha);\r\n            }\r\n            for (; i < this._palette.length; i++) {\r\n                this._palette[i].push(255);\r\n            }\r\n        }\r\n    }\r\n    // https://www.w3.org/TR/PNG/#11tEXt\r\n    decodetEXt(length) {\r\n        let keyword = '';\r\n        let char;\r\n        while ((char = this.readChar()) !== NULL) {\r\n            keyword += char;\r\n        }\r\n        this._png.text[keyword] = this.readChars(length - keyword.length - 1);\r\n    }\r\n    // https://www.w3.org/TR/PNG/#11pHYs\r\n    decodepHYs() {\r\n        const ppuX = this.readUint32();\r\n        const ppuY = this.readUint32();\r\n        const unitSpecifier = this.readByte();\r\n        this._png.resolution = { x: ppuX, y: ppuY, unit: unitSpecifier };\r\n    }\r\n    decodeImage() {\r\n        this._inflator.push(empty, true);\r\n        if (this._inflator.err) {\r\n            throw new Error(`Error while decompressing the data: ${this._inflator.err}`);\r\n        }\r\n        const data = this._inflator.result;\r\n        if (this._filterMethod !== FilterMethod.ADAPTIVE) {\r\n            throw new Error(`Filter method ${this._filterMethod} not supported`);\r\n        }\r\n        if (this._interlaceMethod === InterlaceMethod.NO_INTERLACE) {\r\n            this.decodeInterlaceNull(data);\r\n        }\r\n        else {\r\n            throw new Error(`Interlace method ${this._interlaceMethod} not supported`);\r\n        }\r\n    }\r\n    decodeInterlaceNull(data) {\r\n        const height = this._png.height;\r\n        const bytesPerPixel = (this._png.channels * this._png.depth) / 8;\r\n        const bytesPerLine = this._png.width * bytesPerPixel;\r\n        const newData = new Uint8Array(this._png.height * bytesPerLine);\r\n        let prevLine = empty;\r\n        let offset = 0;\r\n        let currentLine;\r\n        let newLine;\r\n        for (let i = 0; i < height; i++) {\r\n            currentLine = data.subarray(offset + 1, offset + 1 + bytesPerLine);\r\n            newLine = newData.subarray(i * bytesPerLine, (i + 1) * bytesPerLine);\r\n            switch (data[offset]) {\r\n                case 0:\r\n                    unfilterNone(currentLine, newLine, bytesPerLine);\r\n                    break;\r\n                case 1:\r\n                    unfilterSub(currentLine, newLine, bytesPerLine, bytesPerPixel);\r\n                    break;\r\n                case 2:\r\n                    unfilterUp(currentLine, newLine, prevLine, bytesPerLine);\r\n                    break;\r\n                case 3:\r\n                    unfilterAverage(currentLine, newLine, prevLine, bytesPerLine, bytesPerPixel);\r\n                    break;\r\n                case 4:\r\n                    unfilterPaeth(currentLine, newLine, prevLine, bytesPerLine, bytesPerPixel);\r\n                    break;\r\n                default:\r\n                    throw new Error(`Unsupported filter: ${data[offset]}`);\r\n            }\r\n            prevLine = newLine;\r\n            offset += bytesPerLine + 1;\r\n        }\r\n        if (this._hasPalette) {\r\n            this._png.palette = this._palette;\r\n        }\r\n        if (this._png.depth === 16) {\r\n            const uint16Data = new Uint16Array(newData.buffer);\r\n            if (osIsLittleEndian) {\r\n                for (let k = 0; k < uint16Data.length; k++) {\r\n                    // PNG is always big endian. Swap the bytes.\r\n                    uint16Data[k] = swap16(uint16Data[k]);\r\n                }\r\n            }\r\n            this._png.data = uint16Data;\r\n        }\r\n        else {\r\n            this._png.data = newData;\r\n        }\r\n    }\r\n}\r\nfunction unfilterNone(currentLine, newLine, bytesPerLine) {\r\n    for (let i = 0; i < bytesPerLine; i++) {\r\n        newLine[i] = currentLine[i];\r\n    }\r\n}\r\nfunction unfilterSub(currentLine, newLine, bytesPerLine, bytesPerPixel) {\r\n    let i = 0;\r\n    for (; i < bytesPerPixel; i++) {\r\n        // just copy first bytes\r\n        newLine[i] = currentLine[i];\r\n    }\r\n    for (; i < bytesPerLine; i++) {\r\n        newLine[i] = (currentLine[i] + newLine[i - bytesPerPixel]) & 0xff;\r\n    }\r\n}\r\nfunction unfilterUp(currentLine, newLine, prevLine, bytesPerLine) {\r\n    let i = 0;\r\n    if (prevLine.length === 0) {\r\n        // just copy bytes for first line\r\n        for (; i < bytesPerLine; i++) {\r\n            newLine[i] = currentLine[i];\r\n        }\r\n    }\r\n    else {\r\n        for (; i < bytesPerLine; i++) {\r\n            newLine[i] = (currentLine[i] + prevLine[i]) & 0xff;\r\n        }\r\n    }\r\n}\r\nfunction unfilterAverage(currentLine, newLine, prevLine, bytesPerLine, bytesPerPixel) {\r\n    let i = 0;\r\n    if (prevLine.length === 0) {\r\n        for (; i < bytesPerPixel; i++) {\r\n            newLine[i] = currentLine[i];\r\n        }\r\n        for (; i < bytesPerLine; i++) {\r\n            newLine[i] = (currentLine[i] + (newLine[i - bytesPerPixel] >> 1)) & 0xff;\r\n        }\r\n    }\r\n    else {\r\n        for (; i < bytesPerPixel; i++) {\r\n            newLine[i] = (currentLine[i] + (prevLine[i] >> 1)) & 0xff;\r\n        }\r\n        for (; i < bytesPerLine; i++) {\r\n            newLine[i] =\r\n                (currentLine[i] + ((newLine[i - bytesPerPixel] + prevLine[i]) >> 1)) &\r\n                    0xff;\r\n        }\r\n    }\r\n}\r\nfunction unfilterPaeth(currentLine, newLine, prevLine, bytesPerLine, bytesPerPixel) {\r\n    let i = 0;\r\n    if (prevLine.length === 0) {\r\n        for (; i < bytesPerPixel; i++) {\r\n            newLine[i] = currentLine[i];\r\n        }\r\n        for (; i < bytesPerLine; i++) {\r\n            newLine[i] = (currentLine[i] + newLine[i - bytesPerPixel]) & 0xff;\r\n        }\r\n    }\r\n    else {\r\n        for (; i < bytesPerPixel; i++) {\r\n            newLine[i] = (currentLine[i] + prevLine[i]) & 0xff;\r\n        }\r\n        for (; i < bytesPerLine; i++) {\r\n            newLine[i] =\r\n                (currentLine[i] +\r\n                    paethPredictor(newLine[i - bytesPerPixel], prevLine[i], prevLine[i - bytesPerPixel])) &\r\n                    0xff;\r\n        }\r\n    }\r\n}\r\nfunction paethPredictor(a, b, c) {\r\n    const p = a + b - c;\r\n    const pa = Math.abs(p - a);\r\n    const pb = Math.abs(p - b);\r\n    const pc = Math.abs(p - c);\r\n    if (pa <= pb && pa <= pc)\r\n        return a;\r\n    else if (pb <= pc)\r\n        return b;\r\n    else\r\n        return c;\r\n}\r\nfunction swap16(val) {\r\n    return ((val & 0xff) << 8) | ((val >> 8) & 0xff);\r\n}\r\nfunction checkBitDepth(value) {\r\n    if (value !== 1 &&\r\n        value !== 2 &&\r\n        value !== 4 &&\r\n        value !== 8 &&\r\n        value !== 16) {\r\n        throw new Error(`invalid bit depth: ${value}`);\r\n    }\r\n    return value;\r\n}\r\n//# sourceMappingURL=PNGDecoder.js.map"]},"metadata":{},"sourceType":"module"}