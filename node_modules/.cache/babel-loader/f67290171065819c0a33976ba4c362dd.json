{"ast":null,"code":"import Image from '../Image';\nimport { GREY } from '../model/model';\n/**\n * Create a new grey Image by combining the channels of the current image.\n * @memberof Image\n * @instance\n * @param {function} method\n * @param {object} [options]\n * @param {boolean} [options.mergeAlpha=false]\n * @param {boolean} [options.keepAlpha=false]\n * @return {Image}\n */\n\nexport default function combineChannels(method = defaultCombineMethod, options = {}) {\n  let {\n    mergeAlpha = false,\n    keepAlpha = false\n  } = options;\n  mergeAlpha &= this.alpha;\n  keepAlpha &= this.alpha;\n  this.checkProcessable('combineChannels', {\n    bitDepth: [8, 16]\n  });\n  let newImage = Image.createFrom(this, {\n    components: 1,\n    alpha: keepAlpha,\n    colorModel: GREY\n  });\n  let ptr = 0;\n\n  for (let i = 0; i < this.size; i++) {\n    // TODO quite slow because we create a new pixel each time\n    let value = method(this.getPixel(i));\n\n    if (mergeAlpha) {\n      newImage.data[ptr++] = value * this.data[i * this.channels + this.components] / this.maxValue;\n    } else {\n      newImage.data[ptr++] = value;\n\n      if (keepAlpha) {\n        newImage.data[ptr++] = this.data[i * this.channels + this.components];\n      }\n    }\n  }\n\n  return newImage;\n}\n\nfunction defaultCombineMethod(pixel) {\n  return (pixel[0] + pixel[1] + pixel[2]) / 3;\n}","map":{"version":3,"sources":["C:/Users/kuent/Documents/FinishDipshit/Creative/Ocean-Weather-Visualization/node_modules/image-js/src/image/utility/combineChannels.js"],"names":["Image","GREY","combineChannels","method","defaultCombineMethod","options","mergeAlpha","keepAlpha","alpha","checkProcessable","bitDepth","newImage","createFrom","components","colorModel","ptr","i","size","value","getPixel","data","channels","maxValue","pixel"],"mappings":"AAAA,OAAOA,KAAP,MAAkB,UAAlB;AACA,SAASC,IAAT,QAAqB,gBAArB;AAEA;;;;;;;;;;;AAUA,eAAe,SAASC,eAAT,CACbC,MAAM,GAAGC,oBADI,EAEbC,OAAO,GAAG,EAFG,EAGb;AACA,MAAI;AAAEC,IAAAA,UAAU,GAAG,KAAf;AAAsBC,IAAAA,SAAS,GAAG;AAAlC,MAA4CF,OAAhD;AAEAC,EAAAA,UAAU,IAAI,KAAKE,KAAnB;AACAD,EAAAA,SAAS,IAAI,KAAKC,KAAlB;AAEA,OAAKC,gBAAL,CAAsB,iBAAtB,EAAyC;AACvCC,IAAAA,QAAQ,EAAE,CAAC,CAAD,EAAI,EAAJ;AAD6B,GAAzC;AAIA,MAAIC,QAAQ,GAAGX,KAAK,CAACY,UAAN,CAAiB,IAAjB,EAAuB;AACpCC,IAAAA,UAAU,EAAE,CADwB;AAEpCL,IAAAA,KAAK,EAAED,SAF6B;AAGpCO,IAAAA,UAAU,EAAEb;AAHwB,GAAvB,CAAf;AAMA,MAAIc,GAAG,GAAG,CAAV;;AACA,OAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG,KAAKC,IAAzB,EAA+BD,CAAC,EAAhC,EAAoC;AAClC;AACA,QAAIE,KAAK,GAAGf,MAAM,CAAC,KAAKgB,QAAL,CAAcH,CAAd,CAAD,CAAlB;;AACA,QAAIV,UAAJ,EAAgB;AACdK,MAAAA,QAAQ,CAACS,IAAT,CAAcL,GAAG,EAAjB,IACGG,KAAK,GAAG,KAAKE,IAAL,CAAUJ,CAAC,GAAG,KAAKK,QAAT,GAAoB,KAAKR,UAAnC,CAAT,GACA,KAAKS,QAFP;AAGD,KAJD,MAIO;AACLX,MAAAA,QAAQ,CAACS,IAAT,CAAcL,GAAG,EAAjB,IAAuBG,KAAvB;;AACA,UAAIX,SAAJ,EAAe;AACbI,QAAAA,QAAQ,CAACS,IAAT,CAAcL,GAAG,EAAjB,IAAuB,KAAKK,IAAL,CAAUJ,CAAC,GAAG,KAAKK,QAAT,GAAoB,KAAKR,UAAnC,CAAvB;AACD;AACF;AACF;;AAED,SAAOF,QAAP;AACD;;AAED,SAASP,oBAAT,CAA8BmB,KAA9B,EAAqC;AACnC,SAAO,CAACA,KAAK,CAAC,CAAD,CAAL,GAAWA,KAAK,CAAC,CAAD,CAAhB,GAAsBA,KAAK,CAAC,CAAD,CAA5B,IAAmC,CAA1C;AACD","sourcesContent":["import Image from '../Image';\nimport { GREY } from '../model/model';\n\n/**\n * Create a new grey Image by combining the channels of the current image.\n * @memberof Image\n * @instance\n * @param {function} method\n * @param {object} [options]\n * @param {boolean} [options.mergeAlpha=false]\n * @param {boolean} [options.keepAlpha=false]\n * @return {Image}\n */\nexport default function combineChannels(\n  method = defaultCombineMethod,\n  options = {},\n) {\n  let { mergeAlpha = false, keepAlpha = false } = options;\n\n  mergeAlpha &= this.alpha;\n  keepAlpha &= this.alpha;\n\n  this.checkProcessable('combineChannels', {\n    bitDepth: [8, 16],\n  });\n\n  let newImage = Image.createFrom(this, {\n    components: 1,\n    alpha: keepAlpha,\n    colorModel: GREY,\n  });\n\n  let ptr = 0;\n  for (let i = 0; i < this.size; i++) {\n    // TODO quite slow because we create a new pixel each time\n    let value = method(this.getPixel(i));\n    if (mergeAlpha) {\n      newImage.data[ptr++] =\n        (value * this.data[i * this.channels + this.components]) /\n        this.maxValue;\n    } else {\n      newImage.data[ptr++] = value;\n      if (keepAlpha) {\n        newImage.data[ptr++] = this.data[i * this.channels + this.components];\n      }\n    }\n  }\n\n  return newImage;\n}\n\nfunction defaultCombineMethod(pixel) {\n  return (pixel[0] + pixel[1] + pixel[2]) / 3;\n}\n"]},"metadata":{},"sourceType":"module"}