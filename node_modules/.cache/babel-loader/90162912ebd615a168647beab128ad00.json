{"ast":null,"code":"import { black, white } from \"color-name\";\nexport function drawAllLegends(p) {\n  let fillColor = p.color(255, 255, 255);\n  fillColor.setAlpha(200);\n  p.noStroke();\n  p.fill(fillColor);\n  p.rect(100, 100, p.width - 200, p.height - 200);\n  p.noFill();\n  p.stroke(black);\n  p.strokeWeight(50);\n  p.rect(100, 100, p.width - 200, p.height - 200);\n  p.fill(0);\n  p.textSize(36);\n  p.strokeWeight(1);\n  p.textAlign(p.CENTER);\n  p.text(\"Legend\", p.width / 2, 200);\n  p.textAlign(p.CENTER);\n  p.textSize(24);\n  p.text(\"Welcome to our visualization! Provided here are explanations of what data different attributes of the landscape correspond to.\", p.width / 2, 250);\n  p.textAlign(p.LEFT);\n  p.textSize(24);\n  p.text(\"Sky Color\\nThe color of the sky is based off carbon dioxide data, darkening as CO2 levels in the atmosphere increase.\", 200, 300);\n  p.text(\"Sun Size\\nThe sun increases and decreases in size based on global temperature averages - larger means hotter, smaller means cooler.\", 200, 375);\n  p.text(\"Smog\\nThe grey smog clouds increase and decrease in density, size, and number based off of nitrous oxide levels in the atmosphere.\", 200, 450);\n  p.text(\"Ocean Level\\n(Currerntly not based on an API. Will be soon.)\", 200, 525);\n  p.text(\"Microplastics\\nThe small white dots drifting downward through the ocean represent microplastics, tiny plastic particulates polluting the oceans.\\nThey\" + \" increase and decrease in number based on microplastic levels in the oceans.\", 200, 600);\n  p.text(\"Macroplastics\\nThe large brown and grey shapes on the ocean surface represent macroplastics, larger plastic objects polluting the oceans.\\nThey\" + \" increase and decrease in number based on macroplastic levels in the oceans.\", 200, 700);\n  p.text(\"Bubbles\\nThe bubbles rising up through the ocean represent methane entering the atmosphere, and increase and decrease in number accordingly.\", 200, 800);\n  p.noStroke();\n}\nexport function drawLegend(p, text, value) {\n  const maxWidth = window.screen.availWidth - (window.outerWidth - window.innerWidth);\n  const width_ratio = p.windowWidth / maxWidth;\n  const strokeWeight = 5; // font boldness\n\n  const bottomPadding = 3;\n  const maxChars = 66;\n  const numTextWraps = 1 + Math.ceil(text.length / maxChars); // add 1 for value representation\n\n  const textSize = 20 * width_ratio; // scales with window width\n\n  const textBoxWidth = 625 * width_ratio; // scales with window width\n\n  const textBoxHeight = strokeWeight * numTextWraps + textSize * numTextWraps + bottomPadding; // scales with window height\n\n  const leftMargin = p.mouseX + textBoxWidth + 20 > p.windowWidth ? -textBoxWidth - 20 : 20; // check if text box would go beyond window width\n\n  const fillColor = p.color(255, 255, 255);\n  const wrappedText = text.replace( // wrap text around 66 chars maximum\n  /(?![^\\n]{1,66}$)([^\\n]{1,66})\\s/g, '$1\\n');\n  fillColor.setAlpha(200);\n  p.noStroke();\n  p.fill(fillColor);\n  p.rect(leftMargin + p.mouseX, p.mouseY, textBoxWidth, textBoxHeight);\n  p.noFill();\n  p.stroke(black);\n  p.strokeWeight(strokeWeight);\n  p.rect(leftMargin + p.mouseX, p.mouseY, textBoxWidth, textBoxHeight);\n  p.fill(0);\n  p.strokeWeight(0.5);\n  p.textAlign(p.LEFT);\n  p.textSize(textSize);\n\n  if (value) {\n    p.text(wrappedText, leftMargin + strokeWeight + p.mouseX, p.mouseY + textSize);\n    p.text(value, leftMargin + strokeWeight + p.mouseX, p.mouseY + (bottomPadding + textSize) * numTextWraps);\n  }\n\n  p.noStroke();\n}","map":{"version":3,"sources":["C:/Users/kuent/Documents/FinishDipshit/Creative/Ocean-Weather-Visualization/src/sketches/legend.js"],"names":["black","white","drawAllLegends","p","fillColor","color","setAlpha","noStroke","fill","rect","width","height","noFill","stroke","strokeWeight","textSize","textAlign","CENTER","text","LEFT","drawLegend","value","maxWidth","window","screen","availWidth","outerWidth","innerWidth","width_ratio","windowWidth","bottomPadding","maxChars","numTextWraps","Math","ceil","length","textBoxWidth","textBoxHeight","leftMargin","mouseX","wrappedText","replace","mouseY"],"mappings":"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","sourcesContent":["import { black, white } from \"color-name\";\r\n\r\nexport function drawAllLegends(p) {\r\n    let fillColor = p.color(255, 255, 255);\r\n    fillColor.setAlpha(200);\r\n    p.noStroke();\r\n    p.fill(fillColor);\r\n    p.rect(100, 100, p.width - 200, p.height - 200);\r\n\r\n    p.noFill();\r\n    p.stroke(black);\r\n    p.strokeWeight(50);\r\n    p.rect(100, 100, p.width - 200, p.height - 200);\r\n\r\n    p.fill(0);\r\n    p.textSize(36);\r\n    p.strokeWeight(1);\r\n    p.textAlign(p.CENTER);\r\n    p.text(\"Legend\", p.width/2, 200);\r\n\r\n    p.textAlign(p.CENTER);\r\n    p.textSize(24);\r\n    p.text(\"Welcome to our visualization! Provided here are explanations of what data different attributes of the landscape correspond to.\", p.width/2, 250);\r\n\r\n    p.textAlign(p.LEFT);\r\n    p.textSize(24);\r\n    p.text(\"Sky Color\\nThe color of the sky is based off carbon dioxide data, darkening as CO2 levels in the atmosphere increase.\", 200, 300);\r\n    p.text(\"Sun Size\\nThe sun increases and decreases in size based on global temperature averages - larger means hotter, smaller means cooler.\", 200, 375);\r\n    p.text(\"Smog\\nThe grey smog clouds increase and decrease in density, size, and number based off of nitrous oxide levels in the atmosphere.\", 200, 450);\r\n    p.text(\"Ocean Level\\n(Currerntly not based on an API. Will be soon.)\", 200, 525);\r\n    p.text(\"Microplastics\\nThe small white dots drifting downward through the ocean represent microplastics, tiny plastic particulates polluting the oceans.\\nThey\"+\r\n    \" increase and decrease in number based on microplastic levels in the oceans.\", 200, 600);\r\n    p.text(\"Macroplastics\\nThe large brown and grey shapes on the ocean surface represent macroplastics, larger plastic objects polluting the oceans.\\nThey\"\r\n    +\" increase and decrease in number based on macroplastic levels in the oceans.\", 200, 700);\r\n    p.text(\"Bubbles\\nThe bubbles rising up through the ocean represent methane entering the atmosphere, and increase and decrease in number accordingly.\", 200, 800);\r\n\r\n    p.noStroke();\r\n}\r\n\r\nexport function drawLegend(p, text, value) {\r\n    const maxWidth = window.screen.availWidth - (window.outerWidth - window.innerWidth);\r\n    const width_ratio = p.windowWidth / maxWidth;\r\n    \r\n    const strokeWeight = 5; // font boldness\r\n    const bottomPadding = 3;\r\n    const maxChars = 66;\r\n    const numTextWraps = 1 + Math.ceil(text.length / maxChars); // add 1 for value representation\r\n    \r\n    const textSize = 20 * width_ratio; // scales with window width\r\n    const textBoxWidth = 625 * width_ratio; // scales with window width\r\n    const textBoxHeight = strokeWeight * numTextWraps + textSize * numTextWraps + bottomPadding; // scales with window height\r\n    \r\n    const leftMargin = p.mouseX + textBoxWidth + 20 > p.windowWidth ? -textBoxWidth - 20 : 20; // check if text box would go beyond window width\r\n\r\n    const fillColor = p.color(255, 255, 255);\r\n\r\n    const wrappedText = text.replace( // wrap text around 66 chars maximum\r\n        /(?![^\\n]{1,66}$)([^\\n]{1,66})\\s/g, '$1\\n'\r\n    );\r\n    \r\n    fillColor.setAlpha(200);\r\n    p.noStroke();\r\n    p.fill(fillColor);\r\n    p.rect(leftMargin + p.mouseX, p.mouseY, textBoxWidth, textBoxHeight);\r\n\r\n    p.noFill();\r\n    p.stroke(black);\r\n    p.strokeWeight(strokeWeight);\r\n    p.rect(leftMargin + p.mouseX, p.mouseY, textBoxWidth, textBoxHeight);\r\n\r\n    p.fill(0);\r\n    p.strokeWeight(0.5);\r\n    p.textAlign(p.LEFT);\r\n    \r\n    p.textSize(textSize);\r\n\r\n    if (value) {\r\n        p.text(wrappedText, leftMargin + strokeWeight + p.mouseX, p.mouseY + textSize);\r\n        p.text(value, leftMargin + strokeWeight + p.mouseX, p.mouseY + (bottomPadding + textSize) * numTextWraps)\r\n    }\r\n\r\n    p.noStroke();\r\n}"]},"metadata":{},"sourceType":"module"}