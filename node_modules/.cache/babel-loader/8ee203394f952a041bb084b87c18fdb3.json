{"ast":null,"code":"import { rotate, difference, normalize } from '../../util/points';\nimport convexHullFunction from '../compute/monotoneChainConvexHull';\n/**\n * Computes the Feret diameters\n * https://www.sympatec.com/en/particle-measurement/glossary/particle-shape/#\n * http://portal.s2nano.org:8282/files/TEM_protocol_NANoREG.pdf\n * @memberof Image\n * @instance\n * @param {object} [options]\n * @param {Array<Array<number>>} [options.originalPoints]\n * @return {object} Object with {min, max, minLine: {Array<Array<number>>}, maxLine: {Array<Array<number>>}}\n */\n\nexport default function feretDiameters(options = {}) {\n  const {\n    originalPoints = convexHullFunction.call(this)\n  } = options;\n\n  if (originalPoints.length === 0) {\n    return {\n      min: 0,\n      max: 0,\n      minLine: [],\n      maxLine: [],\n      aspectRatio: 1\n    };\n  }\n\n  if (originalPoints.length === 1) {\n    return {\n      min: 1,\n      max: 1,\n      minLine: [originalPoints[0], originalPoints[0]],\n      maxLine: [originalPoints[0], originalPoints[0]],\n      aspectRatio: 1\n    };\n  }\n\n  const temporaryPoints = new Array(originalPoints.length); // CALCULATE MIN VALUE\n\n  let minWidth = +Infinity;\n  let minWidthAngle = 0;\n  let minLine = [];\n\n  for (let i = 0; i < originalPoints.length; i++) {\n    let angle = getAngle(originalPoints[i], originalPoints[(i + 1) % originalPoints.length]); // we rotate so that it is parallel to X axis\n\n    rotate(-angle, originalPoints, temporaryPoints);\n    let currentWidth = 0;\n    let currentMinLine = [];\n\n    for (let j = 0; j < originalPoints.length; j++) {\n      let absWidth = Math.abs(temporaryPoints[i][1] - temporaryPoints[j][1]);\n\n      if (absWidth > currentWidth) {\n        currentWidth = absWidth;\n        currentMinLine = [];\n        currentMinLine.push([temporaryPoints[j][0], temporaryPoints[i][1]], [temporaryPoints[j][0], temporaryPoints[j][1]]);\n      }\n    }\n\n    if (currentWidth < minWidth) {\n      minWidth = currentWidth;\n      minWidthAngle = angle;\n      minLine = currentMinLine;\n    }\n  }\n\n  rotate(minWidthAngle, minLine, minLine); // CALCULATE MAX VALUE\n\n  let maxWidth = 0;\n  let maxLine = [];\n  let maxSquaredWidth = 0;\n\n  for (let i = 0; i < originalPoints.length - 1; i++) {\n    for (let j = i + 1; j < originalPoints.length; j++) {\n      let currentSquaredWidth = (originalPoints[i][0] - originalPoints[j][0]) ** 2 + (originalPoints[i][1] - originalPoints[j][1]) ** 2;\n\n      if (currentSquaredWidth > maxSquaredWidth) {\n        maxSquaredWidth = currentSquaredWidth;\n        maxWidth = Math.sqrt(currentSquaredWidth);\n        maxLine = [originalPoints[i], originalPoints[j]];\n      }\n    }\n  }\n\n  return {\n    min: minWidth,\n    minLine,\n    max: maxWidth,\n    maxLine,\n    aspectRatio: minWidth / maxWidth\n  };\n} // the angle that allows to make the line going through p1 and p2 horizontal\n// this is an optimized version because it assume one vector is horizontal\n\nfunction getAngle(p1, p2) {\n  let diff = difference(p2, p1);\n  let vector = normalize(diff);\n  let angle = Math.acos(vector[0]);\n  if (vector[1] < 0) return -angle;\n  return angle;\n}","map":{"version":3,"sources":["C:/Users/kuent/Documents/FinishDipshit/Creative/Ocean-Weather-Visualization/node_modules/image-js/src/image/roi/feretDiameters.js"],"names":["rotate","difference","normalize","convexHullFunction","feretDiameters","options","originalPoints","call","length","min","max","minLine","maxLine","aspectRatio","temporaryPoints","Array","minWidth","Infinity","minWidthAngle","i","angle","getAngle","currentWidth","currentMinLine","j","absWidth","Math","abs","push","maxWidth","maxSquaredWidth","currentSquaredWidth","sqrt","p1","p2","diff","vector","acos"],"mappings":"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","sourcesContent":["import { rotate, difference, normalize } from '../../util/points';\nimport convexHullFunction from '../compute/monotoneChainConvexHull';\n\n/**\n * Computes the Feret diameters\n * https://www.sympatec.com/en/particle-measurement/glossary/particle-shape/#\n * http://portal.s2nano.org:8282/files/TEM_protocol_NANoREG.pdf\n * @memberof Image\n * @instance\n * @param {object} [options]\n * @param {Array<Array<number>>} [options.originalPoints]\n * @return {object} Object with {min, max, minLine: {Array<Array<number>>}, maxLine: {Array<Array<number>>}}\n */\nexport default function feretDiameters(options = {}) {\n  const { originalPoints = convexHullFunction.call(this) } = options;\n  if (originalPoints.length === 0) {\n    return { min: 0, max: 0, minLine: [], maxLine: [], aspectRatio: 1 };\n  }\n\n  if (originalPoints.length === 1) {\n    return {\n      min: 1,\n      max: 1,\n      minLine: [originalPoints[0], originalPoints[0]],\n      maxLine: [originalPoints[0], originalPoints[0]],\n      aspectRatio: 1,\n    };\n  }\n\n  const temporaryPoints = new Array(originalPoints.length);\n\n  // CALCULATE MIN VALUE\n  let minWidth = +Infinity;\n  let minWidthAngle = 0;\n  let minLine = [];\n\n  for (let i = 0; i < originalPoints.length; i++) {\n    let angle = getAngle(\n      originalPoints[i],\n      originalPoints[(i + 1) % originalPoints.length],\n    );\n\n    // we rotate so that it is parallel to X axis\n    rotate(-angle, originalPoints, temporaryPoints);\n\n    let currentWidth = 0;\n    let currentMinLine = [];\n    for (let j = 0; j < originalPoints.length; j++) {\n      let absWidth = Math.abs(temporaryPoints[i][1] - temporaryPoints[j][1]);\n      if (absWidth > currentWidth) {\n        currentWidth = absWidth;\n        currentMinLine = [];\n        currentMinLine.push(\n          [temporaryPoints[j][0], temporaryPoints[i][1]],\n          [temporaryPoints[j][0], temporaryPoints[j][1]],\n        );\n      }\n    }\n    if (currentWidth < minWidth) {\n      minWidth = currentWidth;\n      minWidthAngle = angle;\n      minLine = currentMinLine;\n    }\n  }\n  rotate(minWidthAngle, minLine, minLine);\n\n  // CALCULATE MAX VALUE\n  let maxWidth = 0;\n  let maxLine = [];\n  let maxSquaredWidth = 0;\n  for (let i = 0; i < originalPoints.length - 1; i++) {\n    for (let j = i + 1; j < originalPoints.length; j++) {\n      let currentSquaredWidth =\n        (originalPoints[i][0] - originalPoints[j][0]) ** 2 +\n        (originalPoints[i][1] - originalPoints[j][1]) ** 2;\n      if (currentSquaredWidth > maxSquaredWidth) {\n        maxSquaredWidth = currentSquaredWidth;\n        maxWidth = Math.sqrt(currentSquaredWidth);\n        maxLine = [originalPoints[i], originalPoints[j]];\n      }\n    }\n  }\n\n  return {\n    min: minWidth,\n    minLine,\n    max: maxWidth,\n    maxLine,\n    aspectRatio: minWidth / maxWidth,\n  };\n}\n\n// the angle that allows to make the line going through p1 and p2 horizontal\n// this is an optimized version because it assume one vector is horizontal\nfunction getAngle(p1, p2) {\n  let diff = difference(p2, p1);\n  let vector = normalize(diff);\n  let angle = Math.acos(vector[0]);\n  if (vector[1] < 0) return -angle;\n  return angle;\n}\n"]},"metadata":{},"sourceType":"module"}