{"ast":null,"code":"import Image from '../Image';\n/**\n * Dilatation is one of two fundamental operations (with erosion) in morphological\n * image processing from which all other morphological operations are based (from Wikipedia).\n * Replaces each value with it's local maximum among the pixels with a kernel value of 1.\n * http://docs.opencv.org/2.4/doc/tutorials/imgproc/erosion_dilatation/erosion_dilatation.html\n * https://en.wikipedia.org/wiki/Dilation_(morphology)\n * @memberof Image\n * @instance\n * @param {object} [options]\n * @param {Array<Array<number>>} [options.kernel] - The kernel can only have ones and zeros. Default: [[1, 1, 1], [1, 1, 1], [1, 1, 1]]\n * @param {number} [options.iterations=1] - The number of successive erosions\n * @return {Image}\n */\n\nexport default function dilate(options = {}) {\n  let {\n    kernel = [[1, 1, 1], [1, 1, 1], [1, 1, 1]],\n    iterations = 1\n  } = options;\n  this.checkProcessable('dilate', {\n    bitDepth: [1, 8, 16],\n    components: 1,\n    alpha: 0\n  });\n\n  if (kernel.columns % 2 === 0 || kernel.rows % 2 === 0) {\n    throw new TypeError('dilate: The number of rows and columns of the kernel must be odd');\n  }\n\n  let onlyOnes = true;\n\n  outer: for (const row of kernel) {\n    for (const value of row) {\n      if (value !== 1) {\n        onlyOnes = false;\n        break outer;\n      }\n    }\n  }\n\n  let result = this;\n\n  for (let i = 0; i < iterations; i++) {\n    if (this.bitDepth === 1) {\n      if (onlyOnes) {\n        const newImage = result.clone();\n        result = dilateOnceBinaryOnlyOnes(result, newImage, kernel.length, kernel[0].length);\n      } else {\n        const newImage = Image.createFrom(result);\n        result = dilateOnceBinary(result, newImage, kernel);\n      }\n    } else if (onlyOnes) {\n      const newImage = Image.createFrom(result);\n      result = dilateOnceGreyOnlyOnes(result, newImage, kernel.length, kernel[0].length);\n    } else {\n      const newImage = Image.createFrom(result);\n      result = dilateOnceGrey(result, newImage, kernel);\n    }\n  }\n\n  return result;\n}\n\nfunction dilateOnceGrey(img, newImage, kernel) {\n  const kernelWidth = kernel.length;\n  const kernelHeight = kernel[0].length;\n  let radiusX = (kernelWidth - 1) / 2;\n  let radiusY = (kernelHeight - 1) / 2;\n\n  for (let y = 0; y < img.height; y++) {\n    for (let x = 0; x < img.width; x++) {\n      let max = 0;\n\n      for (let jj = 0; jj < kernelHeight; jj++) {\n        for (let ii = 0; ii < kernelWidth; ii++) {\n          if (kernel[ii][jj] !== 1) continue;\n          let i = ii - radiusX + x;\n          let j = jj - radiusY + y;\n          if (i < 0 || j < 0 || i >= img.width || j >= img.height) continue;\n          const value = img.getValueXY(i, j, 0);\n          if (value > max) max = value;\n        }\n      }\n\n      newImage.setValueXY(x, y, 0, max);\n    }\n  }\n\n  return newImage;\n}\n\nfunction dilateOnceGreyOnlyOnes(img, newImage, kernelWidth, kernelHeight) {\n  const radiusX = (kernelWidth - 1) / 2;\n  const radiusY = (kernelHeight - 1) / 2;\n  const maxList = [];\n\n  for (let x = 0; x < img.width; x++) {\n    maxList.push(0);\n  }\n\n  for (let y = 0; y < img.height; y++) {\n    for (let x = 0; x < img.width; x++) {\n      let max = 0;\n\n      for (let h = Math.max(0, y - radiusY); h < Math.min(img.height, y + radiusY + 1); h++) {\n        const value = img.getValueXY(x, h, 0);\n\n        if (value > max) {\n          max = value;\n        }\n      }\n\n      maxList[x] = max;\n    }\n\n    for (let x = 0; x < img.width; x++) {\n      let max = 0;\n\n      for (let i = Math.max(0, x - radiusX); i < Math.min(img.width, x + radiusX + 1); i++) {\n        if (maxList[i] > max) {\n          max = maxList[i];\n        }\n      }\n\n      newImage.setValueXY(x, y, 0, max);\n    }\n  }\n\n  return newImage;\n}\n\nfunction dilateOnceBinary(img, newImage, kernel) {\n  const kernelWidth = kernel.length;\n  const kernelHeight = kernel[0].length;\n  let radiusX = (kernelWidth - 1) / 2;\n  let radiusY = (kernelHeight - 1) / 2;\n\n  for (let y = 0; y < img.height; y++) {\n    for (let x = 0; x < img.width; x++) {\n      let max = 0;\n\n      intLoop: for (let jj = 0; jj < kernelHeight; jj++) {\n        for (let ii = 0; ii < kernelWidth; ii++) {\n          if (kernel[ii][jj] !== 1) continue;\n          let i = ii - radiusX + x;\n          let j = jj - radiusY + y;\n          if (j < 0 || i < 0 || i >= img.width || j >= img.height) continue;\n          const value = img.getBitXY(i, j);\n\n          if (value === 1) {\n            max = 1;\n            break intLoop;\n          }\n        }\n      }\n\n      if (max === 1) {\n        newImage.setBitXY(x, y);\n      }\n    }\n  }\n\n  return newImage;\n}\n\nfunction dilateOnceBinaryOnlyOnes(img, newImage, kernelWidth, kernelHeight) {\n  const radiusX = (kernelWidth - 1) / 2;\n  const radiusY = (kernelHeight - 1) / 2;\n  const maxList = [];\n\n  for (let x = 0; x < img.width; x++) {\n    maxList.push(1);\n  }\n\n  for (let y = 0; y < img.height; y++) {\n    for (let x = 0; x < img.width; x++) {\n      maxList[x] = 0;\n\n      for (let h = Math.max(0, y - radiusY); h < Math.min(img.height, y + radiusY + 1); h++) {\n        if (img.getBitXY(x, h) === 1) {\n          maxList[x] = 1;\n          break;\n        }\n      }\n    }\n\n    for (let x = 0; x < img.width; x++) {\n      if (newImage.getBitXY(x, y) === 1) continue;\n\n      for (let i = Math.max(0, x - radiusX); i < Math.min(img.width, x + radiusX + 1); i++) {\n        if (maxList[i] === 1) {\n          newImage.setBitXY(x, y);\n          break;\n        }\n      }\n    }\n  }\n\n  return newImage;\n}","map":{"version":3,"sources":["C:/Users/kuent/Documents/FinishDipshit/Creative/Ocean-Weather-Visualization/node_modules/image-js/src/image/morphology/dilate.js"],"names":["Image","dilate","options","kernel","iterations","checkProcessable","bitDepth","components","alpha","columns","rows","TypeError","onlyOnes","outer","row","value","result","i","newImage","clone","dilateOnceBinaryOnlyOnes","length","createFrom","dilateOnceBinary","dilateOnceGreyOnlyOnes","dilateOnceGrey","img","kernelWidth","kernelHeight","radiusX","radiusY","y","height","x","width","max","jj","ii","j","getValueXY","setValueXY","maxList","push","h","Math","min","intLoop","getBitXY","setBitXY"],"mappings":"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","sourcesContent":["import Image from '../Image';\n\n/**\n * Dilatation is one of two fundamental operations (with erosion) in morphological\n * image processing from which all other morphological operations are based (from Wikipedia).\n * Replaces each value with it's local maximum among the pixels with a kernel value of 1.\n * http://docs.opencv.org/2.4/doc/tutorials/imgproc/erosion_dilatation/erosion_dilatation.html\n * https://en.wikipedia.org/wiki/Dilation_(morphology)\n * @memberof Image\n * @instance\n * @param {object} [options]\n * @param {Array<Array<number>>} [options.kernel] - The kernel can only have ones and zeros. Default: [[1, 1, 1], [1, 1, 1], [1, 1, 1]]\n * @param {number} [options.iterations=1] - The number of successive erosions\n * @return {Image}\n */\nexport default function dilate(options = {}) {\n  let {\n    kernel = [\n      [1, 1, 1],\n      [1, 1, 1],\n      [1, 1, 1],\n    ],\n    iterations = 1,\n  } = options;\n\n  this.checkProcessable('dilate', {\n    bitDepth: [1, 8, 16],\n    components: 1,\n    alpha: 0,\n  });\n  if (kernel.columns % 2 === 0 || kernel.rows % 2 === 0) {\n    throw new TypeError(\n      'dilate: The number of rows and columns of the kernel must be odd',\n    );\n  }\n\n  let onlyOnes = true;\n  outer: for (const row of kernel) {\n    for (const value of row) {\n      if (value !== 1) {\n        onlyOnes = false;\n        break outer;\n      }\n    }\n  }\n\n  let result = this;\n  for (let i = 0; i < iterations; i++) {\n    if (this.bitDepth === 1) {\n      if (onlyOnes) {\n        const newImage = result.clone();\n        result = dilateOnceBinaryOnlyOnes(\n          result,\n          newImage,\n          kernel.length,\n          kernel[0].length,\n        );\n      } else {\n        const newImage = Image.createFrom(result);\n        result = dilateOnceBinary(result, newImage, kernel);\n      }\n    } else if (onlyOnes) {\n      const newImage = Image.createFrom(result);\n      result = dilateOnceGreyOnlyOnes(\n        result,\n        newImage,\n        kernel.length,\n        kernel[0].length,\n      );\n    } else {\n      const newImage = Image.createFrom(result);\n      result = dilateOnceGrey(result, newImage, kernel);\n    }\n  }\n  return result;\n}\n\nfunction dilateOnceGrey(img, newImage, kernel) {\n  const kernelWidth = kernel.length;\n  const kernelHeight = kernel[0].length;\n  let radiusX = (kernelWidth - 1) / 2;\n  let radiusY = (kernelHeight - 1) / 2;\n  for (let y = 0; y < img.height; y++) {\n    for (let x = 0; x < img.width; x++) {\n      let max = 0;\n      for (let jj = 0; jj < kernelHeight; jj++) {\n        for (let ii = 0; ii < kernelWidth; ii++) {\n          if (kernel[ii][jj] !== 1) continue;\n          let i = ii - radiusX + x;\n          let j = jj - radiusY + y;\n          if (i < 0 || j < 0 || i >= img.width || j >= img.height) continue;\n          const value = img.getValueXY(i, j, 0);\n          if (value > max) max = value;\n        }\n      }\n      newImage.setValueXY(x, y, 0, max);\n    }\n  }\n  return newImage;\n}\n\nfunction dilateOnceGreyOnlyOnes(img, newImage, kernelWidth, kernelHeight) {\n  const radiusX = (kernelWidth - 1) / 2;\n  const radiusY = (kernelHeight - 1) / 2;\n\n  const maxList = [];\n  for (let x = 0; x < img.width; x++) {\n    maxList.push(0);\n  }\n\n  for (let y = 0; y < img.height; y++) {\n    for (let x = 0; x < img.width; x++) {\n      let max = 0;\n      for (\n        let h = Math.max(0, y - radiusY);\n        h < Math.min(img.height, y + radiusY + 1);\n        h++\n      ) {\n        const value = img.getValueXY(x, h, 0);\n        if (value > max) {\n          max = value;\n        }\n      }\n      maxList[x] = max;\n    }\n\n    for (let x = 0; x < img.width; x++) {\n      let max = 0;\n      for (\n        let i = Math.max(0, x - radiusX);\n        i < Math.min(img.width, x + radiusX + 1);\n        i++\n      ) {\n        if (maxList[i] > max) {\n          max = maxList[i];\n        }\n      }\n      newImage.setValueXY(x, y, 0, max);\n    }\n  }\n  return newImage;\n}\n\nfunction dilateOnceBinary(img, newImage, kernel) {\n  const kernelWidth = kernel.length;\n  const kernelHeight = kernel[0].length;\n  let radiusX = (kernelWidth - 1) / 2;\n  let radiusY = (kernelHeight - 1) / 2;\n  for (let y = 0; y < img.height; y++) {\n    for (let x = 0; x < img.width; x++) {\n      let max = 0;\n      intLoop: for (let jj = 0; jj < kernelHeight; jj++) {\n        for (let ii = 0; ii < kernelWidth; ii++) {\n          if (kernel[ii][jj] !== 1) continue;\n          let i = ii - radiusX + x;\n          let j = jj - radiusY + y;\n          if (j < 0 || i < 0 || i >= img.width || j >= img.height) continue;\n          const value = img.getBitXY(i, j);\n          if (value === 1) {\n            max = 1;\n            break intLoop;\n          }\n        }\n      }\n      if (max === 1) {\n        newImage.setBitXY(x, y);\n      }\n    }\n  }\n  return newImage;\n}\n\nfunction dilateOnceBinaryOnlyOnes(img, newImage, kernelWidth, kernelHeight) {\n  const radiusX = (kernelWidth - 1) / 2;\n  const radiusY = (kernelHeight - 1) / 2;\n\n  const maxList = [];\n  for (let x = 0; x < img.width; x++) {\n    maxList.push(1);\n  }\n\n  for (let y = 0; y < img.height; y++) {\n    for (let x = 0; x < img.width; x++) {\n      maxList[x] = 0;\n      for (\n        let h = Math.max(0, y - radiusY);\n        h < Math.min(img.height, y + radiusY + 1);\n        h++\n      ) {\n        if (img.getBitXY(x, h) === 1) {\n          maxList[x] = 1;\n          break;\n        }\n      }\n    }\n\n    for (let x = 0; x < img.width; x++) {\n      if (newImage.getBitXY(x, y) === 1) continue;\n      for (\n        let i = Math.max(0, x - radiusX);\n        i < Math.min(img.width, x + radiusX + 1);\n        i++\n      ) {\n        if (maxList[i] === 1) {\n          newImage.setBitXY(x, y);\n          break;\n        }\n      }\n    }\n  }\n  return newImage;\n}\n"]},"metadata":{},"sourceType":"module"}