{"ast":null,"code":"import { RGB } from '../model/model';\n/**\n * Retrieve the data of the current image as RGBA 8 bits\n * The source image may be:\n * * a mask (binary image)\n * * a grey image (8 16 bits) with or without alpha channel\n * * a color image (8 or 16 bits) with or without alpha channel in with RGB model\n * @instance\n * @memberof Image\n * @param {object} [options]\n * @param {boolean} [options.clamped] - If true, the function will return a Uint8ClampedArray\n * @return {Uint8Array|Uint8ClampedArray} - Array with the data\n */\n\nexport default function getRGBAData(options = {}) {\n  const {\n    clamped\n  } = options;\n  this.checkProcessable('getRGBAData', {\n    components: [1, 3],\n    bitDepth: [1, 8, 16, 32]\n  });\n  const arrayLength = this.width * this.height * 4;\n  let newData = clamped ? new Uint8ClampedArray(arrayLength) : new Uint8Array(arrayLength);\n\n  if (this.bitDepth === 1) {\n    fillDataFromBinary(this, newData);\n  } else if (this.bitDepth === 32) {\n    this.checkProcessable('getRGBAData', {\n      alpha: 0\n    });\n\n    if (this.components === 1) {\n      fillDataFromGrey32(this, newData);\n    } else if (this.components === 3) {\n      this.checkProcessable('getRGBAData', {\n        colorModel: [RGB]\n      });\n      fillDataFromRGB32(this, newData);\n    }\n  } else {\n    if (this.components === 1) {\n      fillDataFromGrey(this, newData);\n    } else if (this.components === 3) {\n      this.checkProcessable('getRGBAData', {\n        colorModel: [RGB]\n      });\n      fillDataFromRGB(this, newData);\n    }\n  }\n\n  if (this.alpha === 1) {\n    this.checkProcessable('getRGBAData', {\n      bitDepth: [8, 16]\n    });\n    copyAlpha(this, newData);\n  } else {\n    fillAlpha(this, newData);\n  }\n\n  return newData;\n}\n\nfunction fillDataFromBinary(image, newData) {\n  for (let i = 0; i < image.size; i++) {\n    const value = image.getBit(i);\n    newData[i * 4] = value * 255;\n    newData[i * 4 + 1] = value * 255;\n    newData[i * 4 + 2] = value * 255;\n  }\n}\n\nfunction fillDataFromGrey32(image, newData) {\n  const min = image.min[0];\n  const max = image.max[0];\n  const range = max - min;\n\n  for (let i = 0; i < image.size; i++) {\n    const val = Math.floor(255 * (image.data[i] - min) / range);\n    newData[i * 4] = val;\n    newData[i * 4 + 1] = val;\n    newData[i * 4 + 2] = val;\n  }\n}\n\nfunction fillDataFromRGB32(image, newData) {\n  const min = Math.min(...image.min);\n  const max = Math.max(...image.max);\n  const range = max - min;\n\n  for (let i = 0; i < image.size; i++) {\n    const val1 = Math.floor(255 * (image.data[i * 3] - min) / range);\n    const val2 = Math.floor(255 * (image.data[i * 3 + 1] - min) / range);\n    const val3 = Math.floor(255 * (image.data[i * 3 + 2] - min) / range);\n    newData[i * 4] = val1;\n    newData[i * 4 + 1] = val2;\n    newData[i * 4 + 2] = val3;\n  }\n}\n\nfunction fillDataFromGrey(image, newData) {\n  for (let i = 0; i < image.size; i++) {\n    newData[i * 4] = image.data[i * image.channels] >>> image.bitDepth - 8;\n    newData[i * 4 + 1] = image.data[i * image.channels] >>> image.bitDepth - 8;\n    newData[i * 4 + 2] = image.data[i * image.channels] >>> image.bitDepth - 8;\n  }\n}\n\nfunction fillDataFromRGB(image, newData) {\n  for (let i = 0; i < image.size; i++) {\n    newData[i * 4] = image.data[i * image.channels] >>> image.bitDepth - 8;\n    newData[i * 4 + 1] = image.data[i * image.channels + 1] >>> image.bitDepth - 8;\n    newData[i * 4 + 2] = image.data[i * image.channels + 2] >>> image.bitDepth - 8;\n  }\n}\n\nfunction copyAlpha(image, newData) {\n  for (let i = 0; i < image.size; i++) {\n    newData[i * 4 + 3] = image.data[i * image.channels + image.components] >> image.bitDepth - 8;\n  }\n}\n\nfunction fillAlpha(image, newData) {\n  for (let i = 0; i < image.size; i++) {\n    newData[i * 4 + 3] = 255;\n  }\n}","map":{"version":3,"sources":["C:/Users/kuent/Documents/FinishDipshit/Creative/Ocean-Weather-Visualization/node_modules/image-js/src/image/core/getRGBAData.js"],"names":["RGB","getRGBAData","options","clamped","checkProcessable","components","bitDepth","arrayLength","width","height","newData","Uint8ClampedArray","Uint8Array","fillDataFromBinary","alpha","fillDataFromGrey32","colorModel","fillDataFromRGB32","fillDataFromGrey","fillDataFromRGB","copyAlpha","fillAlpha","image","i","size","value","getBit","min","max","range","val","Math","floor","data","val1","val2","val3","channels"],"mappings":"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","sourcesContent":["import { RGB } from '../model/model';\n\n/**\n * Retrieve the data of the current image as RGBA 8 bits\n * The source image may be:\n * * a mask (binary image)\n * * a grey image (8 16 bits) with or without alpha channel\n * * a color image (8 or 16 bits) with or without alpha channel in with RGB model\n * @instance\n * @memberof Image\n * @param {object} [options]\n * @param {boolean} [options.clamped] - If true, the function will return a Uint8ClampedArray\n * @return {Uint8Array|Uint8ClampedArray} - Array with the data\n */\nexport default function getRGBAData(options = {}) {\n  const { clamped } = options;\n  this.checkProcessable('getRGBAData', {\n    components: [1, 3],\n    bitDepth: [1, 8, 16, 32],\n  });\n  const arrayLength = this.width * this.height * 4;\n  let newData = clamped\n    ? new Uint8ClampedArray(arrayLength)\n    : new Uint8Array(arrayLength);\n  if (this.bitDepth === 1) {\n    fillDataFromBinary(this, newData);\n  } else if (this.bitDepth === 32) {\n    this.checkProcessable('getRGBAData', { alpha: 0 });\n    if (this.components === 1) {\n      fillDataFromGrey32(this, newData);\n    } else if (this.components === 3) {\n      this.checkProcessable('getRGBAData', { colorModel: [RGB] });\n      fillDataFromRGB32(this, newData);\n    }\n  } else {\n    if (this.components === 1) {\n      fillDataFromGrey(this, newData);\n    } else if (this.components === 3) {\n      this.checkProcessable('getRGBAData', { colorModel: [RGB] });\n      fillDataFromRGB(this, newData);\n    }\n  }\n  if (this.alpha === 1) {\n    this.checkProcessable('getRGBAData', { bitDepth: [8, 16] });\n    copyAlpha(this, newData);\n  } else {\n    fillAlpha(this, newData);\n  }\n  return newData;\n}\n\nfunction fillDataFromBinary(image, newData) {\n  for (let i = 0; i < image.size; i++) {\n    const value = image.getBit(i);\n    newData[i * 4] = value * 255;\n    newData[i * 4 + 1] = value * 255;\n    newData[i * 4 + 2] = value * 255;\n  }\n}\n\nfunction fillDataFromGrey32(image, newData) {\n  const min = image.min[0];\n  const max = image.max[0];\n  const range = max - min;\n  for (let i = 0; i < image.size; i++) {\n    const val = Math.floor((255 * (image.data[i] - min)) / range);\n    newData[i * 4] = val;\n    newData[i * 4 + 1] = val;\n    newData[i * 4 + 2] = val;\n  }\n}\n\nfunction fillDataFromRGB32(image, newData) {\n  const min = Math.min(...image.min);\n  const max = Math.max(...image.max);\n  const range = max - min;\n  for (let i = 0; i < image.size; i++) {\n    const val1 = Math.floor((255 * (image.data[i * 3] - min)) / range);\n    const val2 = Math.floor((255 * (image.data[i * 3 + 1] - min)) / range);\n    const val3 = Math.floor((255 * (image.data[i * 3 + 2] - min)) / range);\n    newData[i * 4] = val1;\n    newData[i * 4 + 1] = val2;\n    newData[i * 4 + 2] = val3;\n  }\n}\n\nfunction fillDataFromGrey(image, newData) {\n  for (let i = 0; i < image.size; i++) {\n    newData[i * 4] = image.data[i * image.channels] >>> (image.bitDepth - 8);\n    newData[i * 4 + 1] =\n      image.data[i * image.channels] >>> (image.bitDepth - 8);\n    newData[i * 4 + 2] =\n      image.data[i * image.channels] >>> (image.bitDepth - 8);\n  }\n}\n\nfunction fillDataFromRGB(image, newData) {\n  for (let i = 0; i < image.size; i++) {\n    newData[i * 4] = image.data[i * image.channels] >>> (image.bitDepth - 8);\n    newData[i * 4 + 1] =\n      image.data[i * image.channels + 1] >>> (image.bitDepth - 8);\n    newData[i * 4 + 2] =\n      image.data[i * image.channels + 2] >>> (image.bitDepth - 8);\n  }\n}\n\nfunction copyAlpha(image, newData) {\n  for (let i = 0; i < image.size; i++) {\n    newData[i * 4 + 3] =\n      image.data[i * image.channels + image.components] >> (image.bitDepth - 8);\n  }\n}\n\nfunction fillAlpha(image, newData) {\n  for (let i = 0; i < image.size; i++) {\n    newData[i * 4 + 3] = 255;\n  }\n}\n"]},"metadata":{},"sourceType":"module"}