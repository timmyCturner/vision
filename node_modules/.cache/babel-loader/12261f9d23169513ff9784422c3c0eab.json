{"ast":null,"code":"/*\n * see http://rsb.info.nih.gov/ij/developer/source/ij/process/AutoThresholder.java.html\n * The method is present in: Implements Li's Minimum Cross Entropy thresholding method\n * This implementation is based on the iterative version (Ref. 2nd reference below) of the algorithm.\n *  1) Li, CH & Lee, CK (1993), \"Minimum Cross Entropy Thresholding\", Pattern Recognition 26(4): 61 625\n *  2) Li, CH & Tam, PKS (1998), \"An Iterative Algorithm for Minimum Cross Entropy Thresholding\",\n *     Pattern Recognition Letters 18(8): 771-776\n *  3) Sezgin, M & Sankur, B (2004), \"Survey over Image Thresholding Techniques and Quantitative Performance\n *     Evaluation\",Journal of Electronic Imaging 13(1): 146-165\n * @param histogram - the histogram of the image\n * @param total - the number of pixels in the image\n * @returns {number} - the threshold\n */\nexport default function li(histogram, total) {\n  let threshold;\n  let sumBack;\n  /* sum of the background pixels at a given threshold */\n\n  let sumObj;\n  /* sum of the object pixels at a given threshold */\n\n  let numBack;\n  /* number of background pixels at a given threshold */\n\n  let numObj;\n  /* number of object pixels at a given threshold */\n\n  let oldThresh;\n  let newThresh;\n  let meanBack;\n  /* mean of the background pixels at a given threshold */\n\n  let meanObj;\n  /* mean of the object pixels at a given threshold */\n\n  let mean;\n  /* mean gray-level in the image */\n\n  let tolerance;\n  /* threshold tolerance */\n\n  let temp;\n  tolerance = 0.5;\n  /* Calculate the mean gray-level */\n\n  mean = 0.0;\n\n  for (let ih = 0; ih < histogram.length; ih++) {\n    mean += ih * histogram[ih];\n  }\n\n  mean /= total;\n  /* Initial estimate */\n\n  newThresh = mean;\n\n  do {\n    oldThresh = newThresh;\n    threshold = oldThresh + 0.5 | 0;\n    /* range */\n\n    /* Calculate the means of background and object pixels */\n\n    /* Background */\n\n    sumBack = 0;\n    numBack = 0;\n\n    for (let ih = 0; ih <= threshold; ih++) {\n      sumBack += ih * histogram[ih];\n      numBack += histogram[ih];\n    }\n\n    meanBack = numBack === 0 ? 0.0 : sumBack / numBack;\n    /* Object */\n\n    sumObj = 0;\n    numObj = 0;\n\n    for (let ih = threshold + 1; ih < histogram.length; ih++) {\n      sumObj += ih * histogram[ih];\n      numObj += histogram[ih];\n    }\n\n    meanObj = numObj === 0 ? 0.0 : sumObj / numObj;\n    temp = (meanBack - meanObj) / (Math.log(meanBack) - Math.log(meanObj));\n\n    if (temp < -Number.EPSILON) {\n      newThresh = temp - 0.5 | 0;\n    } else {\n      newThresh = temp + 0.5 | 0;\n    }\n    /*  Stop the iterations when the difference between the\n         new and old threshold values is less than the tolerance */\n\n  } while (Math.abs(newThresh - oldThresh) > tolerance);\n\n  return threshold;\n}","map":{"version":3,"sources":["C:/Users/kuent/Documents/FinishDipshit/Creative/Ocean-Weather-Visualization/node_modules/image-js/src/image/transform/mask/li.js"],"names":["li","histogram","total","threshold","sumBack","sumObj","numBack","numObj","oldThresh","newThresh","meanBack","meanObj","mean","tolerance","temp","ih","length","Math","log","Number","EPSILON","abs"],"mappings":"AAAA;;;;;;;;;;;;;AAcA,eAAe,SAASA,EAAT,CAAYC,SAAZ,EAAuBC,KAAvB,EAA8B;AAC3C,MAAIC,SAAJ;AACA,MAAIC,OAAJ;AAAa;;AACb,MAAIC,MAAJ;AAAY;;AACZ,MAAIC,OAAJ;AAAa;;AACb,MAAIC,MAAJ;AAAY;;AACZ,MAAIC,SAAJ;AACA,MAAIC,SAAJ;AACA,MAAIC,QAAJ;AAAc;;AACd,MAAIC,OAAJ;AAAa;;AACb,MAAIC,IAAJ;AAAU;;AACV,MAAIC,SAAJ;AAAe;;AACf,MAAIC,IAAJ;AACAD,EAAAA,SAAS,GAAG,GAAZ;AAEA;;AACAD,EAAAA,IAAI,GAAG,GAAP;;AACA,OAAK,IAAIG,EAAE,GAAG,CAAd,EAAiBA,EAAE,GAAGd,SAAS,CAACe,MAAhC,EAAwCD,EAAE,EAA1C,EAA8C;AAC5CH,IAAAA,IAAI,IAAIG,EAAE,GAAGd,SAAS,CAACc,EAAD,CAAtB;AACD;;AAEDH,EAAAA,IAAI,IAAIV,KAAR;AACA;;AACAO,EAAAA,SAAS,GAAGG,IAAZ;;AAEA,KAAG;AACDJ,IAAAA,SAAS,GAAGC,SAAZ;AACAN,IAAAA,SAAS,GAAIK,SAAS,GAAG,GAAb,GAAoB,CAAhC;AAAmC;;AAEnC;;AACA;;AACAJ,IAAAA,OAAO,GAAG,CAAV;AACAE,IAAAA,OAAO,GAAG,CAAV;;AAEA,SAAK,IAAIS,EAAE,GAAG,CAAd,EAAiBA,EAAE,IAAIZ,SAAvB,EAAkCY,EAAE,EAApC,EAAwC;AACtCX,MAAAA,OAAO,IAAIW,EAAE,GAAGd,SAAS,CAACc,EAAD,CAAzB;AACAT,MAAAA,OAAO,IAAIL,SAAS,CAACc,EAAD,CAApB;AACD;;AACDL,IAAAA,QAAQ,GAAGJ,OAAO,KAAK,CAAZ,GAAgB,GAAhB,GAAsBF,OAAO,GAAGE,OAA3C;AAEA;;AACAD,IAAAA,MAAM,GAAG,CAAT;AACAE,IAAAA,MAAM,GAAG,CAAT;;AACA,SAAK,IAAIQ,EAAE,GAAGZ,SAAS,GAAG,CAA1B,EAA6BY,EAAE,GAAGd,SAAS,CAACe,MAA5C,EAAoDD,EAAE,EAAtD,EAA0D;AACxDV,MAAAA,MAAM,IAAIU,EAAE,GAAGd,SAAS,CAACc,EAAD,CAAxB;AACAR,MAAAA,MAAM,IAAIN,SAAS,CAACc,EAAD,CAAnB;AACD;;AACDJ,IAAAA,OAAO,GAAGJ,MAAM,KAAK,CAAX,GAAe,GAAf,GAAqBF,MAAM,GAAGE,MAAxC;AACAO,IAAAA,IAAI,GAAG,CAACJ,QAAQ,GAAGC,OAAZ,KAAwBM,IAAI,CAACC,GAAL,CAASR,QAAT,IAAqBO,IAAI,CAACC,GAAL,CAASP,OAAT,CAA7C,CAAP;;AAEA,QAAIG,IAAI,GAAG,CAACK,MAAM,CAACC,OAAnB,EAA4B;AAC1BX,MAAAA,SAAS,GAAIK,IAAI,GAAG,GAAR,GAAe,CAA3B;AACD,KAFD,MAEO;AACLL,MAAAA,SAAS,GAAIK,IAAI,GAAG,GAAR,GAAe,CAA3B;AACD;AACD;;;AAED,GAhCD,QAgCSG,IAAI,CAACI,GAAL,CAASZ,SAAS,GAAGD,SAArB,IAAkCK,SAhC3C;;AAkCA,SAAOV,SAAP;AACD","sourcesContent":["/*\n * see http://rsb.info.nih.gov/ij/developer/source/ij/process/AutoThresholder.java.html\n * The method is present in: Implements Li's Minimum Cross Entropy thresholding method\n * This implementation is based on the iterative version (Ref. 2nd reference below) of the algorithm.\n *  1) Li, CH & Lee, CK (1993), \"Minimum Cross Entropy Thresholding\", Pattern Recognition 26(4): 61 625\n *  2) Li, CH & Tam, PKS (1998), \"An Iterative Algorithm for Minimum Cross Entropy Thresholding\",\n *     Pattern Recognition Letters 18(8): 771-776\n *  3) Sezgin, M & Sankur, B (2004), \"Survey over Image Thresholding Techniques and Quantitative Performance\n *     Evaluation\",Journal of Electronic Imaging 13(1): 146-165\n * @param histogram - the histogram of the image\n * @param total - the number of pixels in the image\n * @returns {number} - the threshold\n */\n\nexport default function li(histogram, total) {\n  let threshold;\n  let sumBack; /* sum of the background pixels at a given threshold */\n  let sumObj; /* sum of the object pixels at a given threshold */\n  let numBack; /* number of background pixels at a given threshold */\n  let numObj; /* number of object pixels at a given threshold */\n  let oldThresh;\n  let newThresh;\n  let meanBack; /* mean of the background pixels at a given threshold */\n  let meanObj; /* mean of the object pixels at a given threshold */\n  let mean; /* mean gray-level in the image */\n  let tolerance; /* threshold tolerance */\n  let temp;\n  tolerance = 0.5;\n\n  /* Calculate the mean gray-level */\n  mean = 0.0;\n  for (let ih = 0; ih < histogram.length; ih++) {\n    mean += ih * histogram[ih];\n  }\n\n  mean /= total;\n  /* Initial estimate */\n  newThresh = mean;\n\n  do {\n    oldThresh = newThresh;\n    threshold = (oldThresh + 0.5) | 0; /* range */\n\n    /* Calculate the means of background and object pixels */\n    /* Background */\n    sumBack = 0;\n    numBack = 0;\n\n    for (let ih = 0; ih <= threshold; ih++) {\n      sumBack += ih * histogram[ih];\n      numBack += histogram[ih];\n    }\n    meanBack = numBack === 0 ? 0.0 : sumBack / numBack;\n\n    /* Object */\n    sumObj = 0;\n    numObj = 0;\n    for (let ih = threshold + 1; ih < histogram.length; ih++) {\n      sumObj += ih * histogram[ih];\n      numObj += histogram[ih];\n    }\n    meanObj = numObj === 0 ? 0.0 : sumObj / numObj;\n    temp = (meanBack - meanObj) / (Math.log(meanBack) - Math.log(meanObj));\n\n    if (temp < -Number.EPSILON) {\n      newThresh = (temp - 0.5) | 0;\n    } else {\n      newThresh = (temp + 0.5) | 0;\n    }\n    /*  Stop the iterations when the difference between the\n         new and old threshold values is less than the tolerance */\n  } while (Math.abs(newThresh - oldThresh) > tolerance);\n\n  return threshold;\n}\n"]},"metadata":{},"sourceType":"module"}