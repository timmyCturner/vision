{"ast":null,"code":"import { IOBuffer } from 'iobuffer';\nimport { applyHorizontalDifferencing8Bit, applyHorizontalDifferencing16Bit } from './horizontalDifferencing';\nimport IFD from './ifd';\nimport { getByteLength, readData } from './ifdValue';\nimport { decompressLzw } from './lzw';\nimport TiffIfd from './tiffIfd';\nconst defaultOptions = {\n  ignoreImageData: false,\n  onlyFirst: false\n};\nexport default class TIFFDecoder extends IOBuffer {\n  constructor(data) {\n    super(data);\n    this._nextIFD = 0;\n  }\n\n  get isMultiPage() {\n    let c = 0;\n    this.decodeHeader();\n\n    while (this._nextIFD) {\n      c++;\n      this.decodeIFD({\n        ignoreImageData: true\n      }, true);\n\n      if (c === 2) {\n        return true;\n      }\n    }\n\n    if (c === 1) {\n      return false;\n    }\n\n    throw unsupported('ifdCount', c);\n  }\n\n  get pageCount() {\n    let c = 0;\n    this.decodeHeader();\n\n    while (this._nextIFD) {\n      c++;\n      this.decodeIFD({\n        ignoreImageData: true\n      }, true);\n    }\n\n    if (c > 0) {\n      return c;\n    }\n\n    throw unsupported('ifdCount', c);\n  }\n\n  decode(options = {}) {\n    options = Object.assign({}, defaultOptions, options);\n    const result = [];\n    this.decodeHeader();\n\n    while (this._nextIFD) {\n      result.push(this.decodeIFD(options, true));\n\n      if (options.onlyFirst) {\n        return [result[0]];\n      }\n    }\n\n    return result;\n  }\n\n  decodeHeader() {\n    // Byte offset\n    const value = this.readUint16();\n\n    if (value === 0x4949) {\n      this.setLittleEndian();\n    } else if (value === 0x4d4d) {\n      this.setBigEndian();\n    } else {\n      throw new Error(`invalid byte order: 0x${value.toString(16)}`);\n    } // Magic number\n\n\n    if (this.readUint16() !== 42) {\n      throw new Error('not a TIFF file');\n    } // Offset of the first IFD\n\n\n    this._nextIFD = this.readUint32();\n  }\n\n  decodeIFD(options, tiff) {\n    this.seek(this._nextIFD);\n    let ifd;\n\n    if (tiff) {\n      ifd = new TiffIfd();\n    } else {\n      if (!options.kind) {\n        throw new Error(`kind is missing`);\n      }\n\n      ifd = new IFD(options.kind);\n    }\n\n    const numEntries = this.readUint16();\n\n    for (let i = 0; i < numEntries; i++) {\n      this.decodeIFDEntry(ifd);\n    }\n\n    if (!options.ignoreImageData) {\n      if (!(ifd instanceof TiffIfd)) {\n        throw new Error('must be a tiff ifd');\n      }\n\n      this.decodeImageData(ifd);\n    }\n\n    this._nextIFD = this.readUint32();\n    return ifd;\n  }\n\n  decodeIFDEntry(ifd) {\n    const offset = this.offset;\n    const tag = this.readUint16();\n    const type = this.readUint16();\n    const numValues = this.readUint32();\n\n    if (type < 1 || type > 12) {\n      this.skip(4); // unknown type, skip this value\n\n      return;\n    }\n\n    const valueByteLength = getByteLength(type, numValues);\n\n    if (valueByteLength > 4) {\n      this.seek(this.readUint32());\n    }\n\n    const value = readData(this, type, numValues);\n    ifd.fields.set(tag, value); // Read sub-IFDs\n\n    if (tag === 0x8769 || tag === 0x8825) {\n      let currentOffset = this.offset;\n      let kind = 'exif';\n\n      if (tag === 0x8769) {\n        kind = 'exif';\n      } else if (tag === 0x8825) {\n        kind = 'gps';\n      }\n\n      this._nextIFD = value;\n      ifd[kind] = this.decodeIFD({\n        kind,\n        ignoreImageData: true\n      }, false);\n      this.offset = currentOffset;\n    } // go to the next entry\n\n\n    this.seek(offset);\n    this.skip(12);\n  }\n\n  decodeImageData(ifd) {\n    const orientation = ifd.orientation;\n\n    if (orientation && orientation !== 1) {\n      throw unsupported('orientation', orientation);\n    }\n\n    switch (ifd.type) {\n      case 0: // WhiteIsZero\n\n      case 1: // BlackIsZero\n\n      case 2: // RGB\n\n      case 3:\n        // Palette color\n        this.readStripData(ifd);\n        break;\n\n      default:\n        throw unsupported('image type', ifd.type);\n    }\n\n    this.applyPredictor(ifd);\n    this.convertAlpha(ifd);\n\n    if (ifd.type === 0) {\n      // WhiteIsZero: we invert the values\n      const bitDepth = ifd.bitsPerSample;\n      const maxValue = Math.pow(2, bitDepth) - 1;\n\n      for (let i = 0; i < ifd.data.length; i++) {\n        ifd.data[i] = maxValue - ifd.data[i];\n      }\n    }\n  }\n\n  readStripData(ifd) {\n    const width = ifd.width;\n    const height = ifd.height;\n    const bitDepth = ifd.bitsPerSample;\n    const sampleFormat = ifd.sampleFormat;\n    const size = width * height * ifd.samplesPerPixel;\n    const data = getDataArray(size, bitDepth, sampleFormat);\n    const rowsPerStrip = ifd.rowsPerStrip;\n    const maxPixels = rowsPerStrip * width * ifd.samplesPerPixel;\n    const stripOffsets = ifd.stripOffsets;\n    const stripByteCounts = ifd.stripByteCounts;\n    let remainingPixels = size;\n    let pixel = 0;\n\n    for (let i = 0; i < stripOffsets.length; i++) {\n      let stripData = new DataView(this.buffer, stripOffsets[i], stripByteCounts[i]); // Last strip can be smaller\n\n      let length = remainingPixels > maxPixels ? maxPixels : remainingPixels;\n      remainingPixels -= length;\n      let dataToFill = stripData;\n\n      switch (ifd.compression) {\n        case 1:\n          {\n            // No compression, nothing to do\n            break;\n          }\n\n        case 5:\n          {\n            // LZW compression\n            dataToFill = decompressLzw(stripData);\n            break;\n          }\n\n        case 2:\n          // CCITT Group 3 1-Dimensional Modified Huffman run length encoding\n          throw unsupported('Compression', 'CCITT Group 3');\n\n        case 32773:\n          // PackBits compression\n          throw unsupported('Compression', 'PackBits');\n\n        default:\n          throw new Error(`invalid compression: ${ifd.compression}`);\n      }\n\n      pixel = this.fillUncompressed(bitDepth, sampleFormat, data, dataToFill, pixel, length);\n    }\n\n    ifd.data = data;\n  }\n\n  fillUncompressed(bitDepth, sampleFormat, data, stripData, pixel, length) {\n    if (bitDepth === 8) {\n      return fill8bit(data, stripData, pixel, length);\n    } else if (bitDepth === 16) {\n      return fill16bit(data, stripData, pixel, length, this.isLittleEndian());\n    } else if (bitDepth === 32 && sampleFormat === 3) {\n      return fillFloat32(data, stripData, pixel, length, this.isLittleEndian());\n    } else {\n      throw unsupported('bitDepth', bitDepth);\n    }\n  }\n\n  applyPredictor(ifd) {\n    const bitDepth = ifd.bitsPerSample;\n\n    switch (ifd.predictor) {\n      case 1:\n        {\n          // No prediction scheme, nothing to do\n          break;\n        }\n\n      case 2:\n        {\n          if (bitDepth === 8) {\n            applyHorizontalDifferencing8Bit(ifd.data, ifd.width, ifd.components);\n          } else if (bitDepth === 16) {\n            applyHorizontalDifferencing16Bit(ifd.data, ifd.width, ifd.components);\n          } else {\n            throw new Error(`Horizontal differencing is only supported for images with a bit depth of ${bitDepth}`);\n          }\n\n          break;\n        }\n\n      default:\n        throw new Error(`invalid predictor: ${ifd.predictor}`);\n    }\n  }\n\n  convertAlpha(ifd) {\n    if (ifd.alpha && ifd.associatedAlpha) {\n      const {\n        data,\n        components,\n        maxSampleValue\n      } = ifd;\n\n      for (let i = 0; i < data.length; i += components) {\n        const alphaValue = data[i + components - 1];\n\n        for (let j = 0; j < components - 1; j++) {\n          data[i + j] = Math.round(data[i + j] * maxSampleValue / alphaValue);\n        }\n      }\n    }\n  }\n\n}\n\nfunction getDataArray(size, bitDepth, sampleFormat) {\n  if (bitDepth === 8) {\n    return new Uint8Array(size);\n  } else if (bitDepth === 16) {\n    return new Uint16Array(size);\n  } else if (bitDepth === 32 && sampleFormat === 3) {\n    return new Float32Array(size);\n  } else {\n    throw unsupported('bit depth / sample format', `${bitDepth} / ${sampleFormat}`);\n  }\n}\n\nfunction fill8bit(dataTo, dataFrom, index, length) {\n  for (let i = 0; i < length; i++) {\n    dataTo[index++] = dataFrom.getUint8(i);\n  }\n\n  return index;\n}\n\nfunction fill16bit(dataTo, dataFrom, index, length, littleEndian) {\n  for (let i = 0; i < length * 2; i += 2) {\n    dataTo[index++] = dataFrom.getUint16(i, littleEndian);\n  }\n\n  return index;\n}\n\nfunction fillFloat32(dataTo, dataFrom, index, length, littleEndian) {\n  for (let i = 0; i < length * 4; i += 4) {\n    dataTo[index++] = dataFrom.getFloat32(i, littleEndian);\n  }\n\n  return index;\n}\n\nfunction unsupported(type, value) {\n  return new Error(`Unsupported ${type}: ${value}`);\n}","map":{"version":3,"sources":["../src/tiffDecoder.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { IOBuffer } from 'iobuffer';\r\nimport { applyHorizontalDifferencing8Bit, applyHorizontalDifferencing16Bit, } from './horizontalDifferencing';\r\nimport IFD from './ifd';\r\nimport { getByteLength, readData } from './ifdValue';\r\nimport { decompressLzw } from './lzw';\r\nimport TiffIfd from './tiffIfd';\r\nconst defaultOptions = {\r\n    ignoreImageData: false,\r\n    onlyFirst: false,\r\n};\r\nexport default class TIFFDecoder extends IOBuffer {\r\n    constructor(data) {\r\n        super(data);\r\n        this._nextIFD = 0;\r\n    }\r\n    get isMultiPage() {\r\n        let c = 0;\r\n        this.decodeHeader();\r\n        while (this._nextIFD) {\r\n            c++;\r\n            this.decodeIFD({ ignoreImageData: true }, true);\r\n            if (c === 2) {\r\n                return true;\r\n            }\r\n        }\r\n        if (c === 1) {\r\n            return false;\r\n        }\r\n        throw unsupported('ifdCount', c);\r\n    }\r\n    get pageCount() {\r\n        let c = 0;\r\n        this.decodeHeader();\r\n        while (this._nextIFD) {\r\n            c++;\r\n            this.decodeIFD({ ignoreImageData: true }, true);\r\n        }\r\n        if (c > 0) {\r\n            return c;\r\n        }\r\n        throw unsupported('ifdCount', c);\r\n    }\r\n    decode(options = {}) {\r\n        options = Object.assign({}, defaultOptions, options);\r\n        const result = [];\r\n        this.decodeHeader();\r\n        while (this._nextIFD) {\r\n            result.push(this.decodeIFD(options, true));\r\n            if (options.onlyFirst) {\r\n                return [result[0]];\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n    decodeHeader() {\r\n        // Byte offset\r\n        const value = this.readUint16();\r\n        if (value === 0x4949) {\r\n            this.setLittleEndian();\r\n        }\r\n        else if (value === 0x4d4d) {\r\n            this.setBigEndian();\r\n        }\r\n        else {\r\n            throw new Error(`invalid byte order: 0x${value.toString(16)}`);\r\n        }\r\n        // Magic number\r\n        if (this.readUint16() !== 42) {\r\n            throw new Error('not a TIFF file');\r\n        }\r\n        // Offset of the first IFD\r\n        this._nextIFD = this.readUint32();\r\n    }\r\n    decodeIFD(options, tiff) {\r\n        this.seek(this._nextIFD);\r\n        let ifd;\r\n        if (tiff) {\r\n            ifd = new TiffIfd();\r\n        }\r\n        else {\r\n            if (!options.kind) {\r\n                throw new Error(`kind is missing`);\r\n            }\r\n            ifd = new IFD(options.kind);\r\n        }\r\n        const numEntries = this.readUint16();\r\n        for (let i = 0; i < numEntries; i++) {\r\n            this.decodeIFDEntry(ifd);\r\n        }\r\n        if (!options.ignoreImageData) {\r\n            if (!(ifd instanceof TiffIfd)) {\r\n                throw new Error('must be a tiff ifd');\r\n            }\r\n            this.decodeImageData(ifd);\r\n        }\r\n        this._nextIFD = this.readUint32();\r\n        return ifd;\r\n    }\r\n    decodeIFDEntry(ifd) {\r\n        const offset = this.offset;\r\n        const tag = this.readUint16();\r\n        const type = this.readUint16();\r\n        const numValues = this.readUint32();\r\n        if (type < 1 || type > 12) {\r\n            this.skip(4); // unknown type, skip this value\r\n            return;\r\n        }\r\n        const valueByteLength = getByteLength(type, numValues);\r\n        if (valueByteLength > 4) {\r\n            this.seek(this.readUint32());\r\n        }\r\n        const value = readData(this, type, numValues);\r\n        ifd.fields.set(tag, value);\r\n        // Read sub-IFDs\r\n        if (tag === 0x8769 || tag === 0x8825) {\r\n            let currentOffset = this.offset;\r\n            let kind = 'exif';\r\n            if (tag === 0x8769) {\r\n                kind = 'exif';\r\n            }\r\n            else if (tag === 0x8825) {\r\n                kind = 'gps';\r\n            }\r\n            this._nextIFD = value;\r\n            ifd[kind] = this.decodeIFD({\r\n                kind,\r\n                ignoreImageData: true,\r\n            }, false);\r\n            this.offset = currentOffset;\r\n        }\r\n        // go to the next entry\r\n        this.seek(offset);\r\n        this.skip(12);\r\n    }\r\n    decodeImageData(ifd) {\r\n        const orientation = ifd.orientation;\r\n        if (orientation && orientation !== 1) {\r\n            throw unsupported('orientation', orientation);\r\n        }\r\n        switch (ifd.type) {\r\n            case 0: // WhiteIsZero\r\n            case 1: // BlackIsZero\r\n            case 2: // RGB\r\n            case 3: // Palette color\r\n                this.readStripData(ifd);\r\n                break;\r\n            default:\r\n                throw unsupported('image type', ifd.type);\r\n        }\r\n        this.applyPredictor(ifd);\r\n        this.convertAlpha(ifd);\r\n        if (ifd.type === 0) {\r\n            // WhiteIsZero: we invert the values\r\n            const bitDepth = ifd.bitsPerSample;\r\n            const maxValue = Math.pow(2, bitDepth) - 1;\r\n            for (let i = 0; i < ifd.data.length; i++) {\r\n                ifd.data[i] = maxValue - ifd.data[i];\r\n            }\r\n        }\r\n    }\r\n    readStripData(ifd) {\r\n        const width = ifd.width;\r\n        const height = ifd.height;\r\n        const bitDepth = ifd.bitsPerSample;\r\n        const sampleFormat = ifd.sampleFormat;\r\n        const size = width * height * ifd.samplesPerPixel;\r\n        const data = getDataArray(size, bitDepth, sampleFormat);\r\n        const rowsPerStrip = ifd.rowsPerStrip;\r\n        const maxPixels = rowsPerStrip * width * ifd.samplesPerPixel;\r\n        const stripOffsets = ifd.stripOffsets;\r\n        const stripByteCounts = ifd.stripByteCounts;\r\n        let remainingPixels = size;\r\n        let pixel = 0;\r\n        for (let i = 0; i < stripOffsets.length; i++) {\r\n            let stripData = new DataView(this.buffer, stripOffsets[i], stripByteCounts[i]);\r\n            // Last strip can be smaller\r\n            let length = remainingPixels > maxPixels ? maxPixels : remainingPixels;\r\n            remainingPixels -= length;\r\n            let dataToFill = stripData;\r\n            switch (ifd.compression) {\r\n                case 1: {\r\n                    // No compression, nothing to do\r\n                    break;\r\n                }\r\n                case 5: {\r\n                    // LZW compression\r\n                    dataToFill = decompressLzw(stripData);\r\n                    break;\r\n                }\r\n                case 2: // CCITT Group 3 1-Dimensional Modified Huffman run length encoding\r\n                    throw unsupported('Compression', 'CCITT Group 3');\r\n                case 32773: // PackBits compression\r\n                    throw unsupported('Compression', 'PackBits');\r\n                default:\r\n                    throw new Error(`invalid compression: ${ifd.compression}`);\r\n            }\r\n            pixel = this.fillUncompressed(bitDepth, sampleFormat, data, dataToFill, pixel, length);\r\n        }\r\n        ifd.data = data;\r\n    }\r\n    fillUncompressed(bitDepth, sampleFormat, data, stripData, pixel, length) {\r\n        if (bitDepth === 8) {\r\n            return fill8bit(data, stripData, pixel, length);\r\n        }\r\n        else if (bitDepth === 16) {\r\n            return fill16bit(data, stripData, pixel, length, this.isLittleEndian());\r\n        }\r\n        else if (bitDepth === 32 && sampleFormat === 3) {\r\n            return fillFloat32(data, stripData, pixel, length, this.isLittleEndian());\r\n        }\r\n        else {\r\n            throw unsupported('bitDepth', bitDepth);\r\n        }\r\n    }\r\n    applyPredictor(ifd) {\r\n        const bitDepth = ifd.bitsPerSample;\r\n        switch (ifd.predictor) {\r\n            case 1: {\r\n                // No prediction scheme, nothing to do\r\n                break;\r\n            }\r\n            case 2: {\r\n                if (bitDepth === 8) {\r\n                    applyHorizontalDifferencing8Bit(ifd.data, ifd.width, ifd.components);\r\n                }\r\n                else if (bitDepth === 16) {\r\n                    applyHorizontalDifferencing16Bit(ifd.data, ifd.width, ifd.components);\r\n                }\r\n                else {\r\n                    throw new Error(`Horizontal differencing is only supported for images with a bit depth of ${bitDepth}`);\r\n                }\r\n                break;\r\n            }\r\n            default:\r\n                throw new Error(`invalid predictor: ${ifd.predictor}`);\r\n        }\r\n    }\r\n    convertAlpha(ifd) {\r\n        if (ifd.alpha && ifd.associatedAlpha) {\r\n            const { data, components, maxSampleValue } = ifd;\r\n            for (let i = 0; i < data.length; i += components) {\r\n                const alphaValue = data[i + components - 1];\r\n                for (let j = 0; j < components - 1; j++) {\r\n                    data[i + j] = Math.round((data[i + j] * maxSampleValue) / alphaValue);\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\nfunction getDataArray(size, bitDepth, sampleFormat) {\r\n    if (bitDepth === 8) {\r\n        return new Uint8Array(size);\r\n    }\r\n    else if (bitDepth === 16) {\r\n        return new Uint16Array(size);\r\n    }\r\n    else if (bitDepth === 32 && sampleFormat === 3) {\r\n        return new Float32Array(size);\r\n    }\r\n    else {\r\n        throw unsupported('bit depth / sample format', `${bitDepth} / ${sampleFormat}`);\r\n    }\r\n}\r\nfunction fill8bit(dataTo, dataFrom, index, length) {\r\n    for (let i = 0; i < length; i++) {\r\n        dataTo[index++] = dataFrom.getUint8(i);\r\n    }\r\n    return index;\r\n}\r\nfunction fill16bit(dataTo, dataFrom, index, length, littleEndian) {\r\n    for (let i = 0; i < length * 2; i += 2) {\r\n        dataTo[index++] = dataFrom.getUint16(i, littleEndian);\r\n    }\r\n    return index;\r\n}\r\nfunction fillFloat32(dataTo, dataFrom, index, length, littleEndian) {\r\n    for (let i = 0; i < length * 4; i += 4) {\r\n        dataTo[index++] = dataFrom.getFloat32(i, littleEndian);\r\n    }\r\n    return index;\r\n}\r\nfunction unsupported(type, value) {\r\n    return new Error(`Unsupported ${type}: ${value}`);\r\n}\r\n//# sourceMappingURL=tiffDecoder.js.map"]},"metadata":{},"sourceType":"module"}