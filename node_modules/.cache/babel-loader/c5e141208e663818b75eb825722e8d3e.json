{"ast":null,"code":"/**\n * An image may be derived from another image either by a crop\n * or because it is a ROI (region of interest)\n * Also a region of interest can be reprocessed to generated another\n * set of region of interests.\n * It is therefore important to keep the hierarchy of images to know\n * which image is derived from which one and be able to get the\n * relative position of one image in another\n * This methods takes care of this.\n * @memberof Image\n * @instance\n * @param {Image} targetImage\n * @param {object} [options={}]\n * @param {boolean} [options.defaultFurther=false] If set to true and no parent found returns the relative position\n *      to the further parent\n * @return {number[]|boolean}\n */\nexport default function getRelativePosition(targetImage, options = {}) {\n  if (this === targetImage) {\n    return [0, 0];\n  }\n\n  let position = [0, 0];\n  let currentImage = this;\n\n  while (currentImage) {\n    if (currentImage === targetImage) {\n      return position;\n    }\n\n    if (currentImage.position) {\n      position[0] += currentImage.position[0];\n      position[1] += currentImage.position[1];\n    }\n\n    currentImage = currentImage.parent;\n  } // we should never reach this place, this means we could not find the parent\n  // throw Error('Parent image was not found, can not get relative position.')\n\n\n  if (options.defaultFurther) return position;\n  return false;\n}","map":{"version":3,"sources":["C:/Users/kuent/Documents/FinishDipshit/Creative/Ocean-Weather-Visualization/node_modules/image-js/src/image/compute/relativePosition.js"],"names":["getRelativePosition","targetImage","options","position","currentImage","parent","defaultFurther"],"mappings":"AAAA;;;;;;;;;;;;;;;;;AAiBA,eAAe,SAASA,mBAAT,CAA6BC,WAA7B,EAA0CC,OAAO,GAAG,EAApD,EAAwD;AACrE,MAAI,SAASD,WAAb,EAA0B;AACxB,WAAO,CAAC,CAAD,EAAI,CAAJ,CAAP;AACD;;AACD,MAAIE,QAAQ,GAAG,CAAC,CAAD,EAAI,CAAJ,CAAf;AAEA,MAAIC,YAAY,GAAG,IAAnB;;AACA,SAAOA,YAAP,EAAqB;AACnB,QAAIA,YAAY,KAAKH,WAArB,EAAkC;AAChC,aAAOE,QAAP;AACD;;AACD,QAAIC,YAAY,CAACD,QAAjB,EAA2B;AACzBA,MAAAA,QAAQ,CAAC,CAAD,CAAR,IAAeC,YAAY,CAACD,QAAb,CAAsB,CAAtB,CAAf;AACAA,MAAAA,QAAQ,CAAC,CAAD,CAAR,IAAeC,YAAY,CAACD,QAAb,CAAsB,CAAtB,CAAf;AACD;;AACDC,IAAAA,YAAY,GAAGA,YAAY,CAACC,MAA5B;AACD,GAhBoE,CAiBrE;AACA;;;AACA,MAAIH,OAAO,CAACI,cAAZ,EAA4B,OAAOH,QAAP;AAE5B,SAAO,KAAP;AACD","sourcesContent":["/**\n * An image may be derived from another image either by a crop\n * or because it is a ROI (region of interest)\n * Also a region of interest can be reprocessed to generated another\n * set of region of interests.\n * It is therefore important to keep the hierarchy of images to know\n * which image is derived from which one and be able to get the\n * relative position of one image in another\n * This methods takes care of this.\n * @memberof Image\n * @instance\n * @param {Image} targetImage\n * @param {object} [options={}]\n * @param {boolean} [options.defaultFurther=false] If set to true and no parent found returns the relative position\n *      to the further parent\n * @return {number[]|boolean}\n */\nexport default function getRelativePosition(targetImage, options = {}) {\n  if (this === targetImage) {\n    return [0, 0];\n  }\n  let position = [0, 0];\n\n  let currentImage = this;\n  while (currentImage) {\n    if (currentImage === targetImage) {\n      return position;\n    }\n    if (currentImage.position) {\n      position[0] += currentImage.position[0];\n      position[1] += currentImage.position[1];\n    }\n    currentImage = currentImage.parent;\n  }\n  // we should never reach this place, this means we could not find the parent\n  // throw Error('Parent image was not found, can not get relative position.')\n  if (options.defaultFurther) return position;\n\n  return false;\n}\n"]},"metadata":{},"sourceType":"module"}