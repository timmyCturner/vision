{"ast":null,"code":"import { rotate, difference, normalize } from '../../util/points';\nimport convexHullFunction from './monotoneChainConvexHull';\n/**\n * Computes the minimum bounding box around a binary image\n * https://www.researchgate.net/profile/Lennert_Den_Boer2/publication/303783472_A_Fast_Algorithm_for_Generating_a_Minimal_Bounding_Rectangle/links/5751a14108ae6807fafb2aa5.pdf\n * @memberof Image\n * @instance\n * @param {object} [options]\n * @param {Array<Array<number>>} [options.originalPoints]\n * @return {Array<Array<number>>}\n */\n\nexport default function minimalBoundingRectangle(options = {}) {\n  const {\n    originalPoints = convexHullFunction.call(this)\n  } = options;\n\n  if (originalPoints.length === 0) {\n    return [];\n  }\n\n  if (originalPoints.length === 1) {\n    return [originalPoints[0], originalPoints[0], originalPoints[0], originalPoints[0]];\n  }\n\n  const p = new Array(originalPoints.length);\n  let minSurface = +Infinity;\n  let minSurfaceAngle = 0;\n  let mbr;\n\n  for (let i = 0; i < p.length; i++) {\n    let angle = getAngle(originalPoints[i], originalPoints[(i + 1) % p.length]);\n    rotate(-angle, originalPoints, p); // we rotate and translate so that this axe is in the bottom\n\n    let aX = p[i][0];\n    let aY = p[i][1];\n    let bX = p[(i + 1) % p.length][0];\n    let bY = p[(i + 1) % p.length][1];\n    let tUndefined = true;\n    let tMin = 0;\n    let tMax = 0;\n    let maxWidth = 0;\n\n    for (let j = 0; j < p.length; j++) {\n      let cX = p[j][0];\n      let cY = p[j][1];\n      let t = (cX - aX) / (bX - aX);\n\n      if (tUndefined === true) {\n        tUndefined = false;\n        tMin = t;\n        tMax = t;\n      } else {\n        if (t < tMin) tMin = t;\n        if (t > tMax) tMax = t;\n      }\n\n      let width = (-(bX - aX) * cY + bX * aY - bY * aX) / (bX - aX);\n      if (Math.abs(width) > Math.abs(maxWidth)) maxWidth = width;\n    }\n\n    let pMin = [aX + tMin * (bX - aX), aY];\n    let pMax = [aX + tMax * (bX - aX), aY];\n    let currentSurface = Math.abs(maxWidth * (tMin - tMax) * (bX - aX));\n\n    if (currentSurface < minSurface) {\n      minSurfaceAngle = angle;\n      minSurface = currentSurface;\n      mbr = [pMin, pMax, [pMax[0], pMax[1] - maxWidth], [pMin[0], pMin[1] - maxWidth]];\n    }\n  }\n\n  rotate(minSurfaceAngle, mbr, mbr);\n  return mbr;\n} // the angle that allows to make the line going through p1 and p2 horizontal\n// this is an optimized version because it assume one vector is horizontal\n\nfunction getAngle(p1, p2) {\n  let diff = difference(p2, p1);\n  let vector = normalize(diff);\n  let angle = Math.acos(vector[0]);\n  if (vector[1] < 0) return -angle;\n  return angle;\n}","map":{"version":3,"sources":["C:/Users/kuent/Documents/FinishDipshit/Creative/Ocean-Weather-Visualization/node_modules/image-js/src/image/compute/minimalBoundingRectangle.js"],"names":["rotate","difference","normalize","convexHullFunction","minimalBoundingRectangle","options","originalPoints","call","length","p","Array","minSurface","Infinity","minSurfaceAngle","mbr","i","angle","getAngle","aX","aY","bX","bY","tUndefined","tMin","tMax","maxWidth","j","cX","cY","t","width","Math","abs","pMin","pMax","currentSurface","p1","p2","diff","vector","acos"],"mappings":"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","sourcesContent":["import { rotate, difference, normalize } from '../../util/points';\n\nimport convexHullFunction from './monotoneChainConvexHull';\n\n/**\n * Computes the minimum bounding box around a binary image\n * https://www.researchgate.net/profile/Lennert_Den_Boer2/publication/303783472_A_Fast_Algorithm_for_Generating_a_Minimal_Bounding_Rectangle/links/5751a14108ae6807fafb2aa5.pdf\n * @memberof Image\n * @instance\n * @param {object} [options]\n * @param {Array<Array<number>>} [options.originalPoints]\n * @return {Array<Array<number>>}\n */\nexport default function minimalBoundingRectangle(options = {}) {\n  const { originalPoints = convexHullFunction.call(this) } = options;\n  if (originalPoints.length === 0) {\n    return [];\n  }\n\n  if (originalPoints.length === 1) {\n    return [\n      originalPoints[0],\n      originalPoints[0],\n      originalPoints[0],\n      originalPoints[0],\n    ];\n  }\n\n  const p = new Array(originalPoints.length);\n\n  let minSurface = +Infinity;\n  let minSurfaceAngle = 0;\n  let mbr;\n\n  for (let i = 0; i < p.length; i++) {\n    let angle = getAngle(originalPoints[i], originalPoints[(i + 1) % p.length]);\n\n    rotate(-angle, originalPoints, p);\n\n    // we rotate and translate so that this axe is in the bottom\n    let aX = p[i][0];\n    let aY = p[i][1];\n    let bX = p[(i + 1) % p.length][0];\n    let bY = p[(i + 1) % p.length][1];\n\n    let tUndefined = true;\n    let tMin = 0;\n    let tMax = 0;\n    let maxWidth = 0;\n    for (let j = 0; j < p.length; j++) {\n      let cX = p[j][0];\n      let cY = p[j][1];\n      let t = (cX - aX) / (bX - aX);\n      if (tUndefined === true) {\n        tUndefined = false;\n        tMin = t;\n        tMax = t;\n      } else {\n        if (t < tMin) tMin = t;\n        if (t > tMax) tMax = t;\n      }\n      let width = (-(bX - aX) * cY + bX * aY - bY * aX) / (bX - aX);\n\n      if (Math.abs(width) > Math.abs(maxWidth)) maxWidth = width;\n    }\n    let pMin = [aX + tMin * (bX - aX), aY];\n    let pMax = [aX + tMax * (bX - aX), aY];\n\n    let currentSurface = Math.abs(maxWidth * (tMin - tMax) * (bX - aX));\n\n    if (currentSurface < minSurface) {\n      minSurfaceAngle = angle;\n      minSurface = currentSurface;\n      mbr = [\n        pMin,\n        pMax,\n        [pMax[0], pMax[1] - maxWidth],\n        [pMin[0], pMin[1] - maxWidth],\n      ];\n    }\n  }\n  rotate(minSurfaceAngle, mbr, mbr);\n  return mbr;\n}\n\n// the angle that allows to make the line going through p1 and p2 horizontal\n// this is an optimized version because it assume one vector is horizontal\nfunction getAngle(p1, p2) {\n  let diff = difference(p2, p1);\n  let vector = normalize(diff);\n  let angle = Math.acos(vector[0]);\n  if (vector[1] < 0) return -angle;\n  return angle;\n}\n"]},"metadata":{},"sourceType":"module"}