{"ast":null,"code":"// We calculate all the border length with the neighbours\nexport default function commonBorderLength(roiMap) {\n  let data = roiMap.data;\n  let dx = [+1, 0, -1, 0];\n  let dy = [0, +1, 0, -1];\n  let minMax = roiMap.minMax;\n  let shift = -minMax.min;\n  let max = minMax.max + shift;\n  let borderInfo = [];\n\n  for (let i = 0; i <= max; i++) {\n    borderInfo.push(Object.create(null));\n  }\n\n  for (let x = 0; x < roiMap.width; x++) {\n    for (let y = 0; y < roiMap.height; y++) {\n      let target = x + y * roiMap.width;\n      let currentRoiID = data[target];\n\n      if (currentRoiID !== 0) {\n        // each pixel may only contribute one time to a border\n        let used = Object.create(null);\n        let isBorder = false;\n\n        for (let dir = 0; dir < 4; dir++) {\n          let newX = x + dx[dir];\n          let newY = y + dy[dir];\n\n          if (newX >= 0 && newY >= 0 && newX < roiMap.width && newY < roiMap.height) {\n            let neighbourRoiID = data[newX + newY * roiMap.width];\n\n            if (currentRoiID !== neighbourRoiID) {\n              isBorder = true;\n\n              if (neighbourRoiID !== 0 && used[neighbourRoiID] === undefined) {\n                used[neighbourRoiID] = true;\n\n                if (!borderInfo[neighbourRoiID + shift][currentRoiID]) {\n                  borderInfo[neighbourRoiID + shift][currentRoiID] = 1;\n                } else {\n                  borderInfo[neighbourRoiID + shift][currentRoiID]++;\n                }\n              }\n            }\n          } else {\n            isBorder = true;\n          }\n        } // we will also add an information to specify the border length\n\n\n        if (isBorder) {\n          if (!borderInfo[currentRoiID + shift][currentRoiID]) {\n            borderInfo[currentRoiID + shift][currentRoiID] = 1;\n          } else {\n            borderInfo[currentRoiID + shift][currentRoiID]++;\n          }\n        }\n      }\n    }\n  } // we convert now the result to an object for fast lookup and we will reshift the result\n\n\n  let result = {};\n\n  for (let i = 0; i < borderInfo.length; i++) {\n    if (Object.keys(borderInfo[i]).length > 0) {\n      result[i - shift] = borderInfo[i];\n    }\n  }\n\n  return result;\n}","map":{"version":3,"sources":["C:/Users/kuent/Documents/FinishDipshit/Creative/Ocean-Weather-Visualization/node_modules/image-js/src/image/roi/util/commonBorderLength.js"],"names":["commonBorderLength","roiMap","data","dx","dy","minMax","shift","min","max","borderInfo","i","push","Object","create","x","width","y","height","target","currentRoiID","used","isBorder","dir","newX","newY","neighbourRoiID","undefined","result","length","keys"],"mappings":"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","sourcesContent":["// We calculate all the border length with the neighbours\n\nexport default function commonBorderLength(roiMap) {\n  let data = roiMap.data;\n  let dx = [+1, 0, -1, 0];\n  let dy = [0, +1, 0, -1];\n\n  let minMax = roiMap.minMax;\n  let shift = -minMax.min;\n  let max = minMax.max + shift;\n  let borderInfo = [];\n  for (let i = 0; i <= max; i++) {\n    borderInfo.push(Object.create(null));\n  }\n\n  for (let x = 0; x < roiMap.width; x++) {\n    for (let y = 0; y < roiMap.height; y++) {\n      let target = x + y * roiMap.width;\n      let currentRoiID = data[target];\n      if (currentRoiID !== 0) {\n        // each pixel may only contribute one time to a border\n        let used = Object.create(null);\n        let isBorder = false;\n        for (let dir = 0; dir < 4; dir++) {\n          let newX = x + dx[dir];\n          let newY = y + dy[dir];\n          if (\n            newX >= 0 &&\n            newY >= 0 &&\n            newX < roiMap.width &&\n            newY < roiMap.height\n          ) {\n            let neighbourRoiID = data[newX + newY * roiMap.width];\n            if (currentRoiID !== neighbourRoiID) {\n              isBorder = true;\n              if (neighbourRoiID !== 0 && used[neighbourRoiID] === undefined) {\n                used[neighbourRoiID] = true;\n                if (!borderInfo[neighbourRoiID + shift][currentRoiID]) {\n                  borderInfo[neighbourRoiID + shift][currentRoiID] = 1;\n                } else {\n                  borderInfo[neighbourRoiID + shift][currentRoiID]++;\n                }\n              }\n            }\n          } else {\n            isBorder = true;\n          }\n        }\n        // we will also add an information to specify the border length\n        if (isBorder) {\n          if (!borderInfo[currentRoiID + shift][currentRoiID]) {\n            borderInfo[currentRoiID + shift][currentRoiID] = 1;\n          } else {\n            borderInfo[currentRoiID + shift][currentRoiID]++;\n          }\n        }\n      }\n    }\n  }\n\n  // we convert now the result to an object for fast lookup and we will reshift the result\n  let result = {};\n  for (let i = 0; i < borderInfo.length; i++) {\n    if (Object.keys(borderInfo[i]).length > 0) {\n      result[i - shift] = borderInfo[i];\n    }\n  }\n  return result;\n}\n"]},"metadata":{},"sourceType":"module"}