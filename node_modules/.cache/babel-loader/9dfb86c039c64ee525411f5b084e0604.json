{"ast":null,"code":"import Roi from './Roi';\n/**\n * A layer that is caracterised by a {@link RoiMap} and that will\n * generated automatically the corresponding ROI.\n * ROI should be a continuous\n * surface (it is not tested when it is not continous ...)\n * From the roiMap, the RoiLayer will create the corresponding\n * {@link ROI}.\n *\n * @class RoiLayer\n * @private\n * @param {Image} image\n * @param {object} [options]\n */\n\nexport default class RoiLayer {\n  constructor(roiMap, options) {\n    this.roiMap = roiMap;\n    this.options = options;\n    this.roi = this.createRoi();\n  }\n  /**\n   * Roi are created from a roiMap\n   * The roiMap contains mainty an array of identifiers that define\n   * for each data to which Roi it belongs\n   * @memberof RoiManager\n   * @instance\n   * @return {Roi[]}\n   */\n\n\n  createRoi() {\n    // we need to find all all the different IDs there is in the data\n    let data = this.roiMap.data;\n    let mapIDs = {};\n    this.roiMap.positive = 0;\n    this.roiMap.negative = 0;\n\n    for (let i = 0; i < data.length; i++) {\n      if (data[i] && !mapIDs[data[i]]) {\n        mapIDs[data[i]] = true;\n\n        if (data[i] > 0) {\n          this.roiMap.positive++;\n        } else {\n          this.roiMap.negative++;\n        }\n      }\n    }\n\n    let rois = {};\n\n    for (let mapID in mapIDs) {\n      rois[mapID] = new Roi(this.roiMap, mapID * 1);\n    }\n\n    let width = this.roiMap.width;\n    let height = this.roiMap.height;\n\n    for (let y = 0; y < height; y++) {\n      for (let x = 0; x < width; x++) {\n        let target = y * width + x;\n\n        if (data[target] !== 0) {\n          const mapID = data[target];\n          const roi = rois[mapID];\n\n          if (x < roi.minX) {\n            roi.minX = x;\n          }\n\n          if (x > roi.maxX) {\n            roi.maxX = x;\n          }\n\n          if (y < roi.minY) {\n            roi.minY = y;\n          }\n\n          if (y > roi.maxY) {\n            roi.maxY = y;\n          }\n\n          roi.meanX += x;\n          roi.meanY += y;\n          roi.surface++;\n        }\n      }\n    }\n\n    let roiArray = [];\n\n    for (let mapID in mapIDs) {\n      rois[mapID].meanX /= rois[mapID].surface;\n      rois[mapID].meanY /= rois[mapID].surface;\n      roiArray.push(rois[mapID]);\n    }\n\n    return roiArray;\n  }\n\n}","map":{"version":3,"sources":["C:/Users/kuent/Documents/FinishDipshit/Creative/Ocean-Weather-Visualization/node_modules/image-js/src/image/roi/RoiLayer.js"],"names":["Roi","RoiLayer","constructor","roiMap","options","roi","createRoi","data","mapIDs","positive","negative","i","length","rois","mapID","width","height","y","x","target","minX","maxX","minY","maxY","meanX","meanY","surface","roiArray","push"],"mappings":"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","sourcesContent":["import Roi from './Roi';\n\n/**\n * A layer that is caracterised by a {@link RoiMap} and that will\n * generated automatically the corresponding ROI.\n * ROI should be a continuous\n * surface (it is not tested when it is not continous ...)\n * From the roiMap, the RoiLayer will create the corresponding\n * {@link ROI}.\n *\n * @class RoiLayer\n * @private\n * @param {Image} image\n * @param {object} [options]\n */\nexport default class RoiLayer {\n  constructor(roiMap, options) {\n    this.roiMap = roiMap;\n    this.options = options;\n    this.roi = this.createRoi();\n  }\n\n  /**\n   * Roi are created from a roiMap\n   * The roiMap contains mainty an array of identifiers that define\n   * for each data to which Roi it belongs\n   * @memberof RoiManager\n   * @instance\n   * @return {Roi[]}\n   */\n  createRoi() {\n    // we need to find all all the different IDs there is in the data\n    let data = this.roiMap.data;\n    let mapIDs = {};\n    this.roiMap.positive = 0;\n    this.roiMap.negative = 0;\n\n    for (let i = 0; i < data.length; i++) {\n      if (data[i] && !mapIDs[data[i]]) {\n        mapIDs[data[i]] = true;\n        if (data[i] > 0) {\n          this.roiMap.positive++;\n        } else {\n          this.roiMap.negative++;\n        }\n      }\n    }\n\n    let rois = {};\n\n    for (let mapID in mapIDs) {\n      rois[mapID] = new Roi(this.roiMap, mapID * 1);\n    }\n    let width = this.roiMap.width;\n    let height = this.roiMap.height;\n\n    for (let y = 0; y < height; y++) {\n      for (let x = 0; x < width; x++) {\n        let target = y * width + x;\n        if (data[target] !== 0) {\n          const mapID = data[target];\n          const roi = rois[mapID];\n          if (x < roi.minX) {\n            roi.minX = x;\n          }\n          if (x > roi.maxX) {\n            roi.maxX = x;\n          }\n          if (y < roi.minY) {\n            roi.minY = y;\n          }\n          if (y > roi.maxY) {\n            roi.maxY = y;\n          }\n          roi.meanX += x;\n          roi.meanY += y;\n          roi.surface++;\n        }\n      }\n    }\n    let roiArray = [];\n    for (let mapID in mapIDs) {\n      rois[mapID].meanX /= rois[mapID].surface;\n      rois[mapID].meanY /= rois[mapID].surface;\n      roiArray.push(rois[mapID]);\n    }\n\n    return roiArray;\n  }\n}\n"]},"metadata":{},"sourceType":"module"}