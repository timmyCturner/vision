{"ast":null,"code":"import { direct, fft } from 'ml-matrix-convolution';\nimport { validateArrayOfChannels } from '../../util/channel';\nimport { validateKernel } from '../../util/kernel';\nimport Image from '../Image';\nimport { clamp } from '../internal/clamp';\nimport convolutionSeparable from './convolutionSeparable';\nimport getSeparatedKernel from './getSeparatedKernel';\n/**\n * @memberof Image\n * @instance\n * @param {Array<Array<number>>} kernel\n * @param {object} [options] - options\n * @param {Array} [options.channels] - Array of channels to treat. Defaults to all channels\n * @param {number} [options.bitDepth=this.bitDepth] - A new bit depth can be specified. This allows to use 32 bits to avoid clamping of floating-point numbers.\n * @param {boolean} [options.normalize=false]\n * @param {number} [options.divisor=1]\n * @param {string} [options.border='copy']\n * @param {string} [options.algorithm='auto'] - Either 'auto', 'direct', 'fft' or 'separable'. fft is much faster for large kernel.\n * If the separable algorithm is used, one must provide as kernel an array of two 1D kernels.\n * The 'auto' option will try to separate the kernel if that is possible.\n * @return {Image}\n */\n\nexport default function convolution(kernel, options = {}) {\n  let {\n    channels,\n    bitDepth,\n    normalize = false,\n    divisor = 1,\n    border = 'copy',\n    algorithm = 'auto'\n  } = options;\n  let createOptions = {};\n  if (bitDepth) createOptions.bitDepth = bitDepth;\n  let newImage = Image.createFrom(this, createOptions);\n  channels = validateArrayOfChannels(this, channels, true);\n\n  if (algorithm !== 'separable') {\n    ({\n      kernel\n    } = validateKernel(kernel));\n  } else if (!Array.isArray(kernel) || kernel.length !== 2) {\n    throw new RangeError('separable convolution requires two arrays of numbers to represent the kernel');\n  }\n\n  if (algorithm === 'auto') {\n    let separatedKernel = getSeparatedKernel(kernel);\n\n    if (separatedKernel !== null) {\n      algorithm = 'separable';\n      kernel = separatedKernel;\n    } else if ((kernel.length > 9 || kernel[0].length > 9) && this.width <= 4096 && this.height <= 4096) {\n      algorithm = 'fft';\n    } else {\n      algorithm = 'direct';\n    }\n  }\n\n  let halfHeight, halfWidth;\n\n  if (algorithm === 'separable') {\n    halfHeight = Math.floor(kernel[0].length / 2);\n    halfWidth = Math.floor(kernel[1].length / 2);\n  } else {\n    halfHeight = Math.floor(kernel.length / 2);\n    halfWidth = Math.floor(kernel[0].length / 2);\n  }\n\n  let clamped = newImage.isClamped;\n  let tmpData = new Array(this.height * this.width);\n  let index, x, y, channel, c, tmpResult;\n\n  for (channel = 0; channel < channels.length; channel++) {\n    c = channels[channel]; // Copy the channel in a single array\n\n    for (y = 0; y < this.height; y++) {\n      for (x = 0; x < this.width; x++) {\n        index = y * this.width + x;\n        tmpData[index] = this.data[index * this.channels + c];\n      }\n    }\n\n    if (algorithm === 'direct') {\n      tmpResult = direct(tmpData, kernel, {\n        rows: this.height,\n        cols: this.width,\n        normalize: normalize,\n        divisor: divisor\n      });\n    } else if (algorithm === 'separable') {\n      tmpResult = convolutionSeparable(tmpData, kernel, this.width, this.height);\n\n      if (normalize) {\n        divisor = 0;\n\n        for (let i = 0; i < kernel[0].length; i++) {\n          for (let j = 0; j < kernel[1].length; j++) {\n            divisor += kernel[0][i] * kernel[1][j];\n          }\n        }\n      }\n\n      if (divisor !== 1) {\n        for (let i = 0; i < tmpResult.length; i++) {\n          tmpResult[i] /= divisor;\n        }\n      }\n    } else {\n      tmpResult = fft(tmpData, kernel, {\n        rows: this.height,\n        cols: this.width,\n        normalize: normalize,\n        divisor: divisor\n      });\n    } // Copy the result to the output image\n\n\n    for (y = 0; y < this.height; y++) {\n      for (x = 0; x < this.width; x++) {\n        index = y * this.width + x;\n\n        if (clamped) {\n          newImage.data[index * this.channels + c] = clamp(tmpResult[index], newImage);\n        } else {\n          newImage.data[index * this.channels + c] = tmpResult[index];\n        }\n      }\n    }\n  } // if the kernel was not applied on the alpha channel we just copy it\n  // TODO: in general we should copy the channels that where not changed\n  // TODO: probably we should just copy the image at the beginning ?\n\n\n  if (this.alpha && !channels.includes(this.channels)) {\n    for (x = this.components; x < this.data.length; x = x + this.channels) {\n      newImage.data[x] = this.data[x];\n    }\n  } // I only can have 3 types of borders:\n  //  1. Considering the image as periodic: periodic\n  //  2. Extend the interior borders: copy\n  //  3. fill with a color: set\n\n\n  if (border !== 'periodic') {\n    newImage.setBorder({\n      size: [halfWidth, halfHeight],\n      algorithm: border\n    });\n  }\n\n  return newImage;\n}","map":{"version":3,"sources":["C:/Users/kuent/Documents/FinishDipshit/Creative/Ocean-Weather-Visualization/node_modules/image-js/src/image/operator/convolution.js"],"names":["direct","fft","validateArrayOfChannels","validateKernel","Image","clamp","convolutionSeparable","getSeparatedKernel","convolution","kernel","options","channels","bitDepth","normalize","divisor","border","algorithm","createOptions","newImage","createFrom","Array","isArray","length","RangeError","separatedKernel","width","height","halfHeight","halfWidth","Math","floor","clamped","isClamped","tmpData","index","x","y","channel","c","tmpResult","data","rows","cols","i","j","alpha","includes","components","setBorder","size"],"mappings":"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","sourcesContent":["import { direct, fft } from 'ml-matrix-convolution';\n\nimport { validateArrayOfChannels } from '../../util/channel';\nimport { validateKernel } from '../../util/kernel';\nimport Image from '../Image';\nimport { clamp } from '../internal/clamp';\n\nimport convolutionSeparable from './convolutionSeparable';\nimport getSeparatedKernel from './getSeparatedKernel';\n\n/**\n * @memberof Image\n * @instance\n * @param {Array<Array<number>>} kernel\n * @param {object} [options] - options\n * @param {Array} [options.channels] - Array of channels to treat. Defaults to all channels\n * @param {number} [options.bitDepth=this.bitDepth] - A new bit depth can be specified. This allows to use 32 bits to avoid clamping of floating-point numbers.\n * @param {boolean} [options.normalize=false]\n * @param {number} [options.divisor=1]\n * @param {string} [options.border='copy']\n * @param {string} [options.algorithm='auto'] - Either 'auto', 'direct', 'fft' or 'separable'. fft is much faster for large kernel.\n * If the separable algorithm is used, one must provide as kernel an array of two 1D kernels.\n * The 'auto' option will try to separate the kernel if that is possible.\n * @return {Image}\n */\nexport default function convolution(kernel, options = {}) {\n  let {\n    channels,\n    bitDepth,\n    normalize = false,\n    divisor = 1,\n    border = 'copy',\n    algorithm = 'auto',\n  } = options;\n  let createOptions = {};\n  if (bitDepth) createOptions.bitDepth = bitDepth;\n  let newImage = Image.createFrom(this, createOptions);\n\n  channels = validateArrayOfChannels(this, channels, true);\n\n  if (algorithm !== 'separable') {\n    ({ kernel } = validateKernel(kernel));\n  } else if (!Array.isArray(kernel) || kernel.length !== 2) {\n    throw new RangeError(\n      'separable convolution requires two arrays of numbers to represent the kernel',\n    );\n  }\n\n  if (algorithm === 'auto') {\n    let separatedKernel = getSeparatedKernel(kernel);\n    if (separatedKernel !== null) {\n      algorithm = 'separable';\n      kernel = separatedKernel;\n    } else if (\n      (kernel.length > 9 || kernel[0].length > 9) &&\n      this.width <= 4096 &&\n      this.height <= 4096\n    ) {\n      algorithm = 'fft';\n    } else {\n      algorithm = 'direct';\n    }\n  }\n\n  let halfHeight, halfWidth;\n  if (algorithm === 'separable') {\n    halfHeight = Math.floor(kernel[0].length / 2);\n    halfWidth = Math.floor(kernel[1].length / 2);\n  } else {\n    halfHeight = Math.floor(kernel.length / 2);\n    halfWidth = Math.floor(kernel[0].length / 2);\n  }\n  let clamped = newImage.isClamped;\n\n  let tmpData = new Array(this.height * this.width);\n  let index, x, y, channel, c, tmpResult;\n  for (channel = 0; channel < channels.length; channel++) {\n    c = channels[channel];\n    // Copy the channel in a single array\n    for (y = 0; y < this.height; y++) {\n      for (x = 0; x < this.width; x++) {\n        index = y * this.width + x;\n        tmpData[index] = this.data[index * this.channels + c];\n      }\n    }\n    if (algorithm === 'direct') {\n      tmpResult = direct(tmpData, kernel, {\n        rows: this.height,\n        cols: this.width,\n        normalize: normalize,\n        divisor: divisor,\n      });\n    } else if (algorithm === 'separable') {\n      tmpResult = convolutionSeparable(\n        tmpData,\n        kernel,\n        this.width,\n        this.height,\n      );\n      if (normalize) {\n        divisor = 0;\n        for (let i = 0; i < kernel[0].length; i++) {\n          for (let j = 0; j < kernel[1].length; j++) {\n            divisor += kernel[0][i] * kernel[1][j];\n          }\n        }\n      }\n      if (divisor !== 1) {\n        for (let i = 0; i < tmpResult.length; i++) {\n          tmpResult[i] /= divisor;\n        }\n      }\n    } else {\n      tmpResult = fft(tmpData, kernel, {\n        rows: this.height,\n        cols: this.width,\n        normalize: normalize,\n        divisor: divisor,\n      });\n    }\n\n    // Copy the result to the output image\n    for (y = 0; y < this.height; y++) {\n      for (x = 0; x < this.width; x++) {\n        index = y * this.width + x;\n        if (clamped) {\n          newImage.data[index * this.channels + c] = clamp(\n            tmpResult[index],\n            newImage,\n          );\n        } else {\n          newImage.data[index * this.channels + c] = tmpResult[index];\n        }\n      }\n    }\n  }\n  // if the kernel was not applied on the alpha channel we just copy it\n  // TODO: in general we should copy the channels that where not changed\n  // TODO: probably we should just copy the image at the beginning ?\n  if (this.alpha && !channels.includes(this.channels)) {\n    for (x = this.components; x < this.data.length; x = x + this.channels) {\n      newImage.data[x] = this.data[x];\n    }\n  }\n\n  // I only can have 3 types of borders:\n  //  1. Considering the image as periodic: periodic\n  //  2. Extend the interior borders: copy\n  //  3. fill with a color: set\n  if (border !== 'periodic') {\n    newImage.setBorder({ size: [halfWidth, halfHeight], algorithm: border });\n  }\n\n  return newImage;\n}\n"]},"metadata":{},"sourceType":"module"}