{"ast":null,"code":"import { ascending as sortAsc } from 'num-sort';\nimport { validateArrayOfChannels } from '../../util/channel';\nimport Image from '../Image';\n/**\n * Each pixel of the image becomes the median of the neighbor pixels.\n * @memberof Image\n * @instance\n * @param {object} options\n * @param {SelectedChannels} [options.channels] - Specify which channels should be processed.\n * @param {number} [options.radius=1] - Distance of the square to take the mean of.\n * @param {string} [options.border='copy'] - Algorithm that will be applied after to deal with borders.\n * @return {Image}\n */\n\nexport default function medianFilter(options = {}) {\n  let {\n    radius = 1,\n    border = 'copy',\n    channels\n  } = options;\n  this.checkProcessable('medianFilter', {\n    bitDepth: [8, 16]\n  });\n\n  if (radius < 1) {\n    throw new Error('radius must be greater than 0');\n  }\n\n  channels = validateArrayOfChannels(this, channels, true);\n  let kWidth = radius;\n  let kHeight = radius;\n  let newImage = Image.createFrom(this);\n  let size = (kWidth * 2 + 1) * (kHeight * 2 + 1);\n  let middle = Math.floor(size / 2);\n  let kernel = new Array(size);\n\n  for (let channel = 0; channel < channels.length; channel++) {\n    let c = channels[channel];\n\n    for (let y = kHeight; y < this.height - kHeight; y++) {\n      for (let x = kWidth; x < this.width - kWidth; x++) {\n        let n = 0;\n\n        for (let j = -kHeight; j <= kHeight; j++) {\n          for (let i = -kWidth; i <= kWidth; i++) {\n            let index = ((y + j) * this.width + x + i) * this.channels + c;\n            kernel[n++] = this.data[index];\n          }\n        }\n\n        let index = (y * this.width + x) * this.channels + c;\n        let newValue = kernel.sort(sortAsc)[middle];\n        newImage.data[index] = newValue;\n      }\n    }\n  }\n\n  if (this.alpha && !channels.includes(this.channels)) {\n    for (let i = this.components; i < this.data.length; i = i + this.channels) {\n      newImage.data[i] = this.data[i];\n    }\n  }\n\n  newImage.setBorder({\n    size: [kWidth, kHeight],\n    algorithm: border\n  });\n  return newImage;\n}","map":{"version":3,"sources":["C:/Users/kuent/Documents/FinishDipshit/Creative/Ocean-Weather-Visualization/node_modules/image-js/src/image/filter/medianFilter.js"],"names":["ascending","sortAsc","validateArrayOfChannels","Image","medianFilter","options","radius","border","channels","checkProcessable","bitDepth","Error","kWidth","kHeight","newImage","createFrom","size","middle","Math","floor","kernel","Array","channel","length","c","y","height","x","width","n","j","i","index","data","newValue","sort","alpha","includes","components","setBorder","algorithm"],"mappings":"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","sourcesContent":["import { ascending as sortAsc } from 'num-sort';\n\nimport { validateArrayOfChannels } from '../../util/channel';\nimport Image from '../Image';\n\n/**\n * Each pixel of the image becomes the median of the neighbor pixels.\n * @memberof Image\n * @instance\n * @param {object} options\n * @param {SelectedChannels} [options.channels] - Specify which channels should be processed.\n * @param {number} [options.radius=1] - Distance of the square to take the mean of.\n * @param {string} [options.border='copy'] - Algorithm that will be applied after to deal with borders.\n * @return {Image}\n */\nexport default function medianFilter(options = {}) {\n  let { radius = 1, border = 'copy', channels } = options;\n\n  this.checkProcessable('medianFilter', {\n    bitDepth: [8, 16],\n  });\n\n  if (radius < 1) {\n    throw new Error('radius must be greater than 0');\n  }\n\n  channels = validateArrayOfChannels(this, channels, true);\n\n  let kWidth = radius;\n  let kHeight = radius;\n  let newImage = Image.createFrom(this);\n\n  let size = (kWidth * 2 + 1) * (kHeight * 2 + 1);\n  let middle = Math.floor(size / 2);\n  let kernel = new Array(size);\n\n  for (let channel = 0; channel < channels.length; channel++) {\n    let c = channels[channel];\n    for (let y = kHeight; y < this.height - kHeight; y++) {\n      for (let x = kWidth; x < this.width - kWidth; x++) {\n        let n = 0;\n        for (let j = -kHeight; j <= kHeight; j++) {\n          for (let i = -kWidth; i <= kWidth; i++) {\n            let index = ((y + j) * this.width + x + i) * this.channels + c;\n            kernel[n++] = this.data[index];\n          }\n        }\n        let index = (y * this.width + x) * this.channels + c;\n        let newValue = kernel.sort(sortAsc)[middle];\n\n        newImage.data[index] = newValue;\n      }\n    }\n  }\n  if (this.alpha && !channels.includes(this.channels)) {\n    for (let i = this.components; i < this.data.length; i = i + this.channels) {\n      newImage.data[i] = this.data[i];\n    }\n  }\n\n  newImage.setBorder({ size: [kWidth, kHeight], algorithm: border });\n\n  return newImage;\n}\n"]},"metadata":{},"sourceType":"module"}