{"ast":null,"code":"import bitMethods from './core/bitMethods';\nimport checkProcessable from './core/checkProcessable';\nimport exportMethods from './core/export';\nimport { extendMethod, extendProperty } from './core/extend';\nimport getRGBAData from './core/getRGBAData';\nimport { getKind, verifyKindDefinition, createPixelArray, getTheoreticalPixelArraySize } from './core/kind';\nimport { RGBA } from './core/kindNames';\nimport load from './core/load';\nimport valueMethods from './core/valueMethods';\nimport extend from './extend';\nimport getImageParameters from './internal/getImageParameters';\nimport RoiManager from './roi/manager';\nconst objectToString = Object.prototype.toString;\n/**\n * Class representing an image.\n * This class allows to manipulate easily images directly in the browser or in node.\n *\n * This library is designed to deal with scientific images (8 or 16 bit depth) and will be able to open\n * and process jpeg, png and uncompressed tiff images. It is designed to work in the browser\n * as on the server side in node.\n *\n * An image is characterized by:\n * * width and height\n * * colorModel (RGB, HSL, CMYK, GREY, ...)\n * * components: number of components, Grey scale images will have 1 component while RGB will have 3 and CMYK 4.\n * * alpha: 0 or 1 depending if there is an alpha channel. The\n *      alpha channel define the opacity of each pixel\n * * channels: number of channels (components + alpha)\n * * bitDepth : number of bits to define the intensity of a point.\n *      The values may be 1 for a binary image (mask), 8 for a normal image (each\n *      channel contains values between 0 and 255) and 16 for scientific images\n *      (each channel contains values between 0 and 65535).\n *      The png library and tiff library included in image-js allow to deal correctly with\n *      8 and 16 bit depth images.\n * * position : an array of 2 elements that allows to define a relative position\n *      to a parent image. This will be used in a crop or in the management\n *      of Region Of Interests (Roi) for exmaple\n * * data : an array that contains all the points of the image.\n *      Depending the bitDepth Uint8Array (1 bit), Uint8Array (8 bits),\n *      Uint16Array (16 bits), Float32Array (32 bits)\n *\n * In an image there are pixels and points:\n * * A pixel is an array that has as size the number of channels\n * and that contains all the values that define a particular pixel of the image.\n * * A point is an array of 2 elements that contains the x / y coordinate\n * of a specific pixel of the image\n *\n *\n * @class Image\n * @param {number} [width=1]\n * @param {number} [height=1]\n * @param {Array} [data] - Image data to load\n * @param {object} [options]\n *\n *\n * @example\n * // JavaScript code using Node.js to get some info about the image.\n * // We load the library that was installed using 'npm install image-js'\n * const { Image } = require('image-js');\n *\n * // Loading an image is asynchronous and will return a Promise.\n * Image.load('cat.jpg').then(function (image) {\n *   console.log('Width', image.width);\n *   console.log('Height', image.height);\n *   console.log('colorModel', image.colorModel);\n *   console.log('components', image.components);\n *   console.log('alpha', image.alpha);\n *   console.log('channels', image.channels);\n *   console.log('bitDepth', image.bitDepth);\n * });\n *\n * @example\n * // Convert an image to greyscale\n * const { Image } = require('image-js');\n *\n * Image.load('cat.jpg').then(function (image) {\n *   var grey = image.grey();\n *   grey.save('cat-grey.jpg');\n * });\n *\n * @example\n * // Split an RGB image in its components\n * const { Image } = require('image-js');\n *\n * Image.load('cat.jpg').then(function (image) {\n *   var components = image.split();\n *   components[0].save('cat-red.jpg');\n *   components[1].save('cat-green.jpg');\n *   components[2].save('cat-blur.jpg');\n * });\n *\n *\n * @example\n * // For this example you will need the picture of an ecstasy pill that is available on\n * // wget https://raw.githubusercontent.com/image-js/core/854e70f50d63cc73d2dde1d2020fe61ba1b5ec05/test/img/xtc.png // the goal is to isolate the picture and to get a RGB histogram of the pill.\n * // Practically this allows to classify pills based on the histogram similarity\n * // This work was published at: http://dx.doi.org/10.1016/j.forsciint.2012.10.004\n *\n * const { Image } = require('image-js');\n *\n * const image = await Image.load('xtc.png');\n *\n * const grey = image.grey({\n *   algorithm:'lightness'\n * });\n * // we create a mask, which is basically a binary image\n * // a mask has as source a grey image and we will decide how to determine\n * // the threshold to define what is white and what is black\n * var mask = grey.mask({\n *   algorithm: 'li'\n * });\n *\n * // it is possible to create an array of Region Of Interest (Roi) using\n * // the RoiManager. A RoiManager will be applied on the original image\n * // in order to be able to extract from the original image the regions\n *\n * // the result of this console.log result can diretly be pasted\n * // in the browser\n * // console.log(mask.toDataURL());\n *\n *\n * var manager = image.getRoiManager();\n * manager.fromMask(mask);\n * var rois = manager.getRoi({\n *   positive: true,\n *   negative: false,\n *   minSurface: 100\n * });\n *\n * // console.log(rois);\n *\n * // we can sort teh rois by surface\n * // for demonstration we use an arrow function\n * rois.sort((a, b) => b.surface - a.surface);\n *\n * // the first Roi (the biggest is expected to be the pill)\n *\n * var pillMask = rois[0].getMask({\n *   scale: 0.7   // we will scale down the mask to take just the center of the pill and avoid border effects\n * });\n *\n * // image-js remembers the parent of the image and the relative\n * // position of a derived image. This is the case for a crop as\n * // well as for Roi\n *\n * var pill = image.extract(pillMask);\n * pill.save('pill.jpg');\n *\n * var histogram = pill.getHistograms({ maxSlots: 16 });\n *\n * console.log(histogram);\n *\n * @example\n * // Example of use of IJS in the browser\n *\n * <script>\n *  var canvas = document.getElementById('myCanvasID');\n *  var image = IJS.fromCanvas(canvas);\n * </script>\n */\n\nexport default class Image {\n  constructor(width, height, data, options) {\n    if (arguments.length === 1) {\n      options = width;\n      ({\n        width,\n        height,\n        data\n      } = options);\n    } else if (data && !data.length) {\n      options = data;\n      ({\n        data\n      } = options);\n    }\n\n    if (width === undefined) width = 1;\n    if (height === undefined) height = 1;\n    if (options === undefined) options = {};\n\n    if (typeof options !== 'object' || options === null) {\n      throw new TypeError('options must be an object');\n    }\n\n    if (!Number.isInteger(width) || width <= 0) {\n      throw new RangeError('width must be a positive integer');\n    }\n\n    if (!Number.isInteger(height) || height <= 0) {\n      throw new RangeError('height must be a positive integer');\n    }\n\n    const {\n      kind = RGBA\n    } = options;\n\n    if (typeof kind !== 'string') {\n      throw new TypeError('kind must be a string');\n    }\n\n    const theKind = getKind(kind);\n    const kindDefinition = Object.assign({}, options);\n\n    for (const prop in theKind) {\n      if (kindDefinition[prop] === undefined) {\n        kindDefinition[prop] = theKind[prop];\n      }\n    }\n\n    verifyKindDefinition(kindDefinition);\n    const {\n      components,\n      bitDepth,\n      colorModel\n    } = kindDefinition;\n    const alpha = kindDefinition.alpha + 0;\n    const size = width * height;\n    const channels = components + alpha;\n    const maxValue = bitDepth === 32 ? Number.MAX_VALUE : 2 ** bitDepth - 1;\n\n    if (data === undefined) {\n      data = createPixelArray(size, components, alpha, channels, bitDepth, maxValue);\n    } else {\n      const expectedLength = getTheoreticalPixelArraySize(size, channels, bitDepth);\n\n      if (data.length !== expectedLength) {\n        throw new RangeError(`incorrect data size: ${data.length}. Should be ${expectedLength}`);\n      }\n    }\n    /**\n     * Width of the image.\n     * @member {number}\n     */\n\n\n    this.width = width;\n    /**\n     * Height of the image.\n     * @member {number}\n     */\n\n    this.height = height;\n    /**\n     * Typed array holding the image data.\n     * @member {TypedArray}\n     */\n\n    this.data = data;\n    /**\n     * Total number of pixels (width * height).\n     * @member {number}\n     */\n\n    this.size = size;\n    /**\n     * Number of color channels in the image.\n     * A grey image has 1 component. An RGB image has 3 components.\n     * @member {number}\n     */\n\n    this.components = components;\n    /**\n     * Alpha is 1 if there is an alpha channel, 0 otherwise.\n     * @member {number}\n     */\n\n    this.alpha = alpha;\n    /**\n     * Number of bits per value in each channel.\n     * @member {number}\n     */\n\n    this.bitDepth = bitDepth;\n    /**\n     * Maximum value that a pixel can have.\n     * @member {number}\n     */\n\n    this.maxValue = maxValue;\n    /**\n     * Color model of the image.\n     * @member {ColorModel}\n     */\n\n    this.colorModel = colorModel;\n    /**\n     * Total number of channels. Is equal to `image.components + image.alpha`.\n     * @member {number}\n     */\n\n    this.channels = channels;\n    /**\n     * Metadata associated with the image.\n     * @member {object}\n     */\n\n    this.meta = options.meta || {}; // TODO review those props\n\n    Object.defineProperty(this, 'parent', {\n      enumerable: false,\n      writable: true,\n      configurable: true,\n      value: options.parent || null\n    });\n    this.position = options.position || [0, 0];\n    this.computed = null;\n    this.sizes = [this.width, this.height];\n    this.multiplierX = this.channels;\n    this.multiplierY = this.channels * this.width;\n    this.isClamped = this.bitDepth < 32;\n    this.borderSizes = [0, 0]; // when a filter creates a border, it may have impact on future processing like Roi\n  }\n\n  get [Symbol.toStringTag]() {\n    return 'IJSImage';\n  }\n\n  static isImage(object) {\n    return objectToString.call(object) === '[object IJSImage]';\n  }\n  /**\n   * Creates an image from an HTML Canvas object\n   * @param {Canvas} canvas\n   * @return {Image}\n   */\n\n\n  static fromCanvas(canvas) {\n    const ctx = canvas.getContext('2d');\n    const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);\n    return new Image(imageData.width, imageData.height, imageData.data);\n  }\n  /**\n   * Create a new Image based on the characteristics of another one.\n   * @param {Image} other\n   * @param {object} [options] - Override options to change some parameters\n   * @return {Image}\n   * @example\n   * const newImage = Image.createFrom(image, { width: 100 });\n   */\n\n\n  static createFrom(other, options) {\n    const newOptions = getImageParameters(other);\n    Object.assign(newOptions, {\n      parent: other,\n      position: [0, 0]\n    }, options);\n    return new Image(newOptions);\n  }\n  /**\n   * Create a new manager for regions of interest based on the current image.\n   * @param {object} [options]\n   * @return {RoiManager}\n   */\n\n\n  getRoiManager(options) {\n    return new RoiManager(this, options);\n  }\n  /**\n   * Create a copy a the current image, including its data.\n   * @instance\n   * @return {Image}\n   */\n\n\n  clone() {\n    const newData = this.data.slice();\n    return new Image(this.width, this.height, newData, this);\n  }\n\n  apply(filter) {\n    for (let y = 0; y < this.height; y++) {\n      for (let x = 0; x < this.width; x++) {\n        let index = (y * this.width + x) * this.channels;\n        filter.call(this, index);\n      }\n    }\n  }\n\n}\nvalueMethods(Image);\nbitMethods(Image);\nexportMethods(Image);\nImage.prototype.checkProcessable = checkProcessable;\nImage.prototype.getRGBAData = getRGBAData;\nImage.load = load;\nImage.extendMethod = extendMethod;\nImage.extendProperty = extendProperty;\nextend(Image);","map":{"version":3,"sources":["C:/Users/kuent/Documents/FinishDipshit/Creative/Ocean-Weather-Visualization/node_modules/image-js/src/image/Image.js"],"names":["bitMethods","checkProcessable","exportMethods","extendMethod","extendProperty","getRGBAData","getKind","verifyKindDefinition","createPixelArray","getTheoreticalPixelArraySize","RGBA","load","valueMethods","extend","getImageParameters","RoiManager","objectToString","Object","prototype","toString","Image","constructor","width","height","data","options","arguments","length","undefined","TypeError","Number","isInteger","RangeError","kind","theKind","kindDefinition","assign","prop","components","bitDepth","colorModel","alpha","size","channels","maxValue","MAX_VALUE","expectedLength","meta","defineProperty","enumerable","writable","configurable","value","parent","position","computed","sizes","multiplierX","multiplierY","isClamped","borderSizes","Symbol","toStringTag","isImage","object","call","fromCanvas","canvas","ctx","getContext","imageData","getImageData","createFrom","other","newOptions","getRoiManager","clone","newData","slice","apply","filter","y","x","index"],"mappings":"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","sourcesContent":["import bitMethods from './core/bitMethods';\nimport checkProcessable from './core/checkProcessable';\nimport exportMethods from './core/export';\nimport { extendMethod, extendProperty } from './core/extend';\nimport getRGBAData from './core/getRGBAData';\nimport {\n  getKind,\n  verifyKindDefinition,\n  createPixelArray,\n  getTheoreticalPixelArraySize,\n} from './core/kind';\nimport { RGBA } from './core/kindNames';\nimport load from './core/load';\nimport valueMethods from './core/valueMethods';\nimport extend from './extend';\nimport getImageParameters from './internal/getImageParameters';\nimport RoiManager from './roi/manager';\n\nconst objectToString = Object.prototype.toString;\n\n/**\n * Class representing an image.\n * This class allows to manipulate easily images directly in the browser or in node.\n *\n * This library is designed to deal with scientific images (8 or 16 bit depth) and will be able to open\n * and process jpeg, png and uncompressed tiff images. It is designed to work in the browser\n * as on the server side in node.\n *\n * An image is characterized by:\n * * width and height\n * * colorModel (RGB, HSL, CMYK, GREY, ...)\n * * components: number of components, Grey scale images will have 1 component while RGB will have 3 and CMYK 4.\n * * alpha: 0 or 1 depending if there is an alpha channel. The\n *      alpha channel define the opacity of each pixel\n * * channels: number of channels (components + alpha)\n * * bitDepth : number of bits to define the intensity of a point.\n *      The values may be 1 for a binary image (mask), 8 for a normal image (each\n *      channel contains values between 0 and 255) and 16 for scientific images\n *      (each channel contains values between 0 and 65535).\n *      The png library and tiff library included in image-js allow to deal correctly with\n *      8 and 16 bit depth images.\n * * position : an array of 2 elements that allows to define a relative position\n *      to a parent image. This will be used in a crop or in the management\n *      of Region Of Interests (Roi) for exmaple\n * * data : an array that contains all the points of the image.\n *      Depending the bitDepth Uint8Array (1 bit), Uint8Array (8 bits),\n *      Uint16Array (16 bits), Float32Array (32 bits)\n *\n * In an image there are pixels and points:\n * * A pixel is an array that has as size the number of channels\n * and that contains all the values that define a particular pixel of the image.\n * * A point is an array of 2 elements that contains the x / y coordinate\n * of a specific pixel of the image\n *\n *\n * @class Image\n * @param {number} [width=1]\n * @param {number} [height=1]\n * @param {Array} [data] - Image data to load\n * @param {object} [options]\n *\n *\n * @example\n * // JavaScript code using Node.js to get some info about the image.\n * // We load the library that was installed using 'npm install image-js'\n * const { Image } = require('image-js');\n *\n * // Loading an image is asynchronous and will return a Promise.\n * Image.load('cat.jpg').then(function (image) {\n *   console.log('Width', image.width);\n *   console.log('Height', image.height);\n *   console.log('colorModel', image.colorModel);\n *   console.log('components', image.components);\n *   console.log('alpha', image.alpha);\n *   console.log('channels', image.channels);\n *   console.log('bitDepth', image.bitDepth);\n * });\n *\n * @example\n * // Convert an image to greyscale\n * const { Image } = require('image-js');\n *\n * Image.load('cat.jpg').then(function (image) {\n *   var grey = image.grey();\n *   grey.save('cat-grey.jpg');\n * });\n *\n * @example\n * // Split an RGB image in its components\n * const { Image } = require('image-js');\n *\n * Image.load('cat.jpg').then(function (image) {\n *   var components = image.split();\n *   components[0].save('cat-red.jpg');\n *   components[1].save('cat-green.jpg');\n *   components[2].save('cat-blur.jpg');\n * });\n *\n *\n * @example\n * // For this example you will need the picture of an ecstasy pill that is available on\n * // wget https://raw.githubusercontent.com/image-js/core/854e70f50d63cc73d2dde1d2020fe61ba1b5ec05/test/img/xtc.png // the goal is to isolate the picture and to get a RGB histogram of the pill.\n * // Practically this allows to classify pills based on the histogram similarity\n * // This work was published at: http://dx.doi.org/10.1016/j.forsciint.2012.10.004\n *\n * const { Image } = require('image-js');\n *\n * const image = await Image.load('xtc.png');\n *\n * const grey = image.grey({\n *   algorithm:'lightness'\n * });\n * // we create a mask, which is basically a binary image\n * // a mask has as source a grey image and we will decide how to determine\n * // the threshold to define what is white and what is black\n * var mask = grey.mask({\n *   algorithm: 'li'\n * });\n *\n * // it is possible to create an array of Region Of Interest (Roi) using\n * // the RoiManager. A RoiManager will be applied on the original image\n * // in order to be able to extract from the original image the regions\n *\n * // the result of this console.log result can diretly be pasted\n * // in the browser\n * // console.log(mask.toDataURL());\n *\n *\n * var manager = image.getRoiManager();\n * manager.fromMask(mask);\n * var rois = manager.getRoi({\n *   positive: true,\n *   negative: false,\n *   minSurface: 100\n * });\n *\n * // console.log(rois);\n *\n * // we can sort teh rois by surface\n * // for demonstration we use an arrow function\n * rois.sort((a, b) => b.surface - a.surface);\n *\n * // the first Roi (the biggest is expected to be the pill)\n *\n * var pillMask = rois[0].getMask({\n *   scale: 0.7   // we will scale down the mask to take just the center of the pill and avoid border effects\n * });\n *\n * // image-js remembers the parent of the image and the relative\n * // position of a derived image. This is the case for a crop as\n * // well as for Roi\n *\n * var pill = image.extract(pillMask);\n * pill.save('pill.jpg');\n *\n * var histogram = pill.getHistograms({ maxSlots: 16 });\n *\n * console.log(histogram);\n *\n * @example\n * // Example of use of IJS in the browser\n *\n * <script>\n *  var canvas = document.getElementById('myCanvasID');\n *  var image = IJS.fromCanvas(canvas);\n * </script>\n */\nexport default class Image {\n  constructor(width, height, data, options) {\n    if (arguments.length === 1) {\n      options = width;\n      ({ width, height, data } = options);\n    } else if (data && !data.length) {\n      options = data;\n      ({ data } = options);\n    }\n    if (width === undefined) width = 1;\n    if (height === undefined) height = 1;\n    if (options === undefined) options = {};\n\n    if (typeof options !== 'object' || options === null) {\n      throw new TypeError('options must be an object');\n    }\n\n    if (!Number.isInteger(width) || width <= 0) {\n      throw new RangeError('width must be a positive integer');\n    }\n    if (!Number.isInteger(height) || height <= 0) {\n      throw new RangeError('height must be a positive integer');\n    }\n\n    const { kind = RGBA } = options;\n    if (typeof kind !== 'string') {\n      throw new TypeError('kind must be a string');\n    }\n    const theKind = getKind(kind);\n    const kindDefinition = Object.assign({}, options);\n    for (const prop in theKind) {\n      if (kindDefinition[prop] === undefined) {\n        kindDefinition[prop] = theKind[prop];\n      }\n    }\n    verifyKindDefinition(kindDefinition);\n\n    const { components, bitDepth, colorModel } = kindDefinition;\n    const alpha = kindDefinition.alpha + 0;\n    const size = width * height;\n    const channels = components + alpha;\n    const maxValue = bitDepth === 32 ? Number.MAX_VALUE : 2 ** bitDepth - 1;\n\n    if (data === undefined) {\n      data = createPixelArray(\n        size,\n        components,\n        alpha,\n        channels,\n        bitDepth,\n        maxValue,\n      );\n    } else {\n      const expectedLength = getTheoreticalPixelArraySize(\n        size,\n        channels,\n        bitDepth,\n      );\n      if (data.length !== expectedLength) {\n        throw new RangeError(\n          `incorrect data size: ${data.length}. Should be ${expectedLength}`,\n        );\n      }\n    }\n\n    /**\n     * Width of the image.\n     * @member {number}\n     */\n    this.width = width;\n\n    /**\n     * Height of the image.\n     * @member {number}\n     */\n    this.height = height;\n\n    /**\n     * Typed array holding the image data.\n     * @member {TypedArray}\n     */\n    this.data = data;\n\n    /**\n     * Total number of pixels (width * height).\n     * @member {number}\n     */\n    this.size = size;\n\n    /**\n     * Number of color channels in the image.\n     * A grey image has 1 component. An RGB image has 3 components.\n     * @member {number}\n     */\n    this.components = components;\n\n    /**\n     * Alpha is 1 if there is an alpha channel, 0 otherwise.\n     * @member {number}\n     */\n    this.alpha = alpha;\n\n    /**\n     * Number of bits per value in each channel.\n     * @member {number}\n     */\n    this.bitDepth = bitDepth;\n\n    /**\n     * Maximum value that a pixel can have.\n     * @member {number}\n     */\n    this.maxValue = maxValue;\n\n    /**\n     * Color model of the image.\n     * @member {ColorModel}\n     */\n    this.colorModel = colorModel;\n\n    /**\n     * Total number of channels. Is equal to `image.components + image.alpha`.\n     * @member {number}\n     */\n    this.channels = channels;\n\n    /**\n     * Metadata associated with the image.\n     * @member {object}\n     */\n    this.meta = options.meta || {};\n\n    // TODO review those props\n    Object.defineProperty(this, 'parent', {\n      enumerable: false,\n      writable: true,\n      configurable: true,\n      value: options.parent || null,\n    });\n    this.position = options.position || [0, 0];\n\n    this.computed = null;\n    this.sizes = [this.width, this.height];\n    this.multiplierX = this.channels;\n    this.multiplierY = this.channels * this.width;\n    this.isClamped = this.bitDepth < 32;\n    this.borderSizes = [0, 0]; // when a filter creates a border, it may have impact on future processing like Roi\n  }\n\n  get [Symbol.toStringTag]() {\n    return 'IJSImage';\n  }\n\n  static isImage(object) {\n    return objectToString.call(object) === '[object IJSImage]';\n  }\n\n  /**\n   * Creates an image from an HTML Canvas object\n   * @param {Canvas} canvas\n   * @return {Image}\n   */\n  static fromCanvas(canvas) {\n    const ctx = canvas.getContext('2d');\n    const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);\n    return new Image(imageData.width, imageData.height, imageData.data);\n  }\n\n  /**\n   * Create a new Image based on the characteristics of another one.\n   * @param {Image} other\n   * @param {object} [options] - Override options to change some parameters\n   * @return {Image}\n   * @example\n   * const newImage = Image.createFrom(image, { width: 100 });\n   */\n  static createFrom(other, options) {\n    const newOptions = getImageParameters(other);\n    Object.assign(\n      newOptions,\n      {\n        parent: other,\n        position: [0, 0],\n      },\n      options,\n    );\n    return new Image(newOptions);\n  }\n\n  /**\n   * Create a new manager for regions of interest based on the current image.\n   * @param {object} [options]\n   * @return {RoiManager}\n   */\n  getRoiManager(options) {\n    return new RoiManager(this, options);\n  }\n\n  /**\n   * Create a copy a the current image, including its data.\n   * @instance\n   * @return {Image}\n   */\n  clone() {\n    const newData = this.data.slice();\n    return new Image(this.width, this.height, newData, this);\n  }\n\n  apply(filter) {\n    for (let y = 0; y < this.height; y++) {\n      for (let x = 0; x < this.width; x++) {\n        let index = (y * this.width + x) * this.channels;\n        filter.call(this, index);\n      }\n    }\n  }\n}\n\nvalueMethods(Image);\nbitMethods(Image);\nexportMethods(Image);\n\nImage.prototype.checkProcessable = checkProcessable;\nImage.prototype.getRGBAData = getRGBAData;\n\nImage.load = load;\nImage.extendMethod = extendMethod;\nImage.extendProperty = extendProperty;\nextend(Image);\n"]},"metadata":{},"sourceType":"module"}