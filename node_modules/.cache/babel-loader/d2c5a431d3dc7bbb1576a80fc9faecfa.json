{"ast":null,"code":"import Image from '../Image';\nimport { validInterpolations, checkInterpolation } from '../internal/checks';\nexport default function rotateFree(degrees, options = {}) {\n  const {\n    interpolation = validInterpolations.nearestneighbor,\n    width = this.width,\n    height = this.height\n  } = options;\n\n  if (typeof degrees !== 'number') {\n    throw new TypeError('degrees must be a number');\n  }\n\n  const interpolationToUse = checkInterpolation(interpolation);\n  const radians = degrees * Math.PI / 180;\n  const newWidth = Math.floor(Math.abs(width * Math.cos(radians)) + Math.abs(height * Math.sin(radians)));\n  const newHeight = Math.floor(Math.abs(height * Math.cos(radians)) + Math.abs(width * Math.sin(radians)));\n  const newImage = Image.createFrom(this, {\n    width: newWidth,\n    height: newHeight\n  });\n  const cos = Math.cos(-radians);\n  const sin = Math.sin(-radians);\n  let x0 = newWidth / 2;\n  let y0 = newHeight / 2;\n\n  if (newWidth % 2 === 0) {\n    x0 = x0 - 0.5;\n\n    if (newHeight % 2 === 0) {\n      y0 = y0 - 0.5;\n    } else {\n      y0 = Math.floor(y0);\n    }\n  } else {\n    x0 = Math.floor(x0);\n\n    if (newHeight % 2 === 0) {\n      y0 = y0 - 0.5;\n    } else {\n      y0 = Math.floor(y0);\n    }\n  }\n\n  const incrementX = Math.floor(width / 2 - x0);\n  const incrementY = Math.floor(height / 2 - y0);\n\n  switch (interpolationToUse) {\n    case validInterpolations.nearestneighbor:\n      return rotateNearestNeighbor(this, newImage, incrementX, incrementY, x0, y0, cos, sin);\n\n    case validInterpolations.bilinear:\n      return rotateBilinear(this, newImage, incrementX, incrementY, x0, y0, cos, sin);\n\n    default:\n      throw new Error(`unsupported rotate interpolation: ${interpolationToUse}`);\n  }\n}\n\nfunction rotateNearestNeighbor(thisImage, newImage, incrementX, incrementY, x0, y0, cos, sin) {\n  for (let i = 0; i < newImage.width; i += 1) {\n    for (let j = 0; j < newImage.height; j += 1) {\n      for (let c = 0; c < thisImage.channels; c++) {\n        let x = Math.round((i - x0) * cos - (j - y0) * sin + x0) + incrementX;\n        let y = Math.round((j - y0) * cos + (i - x0) * sin + y0) + incrementY;\n\n        if (x < 0 || x >= thisImage.width || y < 0 || y >= thisImage.height) {\n          if (thisImage.alpha === 1 && c === thisImage.channels - 1) {\n            newImage.setValueXY(i, j, c, 0);\n          } else {\n            newImage.setValueXY(i, j, c, thisImage.maxValue);\n          }\n        } else {\n          newImage.setValueXY(i, j, c, thisImage.getValueXY(x, y, c));\n        }\n      }\n    }\n  }\n\n  return newImage;\n}\n\nfunction rotateBilinear(thisImage, newImage, incrementX, incrementY, x0, y0, cos, sin) {\n  let stride = thisImage.width * thisImage.channels;\n\n  for (let j = 0; j < newImage.height; j++) {\n    for (let i = 0; i < newImage.width; i++) {\n      let x = (i - x0) * cos - (j - y0) * sin + x0 + incrementX;\n      let y = (j - y0) * cos + (i - x0) * sin + y0 + incrementY;\n      let x1 = x | 0;\n      let y1 = y | 0;\n      let xDiff = x - x1;\n      let yDiff = y - y1;\n\n      for (let c = 0; c < thisImage.channels; c++) {\n        if (x < 0 || x >= thisImage.width || y < 0 || y >= thisImage.height) {\n          if (thisImage.alpha === 1 && c === thisImage.channels - 1) {\n            newImage.setValueXY(i, j, c, 0);\n          } else {\n            newImage.setValueXY(i, j, c, thisImage.maxValue);\n          }\n        } else {\n          let index = (y1 * thisImage.width + x1) * thisImage.channels + c;\n          let A = thisImage.data[index];\n          let B = thisImage.data[index + thisImage.channels];\n          let C = thisImage.data[index + stride];\n          let D = thisImage.data[index + stride + thisImage.channels];\n          let result = A + xDiff * (B - A) + yDiff * (C - A) + xDiff * yDiff * (A - B - C + D) | 0;\n          newImage.setValueXY(i, j, c, result);\n        }\n      }\n    }\n  }\n\n  return newImage;\n}","map":{"version":3,"sources":["C:/Users/kuent/Documents/FinishDipshit/Creative/Ocean-Weather-Visualization/node_modules/image-js/src/image/transform/rotateFree.js"],"names":["Image","validInterpolations","checkInterpolation","rotateFree","degrees","options","interpolation","nearestneighbor","width","height","TypeError","interpolationToUse","radians","Math","PI","newWidth","floor","abs","cos","sin","newHeight","newImage","createFrom","x0","y0","incrementX","incrementY","rotateNearestNeighbor","bilinear","rotateBilinear","Error","thisImage","i","j","c","channels","x","round","y","alpha","setValueXY","maxValue","getValueXY","stride","x1","y1","xDiff","yDiff","index","A","data","B","C","D","result"],"mappings":"AAAA,OAAOA,KAAP,MAAkB,UAAlB;AACA,SAASC,mBAAT,EAA8BC,kBAA9B,QAAwD,oBAAxD;AAEA,eAAe,SAASC,UAAT,CAAoBC,OAApB,EAA6BC,OAAO,GAAG,EAAvC,EAA2C;AACxD,QAAM;AACJC,IAAAA,aAAa,GAAGL,mBAAmB,CAACM,eADhC;AAEJC,IAAAA,KAAK,GAAG,KAAKA,KAFT;AAGJC,IAAAA,MAAM,GAAG,KAAKA;AAHV,MAIFJ,OAJJ;;AAMA,MAAI,OAAOD,OAAP,KAAmB,QAAvB,EAAiC;AAC/B,UAAM,IAAIM,SAAJ,CAAc,0BAAd,CAAN;AACD;;AACD,QAAMC,kBAAkB,GAAGT,kBAAkB,CAACI,aAAD,CAA7C;AAEA,QAAMM,OAAO,GAAIR,OAAO,GAAGS,IAAI,CAACC,EAAhB,GAAsB,GAAtC;AACA,QAAMC,QAAQ,GAAGF,IAAI,CAACG,KAAL,CACfH,IAAI,CAACI,GAAL,CAAST,KAAK,GAAGK,IAAI,CAACK,GAAL,CAASN,OAAT,CAAjB,IAAsCC,IAAI,CAACI,GAAL,CAASR,MAAM,GAAGI,IAAI,CAACM,GAAL,CAASP,OAAT,CAAlB,CADvB,CAAjB;AAGA,QAAMQ,SAAS,GAAGP,IAAI,CAACG,KAAL,CAChBH,IAAI,CAACI,GAAL,CAASR,MAAM,GAAGI,IAAI,CAACK,GAAL,CAASN,OAAT,CAAlB,IAAuCC,IAAI,CAACI,GAAL,CAAST,KAAK,GAAGK,IAAI,CAACM,GAAL,CAASP,OAAT,CAAjB,CADvB,CAAlB;AAGA,QAAMS,QAAQ,GAAGrB,KAAK,CAACsB,UAAN,CAAiB,IAAjB,EAAuB;AACtCd,IAAAA,KAAK,EAAEO,QAD+B;AAEtCN,IAAAA,MAAM,EAAEW;AAF8B,GAAvB,CAAjB;AAIA,QAAMF,GAAG,GAAGL,IAAI,CAACK,GAAL,CAAS,CAACN,OAAV,CAAZ;AACA,QAAMO,GAAG,GAAGN,IAAI,CAACM,GAAL,CAAS,CAACP,OAAV,CAAZ;AAEA,MAAIW,EAAE,GAAGR,QAAQ,GAAG,CAApB;AACA,MAAIS,EAAE,GAAGJ,SAAS,GAAG,CAArB;;AACA,MAAIL,QAAQ,GAAG,CAAX,KAAiB,CAArB,EAAwB;AACtBQ,IAAAA,EAAE,GAAGA,EAAE,GAAG,GAAV;;AACA,QAAIH,SAAS,GAAG,CAAZ,KAAkB,CAAtB,EAAyB;AACvBI,MAAAA,EAAE,GAAGA,EAAE,GAAG,GAAV;AACD,KAFD,MAEO;AACLA,MAAAA,EAAE,GAAGX,IAAI,CAACG,KAAL,CAAWQ,EAAX,CAAL;AACD;AACF,GAPD,MAOO;AACLD,IAAAA,EAAE,GAAGV,IAAI,CAACG,KAAL,CAAWO,EAAX,CAAL;;AACA,QAAIH,SAAS,GAAG,CAAZ,KAAkB,CAAtB,EAAyB;AACvBI,MAAAA,EAAE,GAAGA,EAAE,GAAG,GAAV;AACD,KAFD,MAEO;AACLA,MAAAA,EAAE,GAAGX,IAAI,CAACG,KAAL,CAAWQ,EAAX,CAAL;AACD;AACF;;AAED,QAAMC,UAAU,GAAGZ,IAAI,CAACG,KAAL,CAAWR,KAAK,GAAG,CAAR,GAAYe,EAAvB,CAAnB;AACA,QAAMG,UAAU,GAAGb,IAAI,CAACG,KAAL,CAAWP,MAAM,GAAG,CAAT,GAAae,EAAxB,CAAnB;;AAEA,UAAQb,kBAAR;AACE,SAAKV,mBAAmB,CAACM,eAAzB;AACE,aAAOoB,qBAAqB,CAC1B,IAD0B,EAE1BN,QAF0B,EAG1BI,UAH0B,EAI1BC,UAJ0B,EAK1BH,EAL0B,EAM1BC,EAN0B,EAO1BN,GAP0B,EAQ1BC,GAR0B,CAA5B;;AAUF,SAAKlB,mBAAmB,CAAC2B,QAAzB;AACE,aAAOC,cAAc,CACnB,IADmB,EAEnBR,QAFmB,EAGnBI,UAHmB,EAInBC,UAJmB,EAKnBH,EALmB,EAMnBC,EANmB,EAOnBN,GAPmB,EAQnBC,GARmB,CAArB;;AAUF;AACE,YAAM,IAAIW,KAAJ,CACH,qCAAoCnB,kBAAmB,EADpD,CAAN;AAxBJ;AA4BD;;AAED,SAASgB,qBAAT,CACEI,SADF,EAEEV,QAFF,EAGEI,UAHF,EAIEC,UAJF,EAKEH,EALF,EAMEC,EANF,EAOEN,GAPF,EAQEC,GARF,EASE;AACA,OAAK,IAAIa,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGX,QAAQ,CAACb,KAA7B,EAAoCwB,CAAC,IAAI,CAAzC,EAA4C;AAC1C,SAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGZ,QAAQ,CAACZ,MAA7B,EAAqCwB,CAAC,IAAI,CAA1C,EAA6C;AAC3C,WAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGH,SAAS,CAACI,QAA9B,EAAwCD,CAAC,EAAzC,EAA6C;AAC3C,YAAIE,CAAC,GAAGvB,IAAI,CAACwB,KAAL,CAAW,CAACL,CAAC,GAAGT,EAAL,IAAWL,GAAX,GAAiB,CAACe,CAAC,GAAGT,EAAL,IAAWL,GAA5B,GAAkCI,EAA7C,IAAmDE,UAA3D;AACA,YAAIa,CAAC,GAAGzB,IAAI,CAACwB,KAAL,CAAW,CAACJ,CAAC,GAAGT,EAAL,IAAWN,GAAX,GAAiB,CAACc,CAAC,GAAGT,EAAL,IAAWJ,GAA5B,GAAkCK,EAA7C,IAAmDE,UAA3D;;AAEA,YAAIU,CAAC,GAAG,CAAJ,IAASA,CAAC,IAAIL,SAAS,CAACvB,KAAxB,IAAiC8B,CAAC,GAAG,CAArC,IAA0CA,CAAC,IAAIP,SAAS,CAACtB,MAA7D,EAAqE;AACnE,cAAIsB,SAAS,CAACQ,KAAV,KAAoB,CAApB,IAAyBL,CAAC,KAAKH,SAAS,CAACI,QAAV,GAAqB,CAAxD,EAA2D;AACzDd,YAAAA,QAAQ,CAACmB,UAAT,CAAoBR,CAApB,EAAuBC,CAAvB,EAA0BC,CAA1B,EAA6B,CAA7B;AACD,WAFD,MAEO;AACLb,YAAAA,QAAQ,CAACmB,UAAT,CAAoBR,CAApB,EAAuBC,CAAvB,EAA0BC,CAA1B,EAA6BH,SAAS,CAACU,QAAvC;AACD;AACF,SAND,MAMO;AACLpB,UAAAA,QAAQ,CAACmB,UAAT,CAAoBR,CAApB,EAAuBC,CAAvB,EAA0BC,CAA1B,EAA6BH,SAAS,CAACW,UAAV,CAAqBN,CAArB,EAAwBE,CAAxB,EAA2BJ,CAA3B,CAA7B;AACD;AACF;AACF;AACF;;AACD,SAAOb,QAAP;AACD;;AAED,SAASQ,cAAT,CACEE,SADF,EAEEV,QAFF,EAGEI,UAHF,EAIEC,UAJF,EAKEH,EALF,EAMEC,EANF,EAOEN,GAPF,EAQEC,GARF,EASE;AACA,MAAIwB,MAAM,GAAGZ,SAAS,CAACvB,KAAV,GAAkBuB,SAAS,CAACI,QAAzC;;AACA,OAAK,IAAIF,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGZ,QAAQ,CAACZ,MAA7B,EAAqCwB,CAAC,EAAtC,EAA0C;AACxC,SAAK,IAAID,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGX,QAAQ,CAACb,KAA7B,EAAoCwB,CAAC,EAArC,EAAyC;AACvC,UAAII,CAAC,GAAG,CAACJ,CAAC,GAAGT,EAAL,IAAWL,GAAX,GAAiB,CAACe,CAAC,GAAGT,EAAL,IAAWL,GAA5B,GAAkCI,EAAlC,GAAuCE,UAA/C;AACA,UAAIa,CAAC,GAAG,CAACL,CAAC,GAAGT,EAAL,IAAWN,GAAX,GAAiB,CAACc,CAAC,GAAGT,EAAL,IAAWJ,GAA5B,GAAkCK,EAAlC,GAAuCE,UAA/C;AACA,UAAIkB,EAAE,GAAGR,CAAC,GAAG,CAAb;AACA,UAAIS,EAAE,GAAGP,CAAC,GAAG,CAAb;AACA,UAAIQ,KAAK,GAAGV,CAAC,GAAGQ,EAAhB;AACA,UAAIG,KAAK,GAAGT,CAAC,GAAGO,EAAhB;;AACA,WAAK,IAAIX,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGH,SAAS,CAACI,QAA9B,EAAwCD,CAAC,EAAzC,EAA6C;AAC3C,YAAIE,CAAC,GAAG,CAAJ,IAASA,CAAC,IAAIL,SAAS,CAACvB,KAAxB,IAAiC8B,CAAC,GAAG,CAArC,IAA0CA,CAAC,IAAIP,SAAS,CAACtB,MAA7D,EAAqE;AACnE,cAAIsB,SAAS,CAACQ,KAAV,KAAoB,CAApB,IAAyBL,CAAC,KAAKH,SAAS,CAACI,QAAV,GAAqB,CAAxD,EAA2D;AACzDd,YAAAA,QAAQ,CAACmB,UAAT,CAAoBR,CAApB,EAAuBC,CAAvB,EAA0BC,CAA1B,EAA6B,CAA7B;AACD,WAFD,MAEO;AACLb,YAAAA,QAAQ,CAACmB,UAAT,CAAoBR,CAApB,EAAuBC,CAAvB,EAA0BC,CAA1B,EAA6BH,SAAS,CAACU,QAAvC;AACD;AACF,SAND,MAMO;AACL,cAAIO,KAAK,GAAG,CAACH,EAAE,GAAGd,SAAS,CAACvB,KAAf,GAAuBoC,EAAxB,IAA8Bb,SAAS,CAACI,QAAxC,GAAmDD,CAA/D;AAEA,cAAIe,CAAC,GAAGlB,SAAS,CAACmB,IAAV,CAAeF,KAAf,CAAR;AACA,cAAIG,CAAC,GAAGpB,SAAS,CAACmB,IAAV,CAAeF,KAAK,GAAGjB,SAAS,CAACI,QAAjC,CAAR;AACA,cAAIiB,CAAC,GAAGrB,SAAS,CAACmB,IAAV,CAAeF,KAAK,GAAGL,MAAvB,CAAR;AACA,cAAIU,CAAC,GAAGtB,SAAS,CAACmB,IAAV,CAAeF,KAAK,GAAGL,MAAR,GAAiBZ,SAAS,CAACI,QAA1C,CAAR;AAEA,cAAImB,MAAM,GACPL,CAAC,GACAH,KAAK,IAAIK,CAAC,GAAGF,CAAR,CADN,GAECF,KAAK,IAAIK,CAAC,GAAGH,CAAR,CAFN,GAGCH,KAAK,GAAGC,KAAR,IAAiBE,CAAC,GAAGE,CAAJ,GAAQC,CAAR,GAAYC,CAA7B,CAHF,GAIA,CALF;AAOAhC,UAAAA,QAAQ,CAACmB,UAAT,CAAoBR,CAApB,EAAuBC,CAAvB,EAA0BC,CAA1B,EAA6BoB,MAA7B;AACD;AACF;AACF;AACF;;AACD,SAAOjC,QAAP;AACD","sourcesContent":["import Image from '../Image';\nimport { validInterpolations, checkInterpolation } from '../internal/checks';\n\nexport default function rotateFree(degrees, options = {}) {\n  const {\n    interpolation = validInterpolations.nearestneighbor,\n    width = this.width,\n    height = this.height,\n  } = options;\n\n  if (typeof degrees !== 'number') {\n    throw new TypeError('degrees must be a number');\n  }\n  const interpolationToUse = checkInterpolation(interpolation);\n\n  const radians = (degrees * Math.PI) / 180;\n  const newWidth = Math.floor(\n    Math.abs(width * Math.cos(radians)) + Math.abs(height * Math.sin(radians)),\n  );\n  const newHeight = Math.floor(\n    Math.abs(height * Math.cos(radians)) + Math.abs(width * Math.sin(radians)),\n  );\n  const newImage = Image.createFrom(this, {\n    width: newWidth,\n    height: newHeight,\n  });\n  const cos = Math.cos(-radians);\n  const sin = Math.sin(-radians);\n\n  let x0 = newWidth / 2;\n  let y0 = newHeight / 2;\n  if (newWidth % 2 === 0) {\n    x0 = x0 - 0.5;\n    if (newHeight % 2 === 0) {\n      y0 = y0 - 0.5;\n    } else {\n      y0 = Math.floor(y0);\n    }\n  } else {\n    x0 = Math.floor(x0);\n    if (newHeight % 2 === 0) {\n      y0 = y0 - 0.5;\n    } else {\n      y0 = Math.floor(y0);\n    }\n  }\n\n  const incrementX = Math.floor(width / 2 - x0);\n  const incrementY = Math.floor(height / 2 - y0);\n\n  switch (interpolationToUse) {\n    case validInterpolations.nearestneighbor:\n      return rotateNearestNeighbor(\n        this,\n        newImage,\n        incrementX,\n        incrementY,\n        x0,\n        y0,\n        cos,\n        sin,\n      );\n    case validInterpolations.bilinear:\n      return rotateBilinear(\n        this,\n        newImage,\n        incrementX,\n        incrementY,\n        x0,\n        y0,\n        cos,\n        sin,\n      );\n    default:\n      throw new Error(\n        `unsupported rotate interpolation: ${interpolationToUse}`,\n      );\n  }\n}\n\nfunction rotateNearestNeighbor(\n  thisImage,\n  newImage,\n  incrementX,\n  incrementY,\n  x0,\n  y0,\n  cos,\n  sin,\n) {\n  for (let i = 0; i < newImage.width; i += 1) {\n    for (let j = 0; j < newImage.height; j += 1) {\n      for (let c = 0; c < thisImage.channels; c++) {\n        let x = Math.round((i - x0) * cos - (j - y0) * sin + x0) + incrementX;\n        let y = Math.round((j - y0) * cos + (i - x0) * sin + y0) + incrementY;\n\n        if (x < 0 || x >= thisImage.width || y < 0 || y >= thisImage.height) {\n          if (thisImage.alpha === 1 && c === thisImage.channels - 1) {\n            newImage.setValueXY(i, j, c, 0);\n          } else {\n            newImage.setValueXY(i, j, c, thisImage.maxValue);\n          }\n        } else {\n          newImage.setValueXY(i, j, c, thisImage.getValueXY(x, y, c));\n        }\n      }\n    }\n  }\n  return newImage;\n}\n\nfunction rotateBilinear(\n  thisImage,\n  newImage,\n  incrementX,\n  incrementY,\n  x0,\n  y0,\n  cos,\n  sin,\n) {\n  let stride = thisImage.width * thisImage.channels;\n  for (let j = 0; j < newImage.height; j++) {\n    for (let i = 0; i < newImage.width; i++) {\n      let x = (i - x0) * cos - (j - y0) * sin + x0 + incrementX;\n      let y = (j - y0) * cos + (i - x0) * sin + y0 + incrementY;\n      let x1 = x | 0;\n      let y1 = y | 0;\n      let xDiff = x - x1;\n      let yDiff = y - y1;\n      for (let c = 0; c < thisImage.channels; c++) {\n        if (x < 0 || x >= thisImage.width || y < 0 || y >= thisImage.height) {\n          if (thisImage.alpha === 1 && c === thisImage.channels - 1) {\n            newImage.setValueXY(i, j, c, 0);\n          } else {\n            newImage.setValueXY(i, j, c, thisImage.maxValue);\n          }\n        } else {\n          let index = (y1 * thisImage.width + x1) * thisImage.channels + c;\n\n          let A = thisImage.data[index];\n          let B = thisImage.data[index + thisImage.channels];\n          let C = thisImage.data[index + stride];\n          let D = thisImage.data[index + stride + thisImage.channels];\n\n          let result =\n            (A +\n              xDiff * (B - A) +\n              yDiff * (C - A) +\n              xDiff * yDiff * (A - B - C + D)) |\n            0;\n\n          newImage.setValueXY(i, j, c, result);\n        }\n      }\n    }\n  }\n  return newImage;\n}\n"]},"metadata":{},"sourceType":"module"}