{"ast":null,"code":"import copyAlphaChannel from '../internal/copyAlphaChannel';\nimport { getOutputImageOrInPlace } from '../internal/getOutputImage';\n/**\n * Invert the colors of an image\n * @memberof Image\n * @instance\n * @param {object} [options]\n * @param {boolean} [options.inPlace=false]\n * @param {Image} [options.out]\n * @return {Image}\n */\n\nexport default function invert(options = {}) {\n  this.checkProcessable('invert', {\n    bitDepth: [1, 8, 16]\n  });\n  const out = getOutputImageOrInPlace(this, options);\n\n  if (this.bitDepth === 1) {\n    invertBinary(this, out);\n  } else {\n    invertColor(this, out);\n\n    if (this !== out) {\n      copyAlphaChannel(this, out);\n    }\n  }\n\n  return out;\n}\n\nfunction invertBinary(image, out) {\n  for (let i = 0; i < image.data.length; i++) {\n    out.data[i] = ~image.data[i];\n  }\n}\n\nfunction invertColor(image, out) {\n  for (let pixel = 0; pixel < image.data.length; pixel += image.channels) {\n    for (let c = 0; c < image.components; c++) {\n      out.data[pixel + c] = image.maxValue - image.data[pixel + c];\n    }\n  }\n}","map":{"version":3,"sources":["C:/Users/kuent/Documents/FinishDipshit/Creative/Ocean-Weather-Visualization/node_modules/image-js/src/image/filter/invert.js"],"names":["copyAlphaChannel","getOutputImageOrInPlace","invert","options","checkProcessable","bitDepth","out","invertBinary","invertColor","image","i","data","length","pixel","channels","c","components","maxValue"],"mappings":"AAAA,OAAOA,gBAAP,MAA6B,8BAA7B;AACA,SAASC,uBAAT,QAAwC,4BAAxC;AAEA;;;;;;;;;;AASA,eAAe,SAASC,MAAT,CAAgBC,OAAO,GAAG,EAA1B,EAA8B;AAC3C,OAAKC,gBAAL,CAAsB,QAAtB,EAAgC;AAC9BC,IAAAA,QAAQ,EAAE,CAAC,CAAD,EAAI,CAAJ,EAAO,EAAP;AADoB,GAAhC;AAIA,QAAMC,GAAG,GAAGL,uBAAuB,CAAC,IAAD,EAAOE,OAAP,CAAnC;;AAEA,MAAI,KAAKE,QAAL,KAAkB,CAAtB,EAAyB;AACvBE,IAAAA,YAAY,CAAC,IAAD,EAAOD,GAAP,CAAZ;AACD,GAFD,MAEO;AACLE,IAAAA,WAAW,CAAC,IAAD,EAAOF,GAAP,CAAX;;AACA,QAAI,SAASA,GAAb,EAAkB;AAChBN,MAAAA,gBAAgB,CAAC,IAAD,EAAOM,GAAP,CAAhB;AACD;AACF;;AACD,SAAOA,GAAP;AACD;;AAED,SAASC,YAAT,CAAsBE,KAAtB,EAA6BH,GAA7B,EAAkC;AAChC,OAAK,IAAII,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGD,KAAK,CAACE,IAAN,CAAWC,MAA/B,EAAuCF,CAAC,EAAxC,EAA4C;AAC1CJ,IAAAA,GAAG,CAACK,IAAJ,CAASD,CAAT,IAAc,CAACD,KAAK,CAACE,IAAN,CAAWD,CAAX,CAAf;AACD;AACF;;AAED,SAASF,WAAT,CAAqBC,KAArB,EAA4BH,GAA5B,EAAiC;AAC/B,OAAK,IAAIO,KAAK,GAAG,CAAjB,EAAoBA,KAAK,GAAGJ,KAAK,CAACE,IAAN,CAAWC,MAAvC,EAA+CC,KAAK,IAAIJ,KAAK,CAACK,QAA9D,EAAwE;AACtE,SAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGN,KAAK,CAACO,UAA1B,EAAsCD,CAAC,EAAvC,EAA2C;AACzCT,MAAAA,GAAG,CAACK,IAAJ,CAASE,KAAK,GAAGE,CAAjB,IAAsBN,KAAK,CAACQ,QAAN,GAAiBR,KAAK,CAACE,IAAN,CAAWE,KAAK,GAAGE,CAAnB,CAAvC;AACD;AACF;AACF","sourcesContent":["import copyAlphaChannel from '../internal/copyAlphaChannel';\nimport { getOutputImageOrInPlace } from '../internal/getOutputImage';\n\n/**\n * Invert the colors of an image\n * @memberof Image\n * @instance\n * @param {object} [options]\n * @param {boolean} [options.inPlace=false]\n * @param {Image} [options.out]\n * @return {Image}\n */\nexport default function invert(options = {}) {\n  this.checkProcessable('invert', {\n    bitDepth: [1, 8, 16],\n  });\n\n  const out = getOutputImageOrInPlace(this, options);\n\n  if (this.bitDepth === 1) {\n    invertBinary(this, out);\n  } else {\n    invertColor(this, out);\n    if (this !== out) {\n      copyAlphaChannel(this, out);\n    }\n  }\n  return out;\n}\n\nfunction invertBinary(image, out) {\n  for (let i = 0; i < image.data.length; i++) {\n    out.data[i] = ~image.data[i];\n  }\n}\n\nfunction invertColor(image, out) {\n  for (let pixel = 0; pixel < image.data.length; pixel += image.channels) {\n    for (let c = 0; c < image.components; c++) {\n      out.data[pixel + c] = image.maxValue - image.data[pixel + c];\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"module"}