{"ast":null,"code":"import isInteger from 'is-integer';\nimport newArray from 'new-array';\n/**\n * Returns a histogram for the specified channel\n * @memberof Image\n * @instance\n * @param {object} [options]\n * @param {number} [options.maxSlots=256]\n * @param {number} [options.channel]\n * @param {boolean} [options.useAlpha=true]\n * @return {number[]}\n */\n\nexport function getHistogram(options = {}) {\n  let {\n    maxSlots = 256,\n    channel,\n    useAlpha = true\n  } = options;\n  this.checkProcessable('getHistogram', {\n    bitDepth: [1, 8, 16]\n  });\n\n  if (channel === undefined) {\n    if (this.components > 1) {\n      throw new RangeError('You need to define the channel for an image that contains more than one channel');\n    }\n\n    channel = 0;\n  }\n\n  return getChannelHistogram.call(this, channel, {\n    useAlpha,\n    maxSlots\n  });\n}\n/**\n * Returns an array (number of channels) of array (number of slots) containing\n * the number of data of a specific intensity.\n * Intensity may be grouped by the maxSlots parameter.\n * @memberof Image\n * @instance\n * @param {object} [options]\n * @param {number} [options.maxSlots] - Number of slots in the resulting\n *      array. The intensity will be evently distributed between 0 and\n *      the maxValue allowed for this image (255 for usual images).\n *      If maxSlots = 8, all the intensities between 0 and 31 will be\n *      placed in the slot 0, 32 to 63 in slot 1, ...\n * @return {Array<Array<number>>}\n * @example\n *      image.getHistograms({\n *          maxSlots: 8,\n *          useAlpha: false\n *      });\n */\n\nexport function getHistograms(options = {}) {\n  const {\n    maxSlots = 256,\n    useAlpha = true\n  } = options;\n  this.checkProcessable('getHistograms', {\n    bitDepth: [8, 16]\n  });\n  let results = new Array(useAlpha ? this.components : this.channels);\n\n  for (let i = 0; i < results.length; i++) {\n    results[i] = getChannelHistogram.call(this, i, {\n      useAlpha,\n      maxSlots\n    });\n  }\n\n  return results;\n}\n\nfunction getChannelHistogram(channel, options) {\n  let {\n    useAlpha,\n    maxSlots\n  } = options; // for a mask, return a number array containing count of black and white points (black = array[0], white = array[1])\n\n  if (this.bitDepth === 1) {\n    let blackWhiteCount = [0, 0];\n\n    for (let i = 0; i < this.height; i++) {\n      for (let j = 0; j < this.width; j++) {\n        let value = this.getBitXY(i, j);\n\n        if (value === 0) {\n          blackWhiteCount[0] += 1;\n        } else if (value === 1) {\n          blackWhiteCount[1] += 1;\n        }\n      }\n    }\n\n    return blackWhiteCount;\n  }\n\n  let bitSlots = Math.log2(maxSlots);\n\n  if (!isInteger(bitSlots)) {\n    throw new RangeError('maxSlots must be a power of 2, for example: 64, 256, 1024');\n  } // we will compare the bitSlots to the bitDepth of the image\n  // based on this we will shift the values. This allows to generate a histogram\n  // of 16 grey even if the images has 256 shade of grey\n\n\n  let bitShift = 0;\n\n  if (this.bitDepth > bitSlots) {\n    bitShift = this.bitDepth - bitSlots;\n  }\n\n  let data = this.data;\n  let result = newArray(Math.pow(2, Math.min(this.bitDepth, bitSlots)), 0);\n\n  if (useAlpha && this.alpha) {\n    let alphaChannelDiff = this.channels - channel - 1;\n\n    for (let i = channel; i < data.length; i += this.channels) {\n      result[data[i] >> bitShift] += data[i + alphaChannelDiff] / this.maxValue;\n    }\n  } else {\n    for (let i = channel; i < data.length; i += this.channels) {\n      result[data[i] >> bitShift]++;\n    }\n  }\n\n  return result;\n}","map":{"version":3,"sources":["C:/Users/kuent/Documents/FinishDipshit/Creative/Ocean-Weather-Visualization/node_modules/image-js/src/image/compute/histogram.js"],"names":["isInteger","newArray","getHistogram","options","maxSlots","channel","useAlpha","checkProcessable","bitDepth","undefined","components","RangeError","getChannelHistogram","call","getHistograms","results","Array","channels","i","length","blackWhiteCount","height","j","width","value","getBitXY","bitSlots","Math","log2","bitShift","data","result","pow","min","alpha","alphaChannelDiff","maxValue"],"mappings":"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","sourcesContent":["import isInteger from 'is-integer';\nimport newArray from 'new-array';\n\n/**\n * Returns a histogram for the specified channel\n * @memberof Image\n * @instance\n * @param {object} [options]\n * @param {number} [options.maxSlots=256]\n * @param {number} [options.channel]\n * @param {boolean} [options.useAlpha=true]\n * @return {number[]}\n */\nexport function getHistogram(options = {}) {\n  let { maxSlots = 256, channel, useAlpha = true } = options;\n  this.checkProcessable('getHistogram', {\n    bitDepth: [1, 8, 16],\n  });\n  if (channel === undefined) {\n    if (this.components > 1) {\n      throw new RangeError(\n        'You need to define the channel for an image that contains more than one channel',\n      );\n    }\n    channel = 0;\n  }\n  return getChannelHistogram.call(this, channel, { useAlpha, maxSlots });\n}\n\n/**\n * Returns an array (number of channels) of array (number of slots) containing\n * the number of data of a specific intensity.\n * Intensity may be grouped by the maxSlots parameter.\n * @memberof Image\n * @instance\n * @param {object} [options]\n * @param {number} [options.maxSlots] - Number of slots in the resulting\n *      array. The intensity will be evently distributed between 0 and\n *      the maxValue allowed for this image (255 for usual images).\n *      If maxSlots = 8, all the intensities between 0 and 31 will be\n *      placed in the slot 0, 32 to 63 in slot 1, ...\n * @return {Array<Array<number>>}\n * @example\n *      image.getHistograms({\n *          maxSlots: 8,\n *          useAlpha: false\n *      });\n */\nexport function getHistograms(options = {}) {\n  const { maxSlots = 256, useAlpha = true } = options;\n  this.checkProcessable('getHistograms', {\n    bitDepth: [8, 16],\n  });\n  let results = new Array(useAlpha ? this.components : this.channels);\n  for (let i = 0; i < results.length; i++) {\n    results[i] = getChannelHistogram.call(this, i, { useAlpha, maxSlots });\n  }\n  return results;\n}\n\nfunction getChannelHistogram(channel, options) {\n  let { useAlpha, maxSlots } = options;\n\n  // for a mask, return a number array containing count of black and white points (black = array[0], white = array[1])\n\n  if (this.bitDepth === 1) {\n    let blackWhiteCount = [0, 0];\n    for (let i = 0; i < this.height; i++) {\n      for (let j = 0; j < this.width; j++) {\n        let value = this.getBitXY(i, j);\n        if (value === 0) {\n          blackWhiteCount[0] += 1;\n        } else if (value === 1) {\n          blackWhiteCount[1] += 1;\n        }\n      }\n    }\n    return blackWhiteCount;\n  }\n\n  let bitSlots = Math.log2(maxSlots);\n  if (!isInteger(bitSlots)) {\n    throw new RangeError(\n      'maxSlots must be a power of 2, for example: 64, 256, 1024',\n    );\n  }\n  // we will compare the bitSlots to the bitDepth of the image\n  // based on this we will shift the values. This allows to generate a histogram\n  // of 16 grey even if the images has 256 shade of grey\n\n  let bitShift = 0;\n  if (this.bitDepth > bitSlots) {\n    bitShift = this.bitDepth - bitSlots;\n  }\n\n  let data = this.data;\n  let result = newArray(Math.pow(2, Math.min(this.bitDepth, bitSlots)), 0);\n  if (useAlpha && this.alpha) {\n    let alphaChannelDiff = this.channels - channel - 1;\n\n    for (let i = channel; i < data.length; i += this.channels) {\n      result[data[i] >> bitShift] += data[i + alphaChannelDiff] / this.maxValue;\n    }\n  } else {\n    for (let i = channel; i < data.length; i += this.channels) {\n      result[data[i] >> bitShift]++;\n    }\n  }\n\n  return result;\n}\n"]},"metadata":{},"sourceType":"module"}