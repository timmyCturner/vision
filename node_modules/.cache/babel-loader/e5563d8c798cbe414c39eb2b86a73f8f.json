{"ast":null,"code":"import { getColors } from '../../util/color';\nimport { RGB } from '../model/model';\n/**\n * Paint a mask or masks on the current image.\n * @memberof Image\n * @instance\n * @param {(Image|Array<Image>)}     masks - Image containing a binary mask\n * @param {object}              [options]\n * @param {Array<number>|string}     [options.color] - Array of 3 elements (R, G, B) or a valid css color.\n * @param {Array<Array<number>>|Array<string>} [options.colors] - Array of Array of 3 elements (R, G, B) for each color of each mask\n * @param {boolean}             [options.randomColors=true] - To paint each mask with a random color if color and colors are undefined\n * @param {boolean}             [options.distinctColors=false] - To paint each mask with a different color if color and colors are undefined\n * @param {number}              [options.alpha=255] - Value from 0 to 255 to specify the alpha.\n * @param {Array<string>}       [options.labels] - Array of labels to display. Should the the same size as masks.\n * @param {Array<Array<number>>} [options.labelsPosition] - Array of points [x,y] where the labels should be displayed.\n *                                      By default it is the 0,0 position of the correesponding mask.\n * @param {string}              [options.labelColor='blue'] - Define the color to paint the labels\n * @param {string}              [options.labelFont='12px Helvetica'] - Paint the labels in a different CSS style\n * @return {this} The original painted image\n */\n\nexport default function paintMasks(masks, options = {}) {\n  let {\n    alpha = 255,\n    labels = [],\n    labelsPosition = [],\n    labelColor = 'blue',\n    labelFont = '12px Helvetica'\n  } = options;\n  this.checkProcessable('paintMasks', {\n    channels: [3, 4],\n    bitDepth: [8, 16],\n    colorModel: RGB\n  });\n  let colors = getColors(Object.assign({}, options, {\n    numberColors: masks.length\n  }));\n\n  if (!Array.isArray(masks)) {\n    masks = [masks];\n  }\n\n  for (let i = 0; i < masks.length; i++) {\n    let mask = masks[i]; // we need to find the parent image to calculate the relative position\n\n    let color = colors[i % colors.length];\n\n    for (let x = 0; x < mask.width; x++) {\n      for (let y = 0; y < mask.height; y++) {\n        if (mask.getBitXY(x, y)) {\n          for (let component = 0; component < Math.min(this.components, color.length); component++) {\n            if (alpha === 255) {\n              this.setValueXY(x + mask.position[0], y + mask.position[1], component, color[component]);\n            } else {\n              let value = this.getValueXY(x + mask.position[0], y + mask.position[1], component);\n              value = Math.round((value * (255 - alpha) + color[component] * alpha) / 255);\n              this.setValueXY(x + mask.position[0], y + mask.position[1], component, value);\n            }\n          }\n        }\n      }\n    }\n  }\n\n  if (Array.isArray(labels) && labels.length > 0) {\n    let canvas = this.getCanvas();\n    let ctx = canvas.getContext('2d');\n    ctx.fillStyle = labelColor;\n    ctx.font = labelFont;\n\n    for (let i = 0; i < Math.min(masks.length, labels.length); i++) {\n      let position = labelsPosition[i] ? labelsPosition[i] : masks[i].position;\n      ctx.fillText(labels[i], position[0], position[1]);\n    }\n\n    this.data = Uint8Array.from(ctx.getImageData(0, 0, this.width, this.height).data);\n  }\n\n  return this;\n}","map":{"version":3,"sources":["C:/Users/kuent/Documents/FinishDipshit/Creative/Ocean-Weather-Visualization/node_modules/image-js/src/image/operator/paintMasks.js"],"names":["getColors","RGB","paintMasks","masks","options","alpha","labels","labelsPosition","labelColor","labelFont","checkProcessable","channels","bitDepth","colorModel","colors","Object","assign","numberColors","length","Array","isArray","i","mask","color","x","width","y","height","getBitXY","component","Math","min","components","setValueXY","position","value","getValueXY","round","canvas","getCanvas","ctx","getContext","fillStyle","font","fillText","data","Uint8Array","from","getImageData"],"mappings":"AAAA,SAASA,SAAT,QAA0B,kBAA1B;AACA,SAASC,GAAT,QAAoB,gBAApB;AAEA;;;;;;;;;;;;;;;;;;;AAkBA,eAAe,SAASC,UAAT,CAAoBC,KAApB,EAA2BC,OAAO,GAAG,EAArC,EAAyC;AACtD,MAAI;AACFC,IAAAA,KAAK,GAAG,GADN;AAEFC,IAAAA,MAAM,GAAG,EAFP;AAGFC,IAAAA,cAAc,GAAG,EAHf;AAIFC,IAAAA,UAAU,GAAG,MAJX;AAKFC,IAAAA,SAAS,GAAG;AALV,MAMAL,OANJ;AAQA,OAAKM,gBAAL,CAAsB,YAAtB,EAAoC;AAClCC,IAAAA,QAAQ,EAAE,CAAC,CAAD,EAAI,CAAJ,CADwB;AAElCC,IAAAA,QAAQ,EAAE,CAAC,CAAD,EAAI,EAAJ,CAFwB;AAGlCC,IAAAA,UAAU,EAAEZ;AAHsB,GAApC;AAMA,MAAIa,MAAM,GAAGd,SAAS,CACpBe,MAAM,CAACC,MAAP,CAAc,EAAd,EAAkBZ,OAAlB,EAA2B;AAAEa,IAAAA,YAAY,EAAEd,KAAK,CAACe;AAAtB,GAA3B,CADoB,CAAtB;;AAIA,MAAI,CAACC,KAAK,CAACC,OAAN,CAAcjB,KAAd,CAAL,EAA2B;AACzBA,IAAAA,KAAK,GAAG,CAACA,KAAD,CAAR;AACD;;AAED,OAAK,IAAIkB,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGlB,KAAK,CAACe,MAA1B,EAAkCG,CAAC,EAAnC,EAAuC;AACrC,QAAIC,IAAI,GAAGnB,KAAK,CAACkB,CAAD,CAAhB,CADqC,CAErC;;AACA,QAAIE,KAAK,GAAGT,MAAM,CAACO,CAAC,GAAGP,MAAM,CAACI,MAAZ,CAAlB;;AACA,SAAK,IAAIM,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGF,IAAI,CAACG,KAAzB,EAAgCD,CAAC,EAAjC,EAAqC;AACnC,WAAK,IAAIE,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGJ,IAAI,CAACK,MAAzB,EAAiCD,CAAC,EAAlC,EAAsC;AACpC,YAAIJ,IAAI,CAACM,QAAL,CAAcJ,CAAd,EAAiBE,CAAjB,CAAJ,EAAyB;AACvB,eACE,IAAIG,SAAS,GAAG,CADlB,EAEEA,SAAS,GAAGC,IAAI,CAACC,GAAL,CAAS,KAAKC,UAAd,EAA0BT,KAAK,CAACL,MAAhC,CAFd,EAGEW,SAAS,EAHX,EAIE;AACA,gBAAIxB,KAAK,KAAK,GAAd,EAAmB;AACjB,mBAAK4B,UAAL,CACET,CAAC,GAAGF,IAAI,CAACY,QAAL,CAAc,CAAd,CADN,EAEER,CAAC,GAAGJ,IAAI,CAACY,QAAL,CAAc,CAAd,CAFN,EAGEL,SAHF,EAIEN,KAAK,CAACM,SAAD,CAJP;AAMD,aAPD,MAOO;AACL,kBAAIM,KAAK,GAAG,KAAKC,UAAL,CACVZ,CAAC,GAAGF,IAAI,CAACY,QAAL,CAAc,CAAd,CADM,EAEVR,CAAC,GAAGJ,IAAI,CAACY,QAAL,CAAc,CAAd,CAFM,EAGVL,SAHU,CAAZ;AAKAM,cAAAA,KAAK,GAAGL,IAAI,CAACO,KAAL,CACN,CAACF,KAAK,IAAI,MAAM9B,KAAV,CAAL,GAAwBkB,KAAK,CAACM,SAAD,CAAL,GAAmBxB,KAA5C,IAAqD,GAD/C,CAAR;AAGA,mBAAK4B,UAAL,CACET,CAAC,GAAGF,IAAI,CAACY,QAAL,CAAc,CAAd,CADN,EAEER,CAAC,GAAGJ,IAAI,CAACY,QAAL,CAAc,CAAd,CAFN,EAGEL,SAHF,EAIEM,KAJF;AAMD;AACF;AACF;AACF;AACF;AACF;;AAED,MAAIhB,KAAK,CAACC,OAAN,CAAcd,MAAd,KAAyBA,MAAM,CAACY,MAAP,GAAgB,CAA7C,EAAgD;AAC9C,QAAIoB,MAAM,GAAG,KAAKC,SAAL,EAAb;AACA,QAAIC,GAAG,GAAGF,MAAM,CAACG,UAAP,CAAkB,IAAlB,CAAV;AACAD,IAAAA,GAAG,CAACE,SAAJ,GAAgBlC,UAAhB;AACAgC,IAAAA,GAAG,CAACG,IAAJ,GAAWlC,SAAX;;AACA,SAAK,IAAIY,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGS,IAAI,CAACC,GAAL,CAAS5B,KAAK,CAACe,MAAf,EAAuBZ,MAAM,CAACY,MAA9B,CAApB,EAA2DG,CAAC,EAA5D,EAAgE;AAC9D,UAAIa,QAAQ,GAAG3B,cAAc,CAACc,CAAD,CAAd,GAAoBd,cAAc,CAACc,CAAD,CAAlC,GAAwClB,KAAK,CAACkB,CAAD,CAAL,CAASa,QAAhE;AACAM,MAAAA,GAAG,CAACI,QAAJ,CAAatC,MAAM,CAACe,CAAD,CAAnB,EAAwBa,QAAQ,CAAC,CAAD,CAAhC,EAAqCA,QAAQ,CAAC,CAAD,CAA7C;AACD;;AACD,SAAKW,IAAL,GAAYC,UAAU,CAACC,IAAX,CACVP,GAAG,CAACQ,YAAJ,CAAiB,CAAjB,EAAoB,CAApB,EAAuB,KAAKvB,KAA5B,EAAmC,KAAKE,MAAxC,EAAgDkB,IADtC,CAAZ;AAGD;;AAED,SAAO,IAAP;AACD","sourcesContent":["import { getColors } from '../../util/color';\nimport { RGB } from '../model/model';\n\n/**\n * Paint a mask or masks on the current image.\n * @memberof Image\n * @instance\n * @param {(Image|Array<Image>)}     masks - Image containing a binary mask\n * @param {object}              [options]\n * @param {Array<number>|string}     [options.color] - Array of 3 elements (R, G, B) or a valid css color.\n * @param {Array<Array<number>>|Array<string>} [options.colors] - Array of Array of 3 elements (R, G, B) for each color of each mask\n * @param {boolean}             [options.randomColors=true] - To paint each mask with a random color if color and colors are undefined\n * @param {boolean}             [options.distinctColors=false] - To paint each mask with a different color if color and colors are undefined\n * @param {number}              [options.alpha=255] - Value from 0 to 255 to specify the alpha.\n * @param {Array<string>}       [options.labels] - Array of labels to display. Should the the same size as masks.\n * @param {Array<Array<number>>} [options.labelsPosition] - Array of points [x,y] where the labels should be displayed.\n *                                      By default it is the 0,0 position of the correesponding mask.\n * @param {string}              [options.labelColor='blue'] - Define the color to paint the labels\n * @param {string}              [options.labelFont='12px Helvetica'] - Paint the labels in a different CSS style\n * @return {this} The original painted image\n */\nexport default function paintMasks(masks, options = {}) {\n  let {\n    alpha = 255,\n    labels = [],\n    labelsPosition = [],\n    labelColor = 'blue',\n    labelFont = '12px Helvetica',\n  } = options;\n\n  this.checkProcessable('paintMasks', {\n    channels: [3, 4],\n    bitDepth: [8, 16],\n    colorModel: RGB,\n  });\n\n  let colors = getColors(\n    Object.assign({}, options, { numberColors: masks.length }),\n  );\n\n  if (!Array.isArray(masks)) {\n    masks = [masks];\n  }\n\n  for (let i = 0; i < masks.length; i++) {\n    let mask = masks[i];\n    // we need to find the parent image to calculate the relative position\n    let color = colors[i % colors.length];\n    for (let x = 0; x < mask.width; x++) {\n      for (let y = 0; y < mask.height; y++) {\n        if (mask.getBitXY(x, y)) {\n          for (\n            let component = 0;\n            component < Math.min(this.components, color.length);\n            component++\n          ) {\n            if (alpha === 255) {\n              this.setValueXY(\n                x + mask.position[0],\n                y + mask.position[1],\n                component,\n                color[component],\n              );\n            } else {\n              let value = this.getValueXY(\n                x + mask.position[0],\n                y + mask.position[1],\n                component,\n              );\n              value = Math.round(\n                (value * (255 - alpha) + color[component] * alpha) / 255,\n              );\n              this.setValueXY(\n                x + mask.position[0],\n                y + mask.position[1],\n                component,\n                value,\n              );\n            }\n          }\n        }\n      }\n    }\n  }\n\n  if (Array.isArray(labels) && labels.length > 0) {\n    let canvas = this.getCanvas();\n    let ctx = canvas.getContext('2d');\n    ctx.fillStyle = labelColor;\n    ctx.font = labelFont;\n    for (let i = 0; i < Math.min(masks.length, labels.length); i++) {\n      let position = labelsPosition[i] ? labelsPosition[i] : masks[i].position;\n      ctx.fillText(labels[i], position[0], position[1]);\n    }\n    this.data = Uint8Array.from(\n      ctx.getImageData(0, 0, this.width, this.height).data,\n    );\n  }\n\n  return this;\n}\n"]},"metadata":{},"sourceType":"module"}