{"ast":null,"code":"import { decode as decodeJpegExif } from 'fast-jpeg';\nimport { decode as decodePng } from 'fast-png';\nimport imageType from 'image-type';\nimport { decode as decodeJpeg } from 'jpeg-js';\nimport { decode as decodeTiff } from 'tiff';\nimport Stack from '../../stack/Stack';\nimport { decode as base64Decode, toBase64URL } from '../../util/base64';\nimport Image from '../Image';\nimport { GREY, RGB } from '../model/model';\nimport { fetchBinary, DOMImage, createCanvas } from './environment';\nconst isDataURL = /^data:[a-z]+\\/([a-z]+);base64,/;\n/**\n * Load an image\n * @memberof Image\n * @static\n * @param {string|ArrayBuffer|Buffer|Uint8Array} image - URL of the image (browser, can be a dataURL) or path (Node.js)\n * or buffer containing the binary data\n * @param {object} [options] - In the browser, the options object is passed to the underlying `fetch` call.\n * @return {Promise<Image>}\n * @example\n * const image = await Image.load('https://example.com/image.png');\n */\n\nexport default function load(image, options) {\n  if (typeof image === 'string') {\n    return loadURL(image, options);\n  } else if (image instanceof ArrayBuffer) {\n    return Promise.resolve(loadBinary(new Uint8Array(image)));\n  } else if (image.buffer) {\n    return Promise.resolve(loadBinary(image));\n  } else {\n    throw new Error('argument to \"load\" must be a string or buffer.');\n  }\n}\n\nfunction loadBinary(image, base64Url) {\n  const type = imageType(image);\n\n  if (type) {\n    switch (type.mime) {\n      case 'image/png':\n        return loadPNG(image);\n\n      case 'image/jpeg':\n        return loadJPEG(image);\n\n      case 'image/tiff':\n        return loadTIFF(image);\n\n      default:\n        return loadGeneric(getBase64(type.mime));\n    }\n  }\n\n  return loadGeneric(getBase64('application/octet-stream'));\n\n  function getBase64(type) {\n    if (base64Url) {\n      return base64Url;\n    } else {\n      return toBase64URL(image, type);\n    }\n  }\n}\n\nfunction loadURL(url, options) {\n  const dataURL = url.slice(0, 64).match(isDataURL);\n  let binaryDataP;\n\n  if (dataURL !== null) {\n    binaryDataP = Promise.resolve(base64Decode(url.slice(dataURL[0].length)));\n  } else {\n    binaryDataP = fetchBinary(url, options);\n  }\n\n  return binaryDataP.then(binaryData => {\n    const uint8 = new Uint8Array(binaryData);\n    return loadBinary(uint8, dataURL ? url : undefined);\n  });\n}\n\nfunction loadPNG(data) {\n  const png = decodePng(data);\n  let channels = png.channels;\n  let components;\n  let alpha = 0;\n\n  if (channels === 2 || channels === 4) {\n    components = channels - 1;\n    alpha = 1;\n  } else {\n    components = channels;\n  }\n\n  if (png.palette) {\n    return loadPNGFromPalette(png);\n  }\n\n  return new Image(png.width, png.height, png.data, {\n    components,\n    alpha,\n    bitDepth: png.depth\n  });\n}\n\nfunction loadPNGFromPalette(png) {\n  const pixels = png.width * png.height;\n  const channels = png.palette[0].length;\n  const data = new Uint8Array(pixels * channels);\n  const pixelsPerByte = 8 / png.depth;\n  const factor = png.depth < 8 ? pixelsPerByte : 1;\n  const mask = parseInt('1'.repeat(png.depth), 2);\n  const hasAlpha = channels === 4;\n  let dataIndex = 0;\n\n  for (let i = 0; i < pixels; i++) {\n    const index = Math.floor(i / factor);\n    let value = png.data[index];\n\n    if (png.depth < 8) {\n      value = value >>> png.depth * (pixelsPerByte - 1 - i % pixelsPerByte) & mask;\n    }\n\n    const paletteValue = png.palette[value];\n    data[dataIndex++] = paletteValue[0];\n    data[dataIndex++] = paletteValue[1];\n    data[dataIndex++] = paletteValue[2];\n\n    if (hasAlpha) {\n      data[dataIndex++] = paletteValue[3];\n    }\n  }\n\n  return new Image(png.width, png.height, data, {\n    components: 3,\n    alpha: hasAlpha,\n    bitDepth: 8\n  });\n}\n\nfunction loadJPEG(data) {\n  const decodedExif = decodeJpegExif(data);\n  let meta;\n\n  if (decodedExif.exif) {\n    meta = getMetadata(decodedExif.exif);\n  }\n\n  const jpeg = decodeJpeg(data, {\n    useTArray: true\n  });\n  return new Image(jpeg.width, jpeg.height, jpeg.data, {\n    meta\n  });\n}\n\nfunction loadTIFF(data) {\n  let result = decodeTiff(data);\n\n  if (result.length === 1) {\n    return getImageFromIFD(result[0]);\n  } else {\n    return new Stack(result.map(getImageFromIFD));\n  }\n}\n\nfunction getMetadata(image) {\n  const metadata = {\n    tiff: {\n      fields: image.fields,\n      tags: image.map\n    }\n  };\n\n  if (image.exif) {\n    metadata.exif = image.exif;\n  }\n\n  if (image.gps) {\n    metadata.gps = image.gps;\n  }\n\n  return metadata;\n}\n\nfunction getImageFromIFD(image) {\n  if (image.type === 3) {\n    // Palette\n    const data = new Uint16Array(3 * image.width * image.height);\n    const palette = image.palette;\n    let ptr = 0;\n\n    for (let i = 0; i < image.data.length; i++) {\n      const index = image.data[i];\n      const color = palette[index];\n      data[ptr++] = color[0];\n      data[ptr++] = color[1];\n      data[ptr++] = color[2];\n    }\n\n    return new Image(image.width, image.height, data, {\n      components: 3,\n      alpha: image.alpha,\n      colorModel: RGB,\n      bitDepth: 16,\n      meta: getMetadata(image)\n    });\n  } else {\n    return new Image(image.width, image.height, image.data, {\n      components: image.type === 2 ? 3 : 1,\n      alpha: image.alpha,\n      colorModel: image.type === 2 ? RGB : GREY,\n      bitDepth: image.bitsPerSample.length ? image.bitsPerSample[0] : image.bitsPerSample,\n      meta: getMetadata(image)\n    });\n  }\n}\n\nfunction loadGeneric(url, options) {\n  options = options || {};\n  return new Promise(function (resolve, reject) {\n    let image = new DOMImage();\n\n    image.onload = function () {\n      let w = image.width;\n      let h = image.height;\n      let canvas = createCanvas(w, h);\n      let ctx = canvas.getContext('2d');\n      ctx.drawImage(image, 0, 0, w, h);\n      let data = ctx.getImageData(0, 0, w, h).data;\n      resolve(new Image(w, h, data, options));\n    };\n\n    image.onerror = function () {\n      reject(new Error(`Could not load ${url}`));\n    };\n\n    image.src = url;\n  });\n}","map":{"version":3,"sources":["C:/Users/kuent/Documents/FinishDipshit/Creative/Ocean-Weather-Visualization/node_modules/image-js/src/image/core/load.js"],"names":["decode","decodeJpegExif","decodePng","imageType","decodeJpeg","decodeTiff","Stack","base64Decode","toBase64URL","Image","GREY","RGB","fetchBinary","DOMImage","createCanvas","isDataURL","load","image","options","loadURL","ArrayBuffer","Promise","resolve","loadBinary","Uint8Array","buffer","Error","base64Url","type","mime","loadPNG","loadJPEG","loadTIFF","loadGeneric","getBase64","url","dataURL","slice","match","binaryDataP","length","then","binaryData","uint8","undefined","data","png","channels","components","alpha","palette","loadPNGFromPalette","width","height","bitDepth","depth","pixels","pixelsPerByte","factor","mask","parseInt","repeat","hasAlpha","dataIndex","i","index","Math","floor","value","paletteValue","decodedExif","meta","exif","getMetadata","jpeg","useTArray","result","getImageFromIFD","map","metadata","tiff","fields","tags","gps","Uint16Array","ptr","color","colorModel","bitsPerSample","reject","onload","w","h","canvas","ctx","getContext","drawImage","getImageData","onerror","src"],"mappings":"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","sourcesContent":["import { decode as decodeJpegExif } from 'fast-jpeg';\nimport { decode as decodePng } from 'fast-png';\nimport imageType from 'image-type';\nimport { decode as decodeJpeg } from 'jpeg-js';\nimport { decode as decodeTiff } from 'tiff';\n\nimport Stack from '../../stack/Stack';\nimport { decode as base64Decode, toBase64URL } from '../../util/base64';\nimport Image from '../Image';\nimport { GREY, RGB } from '../model/model';\n\nimport { fetchBinary, DOMImage, createCanvas } from './environment';\n\nconst isDataURL = /^data:[a-z]+\\/([a-z]+);base64,/;\n\n/**\n * Load an image\n * @memberof Image\n * @static\n * @param {string|ArrayBuffer|Buffer|Uint8Array} image - URL of the image (browser, can be a dataURL) or path (Node.js)\n * or buffer containing the binary data\n * @param {object} [options] - In the browser, the options object is passed to the underlying `fetch` call.\n * @return {Promise<Image>}\n * @example\n * const image = await Image.load('https://example.com/image.png');\n */\nexport default function load(image, options) {\n  if (typeof image === 'string') {\n    return loadURL(image, options);\n  } else if (image instanceof ArrayBuffer) {\n    return Promise.resolve(loadBinary(new Uint8Array(image)));\n  } else if (image.buffer) {\n    return Promise.resolve(loadBinary(image));\n  } else {\n    throw new Error('argument to \"load\" must be a string or buffer.');\n  }\n}\n\nfunction loadBinary(image, base64Url) {\n  const type = imageType(image);\n  if (type) {\n    switch (type.mime) {\n      case 'image/png':\n        return loadPNG(image);\n      case 'image/jpeg':\n        return loadJPEG(image);\n      case 'image/tiff':\n        return loadTIFF(image);\n      default:\n        return loadGeneric(getBase64(type.mime));\n    }\n  }\n  return loadGeneric(getBase64('application/octet-stream'));\n  function getBase64(type) {\n    if (base64Url) {\n      return base64Url;\n    } else {\n      return toBase64URL(image, type);\n    }\n  }\n}\n\nfunction loadURL(url, options) {\n  const dataURL = url.slice(0, 64).match(isDataURL);\n  let binaryDataP;\n  if (dataURL !== null) {\n    binaryDataP = Promise.resolve(base64Decode(url.slice(dataURL[0].length)));\n  } else {\n    binaryDataP = fetchBinary(url, options);\n  }\n  return binaryDataP.then((binaryData) => {\n    const uint8 = new Uint8Array(binaryData);\n    return loadBinary(uint8, dataURL ? url : undefined);\n  });\n}\n\nfunction loadPNG(data) {\n  const png = decodePng(data);\n  let channels = png.channels;\n  let components;\n  let alpha = 0;\n  if (channels === 2 || channels === 4) {\n    components = channels - 1;\n    alpha = 1;\n  } else {\n    components = channels;\n  }\n  if (png.palette) {\n    return loadPNGFromPalette(png);\n  }\n\n  return new Image(png.width, png.height, png.data, {\n    components,\n    alpha,\n    bitDepth: png.depth,\n  });\n}\n\nfunction loadPNGFromPalette(png) {\n  const pixels = png.width * png.height;\n  const channels = png.palette[0].length;\n  const data = new Uint8Array(pixels * channels);\n  const pixelsPerByte = 8 / png.depth;\n  const factor = png.depth < 8 ? pixelsPerByte : 1;\n  const mask = parseInt('1'.repeat(png.depth), 2);\n  const hasAlpha = channels === 4;\n  let dataIndex = 0;\n\n  for (let i = 0; i < pixels; i++) {\n    const index = Math.floor(i / factor);\n    let value = png.data[index];\n    if (png.depth < 8) {\n      value =\n        (value >>> (png.depth * (pixelsPerByte - 1 - (i % pixelsPerByte)))) &\n        mask;\n    }\n    const paletteValue = png.palette[value];\n    data[dataIndex++] = paletteValue[0];\n    data[dataIndex++] = paletteValue[1];\n    data[dataIndex++] = paletteValue[2];\n    if (hasAlpha) {\n      data[dataIndex++] = paletteValue[3];\n    }\n  }\n\n  return new Image(png.width, png.height, data, {\n    components: 3,\n    alpha: hasAlpha,\n    bitDepth: 8,\n  });\n}\n\nfunction loadJPEG(data) {\n  const decodedExif = decodeJpegExif(data);\n  let meta;\n  if (decodedExif.exif) {\n    meta = getMetadata(decodedExif.exif);\n  }\n  const jpeg = decodeJpeg(data, { useTArray: true });\n  return new Image(jpeg.width, jpeg.height, jpeg.data, { meta });\n}\n\nfunction loadTIFF(data) {\n  let result = decodeTiff(data);\n  if (result.length === 1) {\n    return getImageFromIFD(result[0]);\n  } else {\n    return new Stack(result.map(getImageFromIFD));\n  }\n}\n\nfunction getMetadata(image) {\n  const metadata = {\n    tiff: {\n      fields: image.fields,\n      tags: image.map,\n    },\n  };\n  if (image.exif) {\n    metadata.exif = image.exif;\n  }\n  if (image.gps) {\n    metadata.gps = image.gps;\n  }\n  return metadata;\n}\n\nfunction getImageFromIFD(image) {\n  if (image.type === 3) {\n    // Palette\n    const data = new Uint16Array(3 * image.width * image.height);\n    const palette = image.palette;\n    let ptr = 0;\n    for (let i = 0; i < image.data.length; i++) {\n      const index = image.data[i];\n      const color = palette[index];\n      data[ptr++] = color[0];\n      data[ptr++] = color[1];\n      data[ptr++] = color[2];\n    }\n    return new Image(image.width, image.height, data, {\n      components: 3,\n      alpha: image.alpha,\n      colorModel: RGB,\n      bitDepth: 16,\n      meta: getMetadata(image),\n    });\n  } else {\n    return new Image(image.width, image.height, image.data, {\n      components: image.type === 2 ? 3 : 1,\n      alpha: image.alpha,\n      colorModel: image.type === 2 ? RGB : GREY,\n      bitDepth: image.bitsPerSample.length\n        ? image.bitsPerSample[0]\n        : image.bitsPerSample,\n      meta: getMetadata(image),\n    });\n  }\n}\n\nfunction loadGeneric(url, options) {\n  options = options || {};\n  return new Promise(function (resolve, reject) {\n    let image = new DOMImage();\n    image.onload = function () {\n      let w = image.width;\n      let h = image.height;\n      let canvas = createCanvas(w, h);\n      let ctx = canvas.getContext('2d');\n      ctx.drawImage(image, 0, 0, w, h);\n      let data = ctx.getImageData(0, 0, w, h).data;\n      resolve(new Image(w, h, data, options));\n    };\n    image.onerror = function () {\n      reject(new Error(`Could not load ${url}`));\n    };\n    image.src = url;\n  });\n}\n"]},"metadata":{},"sourceType":"module"}