{"ast":null,"code":"import Shape from '../../util/Shape';\nimport { getColors } from '../../util/color';\n/**\n * Paint pixels on the current image.\n * @memberof Image\n * @instance\n * @param {Array<Array<number>>} points - Array of [x,y] points\n * @param {object} [options]\n * @param {Array<number>|string}     [options.color] - Array of 3 elements (R, G, B) or a valid css color.\n * @param {Array<Array<number>>|Array<string>} [options.colors] - Array of Array of 3 elements (R, G, B) for each color of each mask\n * @param {boolean}             [options.randomColors=true] - To paint each mask with a random color if color and colors are undefined\n * @param {boolean}             [options.distinctColors=false] - To paint each mask with a different color if color and colors are undefined\n * @param {object} [options.shape] - Definition of the shape, see Shape contructor.\n * @return {this} The original painted image\n */\n\nexport default function paintPoints(points, options = {}) {\n  let {\n    shape\n  } = options;\n  this.checkProcessable('paintPoints', {\n    bitDepth: [8, 16]\n  });\n  let colors = getColors(Object.assign({}, options, {\n    numberColors: points.length\n  }));\n  let shapePixels = new Shape(shape).getPoints();\n  let numberChannels = Math.min(this.channels, colors[0].length);\n\n  for (let i = 0; i < points.length; i++) {\n    let color = colors[i % colors.length];\n    let xP = points[i][0];\n    let yP = points[i][1];\n\n    for (let j = 0; j < shapePixels.length; j++) {\n      let xS = shapePixels[j][0];\n      let yS = shapePixels[j][1];\n\n      if (xP + xS >= 0 && yP + yS >= 0 && xP + xS < this.width && yP + yS < this.height) {\n        let position = (xP + xS + (yP + yS) * this.width) * this.channels;\n\n        for (let channel = 0; channel < numberChannels; channel++) {\n          this.data[position + channel] = color[channel];\n        }\n      }\n    }\n  }\n\n  return this;\n}","map":{"version":3,"sources":["C:/Users/kuent/Documents/FinishDipshit/Creative/Ocean-Weather-Visualization/node_modules/image-js/src/image/operator/paintPoints.js"],"names":["Shape","getColors","paintPoints","points","options","shape","checkProcessable","bitDepth","colors","Object","assign","numberColors","length","shapePixels","getPoints","numberChannels","Math","min","channels","i","color","xP","yP","j","xS","yS","width","height","position","channel","data"],"mappings":"AAAA,OAAOA,KAAP,MAAkB,kBAAlB;AACA,SAASC,SAAT,QAA0B,kBAA1B;AAEA;;;;;;;;;;;;;;AAaA,eAAe,SAASC,WAAT,CAAqBC,MAArB,EAA6BC,OAAO,GAAG,EAAvC,EAA2C;AACxD,MAAI;AAAEC,IAAAA;AAAF,MAAYD,OAAhB;AAEA,OAAKE,gBAAL,CAAsB,aAAtB,EAAqC;AACnCC,IAAAA,QAAQ,EAAE,CAAC,CAAD,EAAI,EAAJ;AADyB,GAArC;AAIA,MAAIC,MAAM,GAAGP,SAAS,CACpBQ,MAAM,CAACC,MAAP,CAAc,EAAd,EAAkBN,OAAlB,EAA2B;AAAEO,IAAAA,YAAY,EAAER,MAAM,CAACS;AAAvB,GAA3B,CADoB,CAAtB;AAIA,MAAIC,WAAW,GAAG,IAAIb,KAAJ,CAAUK,KAAV,EAAiBS,SAAjB,EAAlB;AAEA,MAAIC,cAAc,GAAGC,IAAI,CAACC,GAAL,CAAS,KAAKC,QAAd,EAAwBV,MAAM,CAAC,CAAD,CAAN,CAAUI,MAAlC,CAArB;;AAEA,OAAK,IAAIO,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGhB,MAAM,CAACS,MAA3B,EAAmCO,CAAC,EAApC,EAAwC;AACtC,QAAIC,KAAK,GAAGZ,MAAM,CAACW,CAAC,GAAGX,MAAM,CAACI,MAAZ,CAAlB;AACA,QAAIS,EAAE,GAAGlB,MAAM,CAACgB,CAAD,CAAN,CAAU,CAAV,CAAT;AACA,QAAIG,EAAE,GAAGnB,MAAM,CAACgB,CAAD,CAAN,CAAU,CAAV,CAAT;;AACA,SAAK,IAAII,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGV,WAAW,CAACD,MAAhC,EAAwCW,CAAC,EAAzC,EAA6C;AAC3C,UAAIC,EAAE,GAAGX,WAAW,CAACU,CAAD,CAAX,CAAe,CAAf,CAAT;AACA,UAAIE,EAAE,GAAGZ,WAAW,CAACU,CAAD,CAAX,CAAe,CAAf,CAAT;;AACA,UACEF,EAAE,GAAGG,EAAL,IAAW,CAAX,IACAF,EAAE,GAAGG,EAAL,IAAW,CADX,IAEAJ,EAAE,GAAGG,EAAL,GAAU,KAAKE,KAFf,IAGAJ,EAAE,GAAGG,EAAL,GAAU,KAAKE,MAJjB,EAKE;AACA,YAAIC,QAAQ,GAAG,CAACP,EAAE,GAAGG,EAAL,GAAU,CAACF,EAAE,GAAGG,EAAN,IAAY,KAAKC,KAA5B,IAAqC,KAAKR,QAAzD;;AACA,aAAK,IAAIW,OAAO,GAAG,CAAnB,EAAsBA,OAAO,GAAGd,cAAhC,EAAgDc,OAAO,EAAvD,EAA2D;AACzD,eAAKC,IAAL,CAAUF,QAAQ,GAAGC,OAArB,IAAgCT,KAAK,CAACS,OAAD,CAArC;AACD;AACF;AACF;AACF;;AAED,SAAO,IAAP;AACD","sourcesContent":["import Shape from '../../util/Shape';\nimport { getColors } from '../../util/color';\n\n/**\n * Paint pixels on the current image.\n * @memberof Image\n * @instance\n * @param {Array<Array<number>>} points - Array of [x,y] points\n * @param {object} [options]\n * @param {Array<number>|string}     [options.color] - Array of 3 elements (R, G, B) or a valid css color.\n * @param {Array<Array<number>>|Array<string>} [options.colors] - Array of Array of 3 elements (R, G, B) for each color of each mask\n * @param {boolean}             [options.randomColors=true] - To paint each mask with a random color if color and colors are undefined\n * @param {boolean}             [options.distinctColors=false] - To paint each mask with a different color if color and colors are undefined\n * @param {object} [options.shape] - Definition of the shape, see Shape contructor.\n * @return {this} The original painted image\n */\nexport default function paintPoints(points, options = {}) {\n  let { shape } = options;\n\n  this.checkProcessable('paintPoints', {\n    bitDepth: [8, 16],\n  });\n\n  let colors = getColors(\n    Object.assign({}, options, { numberColors: points.length }),\n  );\n\n  let shapePixels = new Shape(shape).getPoints();\n\n  let numberChannels = Math.min(this.channels, colors[0].length);\n\n  for (let i = 0; i < points.length; i++) {\n    let color = colors[i % colors.length];\n    let xP = points[i][0];\n    let yP = points[i][1];\n    for (let j = 0; j < shapePixels.length; j++) {\n      let xS = shapePixels[j][0];\n      let yS = shapePixels[j][1];\n      if (\n        xP + xS >= 0 &&\n        yP + yS >= 0 &&\n        xP + xS < this.width &&\n        yP + yS < this.height\n      ) {\n        let position = (xP + xS + (yP + yS) * this.width) * this.channels;\n        for (let channel = 0; channel < numberChannels; channel++) {\n          this.data[position + channel] = color[channel];\n        }\n      }\n    }\n  }\n\n  return this;\n}\n"]},"metadata":{},"sourceType":"module"}