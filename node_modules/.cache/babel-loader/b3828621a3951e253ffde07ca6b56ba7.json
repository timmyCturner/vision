{"ast":null,"code":"/**\n * Find intersection of points between two different masks\n * @memberof Image\n * @instance\n * @param {Image} mask2 - a mask (1 bit image)\n * @return {object} - object containing number of white pixels for mask1, for mask 2 and for them both\n */\nexport default function getIntersection(mask2) {\n  let mask1 = this;\n  let closestParent = mask1.getClosestCommonParent(mask2);\n  let startPos1 = mask1.getRelativePosition(closestParent, {\n    defaultFurther: true\n  });\n  let allRelPos1 = getRelativePositionForAllPixels(mask1, startPos1);\n  let startPos2 = mask2.getRelativePosition(closestParent, {\n    defaultFurther: true\n  });\n  let allRelPos2 = getRelativePositionForAllPixels(mask2, startPos2);\n  let commonSurface = getCommonSurface(allRelPos1, allRelPos2);\n  let intersection = {\n    whitePixelsMask1: [],\n    whitePixelsMask2: [],\n    commonWhitePixels: []\n  };\n\n  for (let i = 0; i < commonSurface.length; i++) {\n    let currentRelativePos = commonSurface[i];\n    let realPos1 = [currentRelativePos[0] - startPos1[0], currentRelativePos[1] - startPos1[1]];\n    let realPos2 = [currentRelativePos[0] - startPos2[0], currentRelativePos[1] - startPos2[1]];\n    let valueBitMask1 = mask1.getBitXY(realPos1[0], realPos1[1]);\n    let valueBitMask2 = mask2.getBitXY(realPos2[0], realPos2[1]);\n\n    if (valueBitMask1 === 1 && valueBitMask2 === 1) {\n      intersection.commonWhitePixels.push(currentRelativePos);\n    }\n  }\n\n  for (let i = 0; i < allRelPos1.length; i++) {\n    let posX;\n    let posY;\n\n    if (i !== 0) {\n      posX = Math.floor(i / mask1.width);\n      posY = i % mask1.width;\n    }\n\n    if (mask1.getBitXY(posX, posY) === 1) {\n      intersection.whitePixelsMask1.push(allRelPos1[i]);\n    }\n  }\n\n  for (let i = 0; i < allRelPos2.length; i++) {\n    let posX = 0;\n    let posY = 0;\n\n    if (i !== 0) {\n      posX = Math.floor(i / mask2.width);\n      posY = i % mask2.width;\n    }\n\n    if (mask2.getBitXY(posX, posY) === 1) {\n      intersection.whitePixelsMask2.push(allRelPos2[i]);\n    }\n  }\n\n  return intersection;\n}\n/**\n * Get relative position array for all pixels in masks\n * @param {Image} mask - a mask (1 bit image)\n * @param {Array<number>} startPosition - start position of mask relative to parent\n * @return {Array} - relative position of all pixels\n * @private\n */\n\nfunction getRelativePositionForAllPixels(mask, startPosition) {\n  let relativePositions = [];\n\n  for (let i = 0; i < mask.height; i++) {\n    for (let j = 0; j < mask.width; j++) {\n      let originalPos = [i, j];\n      relativePositions.push([originalPos[0] + startPosition[0], originalPos[1] + startPosition[1]]);\n    }\n  }\n\n  return relativePositions;\n}\n/**\n * Finds common surface for two arrays containing the positions of the pixels relative to parent image\n * @param {Array<number>} positionArray1 - positions of pixels relative to parent\n * @param {Array<number>} positionArray2 - positions of pixels relative to parent\n * @return {Array<number>} - positions of common pixels for both arrays\n * @private\n */\n\n\nfunction getCommonSurface(positionArray1, positionArray2) {\n  let i = 0;\n  let j = 0;\n  let commonSurface = [];\n\n  while (i < positionArray1.length && j < positionArray2.length) {\n    if (positionArray1[i][0] === positionArray2[j][0] && positionArray1[i][1] === positionArray2[j][1]) {\n      commonSurface.push(positionArray1[i]);\n      i++;\n      j++;\n    } else if (positionArray1[i][0] < positionArray2[j][0] || positionArray1[i][0] === positionArray2[j][0] && positionArray1[i][1] < positionArray2[j][1]) {\n      i++;\n    } else {\n      j++;\n    }\n  }\n\n  return commonSurface;\n}","map":{"version":3,"sources":["C:/Users/kuent/Documents/FinishDipshit/Creative/Ocean-Weather-Visualization/node_modules/image-js/src/image/utility/getIntersection.js"],"names":["getIntersection","mask2","mask1","closestParent","getClosestCommonParent","startPos1","getRelativePosition","defaultFurther","allRelPos1","getRelativePositionForAllPixels","startPos2","allRelPos2","commonSurface","getCommonSurface","intersection","whitePixelsMask1","whitePixelsMask2","commonWhitePixels","i","length","currentRelativePos","realPos1","realPos2","valueBitMask1","getBitXY","valueBitMask2","push","posX","posY","Math","floor","width","mask","startPosition","relativePositions","height","j","originalPos","positionArray1","positionArray2"],"mappings":"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","sourcesContent":["/**\n * Find intersection of points between two different masks\n * @memberof Image\n * @instance\n * @param {Image} mask2 - a mask (1 bit image)\n * @return {object} - object containing number of white pixels for mask1, for mask 2 and for them both\n */\nexport default function getIntersection(mask2) {\n  let mask1 = this;\n  let closestParent = mask1.getClosestCommonParent(mask2);\n\n  let startPos1 = mask1.getRelativePosition(closestParent, {\n    defaultFurther: true,\n  });\n  let allRelPos1 = getRelativePositionForAllPixels(mask1, startPos1);\n  let startPos2 = mask2.getRelativePosition(closestParent, {\n    defaultFurther: true,\n  });\n  let allRelPos2 = getRelativePositionForAllPixels(mask2, startPos2);\n\n  let commonSurface = getCommonSurface(allRelPos1, allRelPos2);\n  let intersection = {\n    whitePixelsMask1: [],\n    whitePixelsMask2: [],\n    commonWhitePixels: [],\n  };\n\n  for (let i = 0; i < commonSurface.length; i++) {\n    let currentRelativePos = commonSurface[i];\n    let realPos1 = [\n      currentRelativePos[0] - startPos1[0],\n      currentRelativePos[1] - startPos1[1],\n    ];\n    let realPos2 = [\n      currentRelativePos[0] - startPos2[0],\n      currentRelativePos[1] - startPos2[1],\n    ];\n    let valueBitMask1 = mask1.getBitXY(realPos1[0], realPos1[1]);\n    let valueBitMask2 = mask2.getBitXY(realPos2[0], realPos2[1]);\n\n    if (valueBitMask1 === 1 && valueBitMask2 === 1) {\n      intersection.commonWhitePixels.push(currentRelativePos);\n    }\n  }\n\n  for (let i = 0; i < allRelPos1.length; i++) {\n    let posX;\n    let posY;\n    if (i !== 0) {\n      posX = Math.floor(i / mask1.width);\n      posY = i % mask1.width;\n    }\n    if (mask1.getBitXY(posX, posY) === 1) {\n      intersection.whitePixelsMask1.push(allRelPos1[i]);\n    }\n  }\n\n  for (let i = 0; i < allRelPos2.length; i++) {\n    let posX = 0;\n    let posY = 0;\n    if (i !== 0) {\n      posX = Math.floor(i / mask2.width);\n      posY = i % mask2.width;\n    }\n    if (mask2.getBitXY(posX, posY) === 1) {\n      intersection.whitePixelsMask2.push(allRelPos2[i]);\n    }\n  }\n\n  return intersection;\n}\n\n/**\n * Get relative position array for all pixels in masks\n * @param {Image} mask - a mask (1 bit image)\n * @param {Array<number>} startPosition - start position of mask relative to parent\n * @return {Array} - relative position of all pixels\n * @private\n */\nfunction getRelativePositionForAllPixels(mask, startPosition) {\n  let relativePositions = [];\n  for (let i = 0; i < mask.height; i++) {\n    for (let j = 0; j < mask.width; j++) {\n      let originalPos = [i, j];\n      relativePositions.push([\n        originalPos[0] + startPosition[0],\n        originalPos[1] + startPosition[1],\n      ]);\n    }\n  }\n  return relativePositions;\n}\n\n/**\n * Finds common surface for two arrays containing the positions of the pixels relative to parent image\n * @param {Array<number>} positionArray1 - positions of pixels relative to parent\n * @param {Array<number>} positionArray2 - positions of pixels relative to parent\n * @return {Array<number>} - positions of common pixels for both arrays\n * @private\n */\nfunction getCommonSurface(positionArray1, positionArray2) {\n  let i = 0;\n  let j = 0;\n  let commonSurface = [];\n  while (i < positionArray1.length && j < positionArray2.length) {\n    if (\n      positionArray1[i][0] === positionArray2[j][0] &&\n      positionArray1[i][1] === positionArray2[j][1]\n    ) {\n      commonSurface.push(positionArray1[i]);\n      i++;\n      j++;\n    } else if (\n      positionArray1[i][0] < positionArray2[j][0] ||\n      (positionArray1[i][0] === positionArray2[j][0] &&\n        positionArray1[i][1] < positionArray2[j][1])\n    ) {\n      i++;\n    } else {\n      j++;\n    }\n  }\n  return commonSurface;\n}\n"]},"metadata":{},"sourceType":"module"}