{"ast":null,"code":"export default function wave(p) {\n  let xspacing = 16; // Distance between each horizontal location\n\n  let w; // Width of entire wave\n\n  let theta = 0.15; // Start angle at 0\n\n  let amplitude = 75.0; // Height of wave\n\n  let period = 500.0; // How many pixels before the wave repeats\n\n  let dx = 2; // Value for incrementing x\n\n  let yvalues; // Using an array to store height values for the wave\n\n  let backvalues;\n  let back = 2; // back offset\n\n  p.setup = () => {\n    p.createCanvas(600, 300);\n    w = p.width + 16;\n    dx = 2 * Math.PI / period * xspacing;\n    yvalues = new Array(p.floor(w / xspacing));\n    backvalues = new Array(p.floor(w / xspacing));\n  };\n\n  p.draw = () => {\n    p.background(\"blue\");\n    p.calcWave();\n    p.renderWave();\n    p.backWave();\n  };\n\n  p.calcWave = () => {\n    // Increment theta (try different values for\n    // 'angular velocity' here)\n    theta += 0.02; // For every x value, calculate a y value with sine function\n\n    let x = theta;\n\n    for (let i = 0; i < yvalues.length; i++) {\n      yvalues[i] = Math.sin(x) * amplitude;\n      backvalues[i] = Math.sin(x + back) * amplitude;\n      x += dx;\n    }\n  };\n\n  p.renderWave = () => {\n    p.noStroke();\n    p.fill(37, 207, 122); // A simple way to draw the wave with an ellipse at each location\n\n    for (let x = 0; x < yvalues.length; x++) {\n      var waveHeight = 4 * p.height / 8 + yvalues[x];\n      p.ellipse(x * xspacing, p.height, 64, waveHeight);\n    }\n  };\n\n  p.backWave = () => {\n    p.noStroke();\n    p.fill(19, 149, 244); // A simple way to draw the wave with an ellipse at each location\n\n    for (let x = 0; x < backvalues.length; x++) {\n      var waveHeight = 4 * p.height / 8 + backvalues[x];\n      p.ellipse(x * xspacing, p.height, 64, waveHeight);\n    }\n  };\n}","map":{"version":3,"sources":["C:/Users/kuent/Documents/FinishDipshit/Creative/Ocean-Weather-Visualization/src/sketches/wave.js"],"names":["wave","p","xspacing","w","theta","amplitude","period","dx","yvalues","backvalues","back","setup","createCanvas","width","Math","PI","Array","floor","draw","background","calcWave","renderWave","backWave","x","i","length","sin","noStroke","fill","waveHeight","height","ellipse"],"mappings":"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","sourcesContent":["export default function wave(p) {\r\n    let xspacing = 16; // Distance between each horizontal location\r\n    let w; // Width of entire wave\r\n    let theta = 0.15; // Start angle at 0\r\n    let amplitude = 75.0; // Height of wave\r\n    let period = 500.0; // How many pixels before the wave repeats\r\n    let dx = 2; // Value for incrementing x\r\n    let yvalues; // Using an array to store height values for the wave\r\n    let backvalues;\r\n    let back = 2; // back offset\r\n\r\n    p.setup = () => {\r\n        p.createCanvas(600, 300);\r\n        w = p.width + 16;\r\n        dx = ((2 * Math.PI) / period) * xspacing;\r\n        yvalues = new Array(p.floor(w / xspacing));\r\n        backvalues = new Array(p.floor(w / xspacing));\r\n    };\r\n    p.draw = () => {\r\n        p.background(\"blue\");\r\n        p.calcWave();\r\n        p.renderWave();\r\n        p.backWave();\r\n    };\r\n\r\n    p.calcWave = () => {\r\n        // Increment theta (try different values for\r\n        // 'angular velocity' here)\r\n        theta += 0.02;\r\n\r\n        // For every x value, calculate a y value with sine function\r\n        let x = theta;\r\n        for (let i = 0; i < yvalues.length; i++) {\r\n            yvalues[i] = Math.sin(x) * amplitude;\r\n            backvalues[i] = Math.sin(x + back) * amplitude;\r\n            x += dx;\r\n        }\r\n    };\r\n    p.renderWave = () => {\r\n        p.noStroke();\r\n        p.fill(37, 207, 122);\r\n        // A simple way to draw the wave with an ellipse at each location\r\n        for (let x = 0; x < yvalues.length; x++) {\r\n            var waveHeight = (4 * p.height) / 8 + yvalues[x];\r\n            p.ellipse(x * xspacing, p.height, 64, waveHeight);\r\n        }\r\n    };\r\n    p.backWave = () => {\r\n        p.noStroke();\r\n        p.fill(19, 149, 244);\r\n        // A simple way to draw the wave with an ellipse at each location\r\n        for (let x = 0; x < backvalues.length; x++) {\r\n            var waveHeight = (4 * p.height) / 8 + backvalues[x];\r\n            p.ellipse(x * xspacing, p.height, 64, waveHeight);\r\n        }\r\n    };\r\n}\r\n"]},"metadata":{},"sourceType":"module"}