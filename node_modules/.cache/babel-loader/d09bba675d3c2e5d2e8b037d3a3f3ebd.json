{"ast":null,"code":"// see https://github.com/fiji/Auto_Threshold/blob/master/src/main/java/fiji/threshold/Auto_Threshold.java\n// J. M. S. Prewitt and M. L. Mendelsohn, \"The analysis of cell images,\" in\n// Annals of the New York Academy of Sciences, vol. 128, pp. 1035-1053, 1966.\n// ported to ImageJ plugin by G.Landini from Antti Niemisto's Matlab code (GPL)\n// Original Matlab code Copyright (C) 2004 Antti Niemisto\n// See http://www.cs.tut.fi/~ant/histthresh/ for an excellent slide presentation\n// and the original Matlab code\nexport default function minimum(histogram) {\n  if (histogram.length < 2) {\n    // validate that the histogram has at least two color values\n    return 0;\n  }\n\n  let iterations = 0; // number of iterations of the smoothing process\n\n  let threshold = -1;\n  let max = -1; // maximum color value with a greater number of pixels to 0\n\n  let histogramCopy = new Array(histogram.length); // a copy of the histogram\n\n  for (let i = 0; i < histogram.length; i++) {\n    histogramCopy[i] = histogram[i];\n\n    if (histogram[i] > 0) {\n      max = i;\n    }\n  }\n\n  while (!bimodalTest(histogramCopy)) {\n    histogramCopy = smoothed(histogramCopy);\n    iterations++;\n\n    if (iterations > 10000) {\n      // if they occur more than 10000 iterations it returns -1\n      return threshold;\n    }\n  }\n\n  threshold = minimumBetweenPeeks(histogramCopy, max);\n  return threshold;\n}\n\nfunction smoothed(histogram) {\n  // Smooth with a 3 point running mean filter\n  let auHistogram = new Array(histogram.length); // a copy of the histograma for the smoothing process\n\n  for (let i = 1; i < histogram.length - 1; i++) {\n    auHistogram[i] = (histogram[i - 1] + histogram[i] + histogram[i + 1]) / 3;\n  }\n\n  auHistogram[0] = (histogram[0] + histogram[1]) / 3;\n  auHistogram[histogram.length - 1] = (histogram[histogram.length - 2] + histogram[histogram.length - 1]) / 3;\n  return auHistogram;\n}\n\nfunction minimumBetweenPeeks(histogramBimodal, max) {\n  let threshold;\n\n  for (let i = 1; i < max; i++) {\n    if (histogramBimodal[i - 1] > histogramBimodal[i] && histogramBimodal[i + 1] >= histogramBimodal[i]) {\n      threshold = i;\n      break;\n    }\n  }\n\n  return threshold;\n}\n\nfunction bimodalTest(histogram) {\n  // It is responsible for determining if a histogram is bimodal\n  let len = histogram.length;\n  let isBimodal = false;\n  let peaks = 0;\n\n  for (let k = 1; k < len - 1; k++) {\n    if (histogram[k - 1] < histogram[k] && histogram[k + 1] < histogram[k]) {\n      peaks++;\n\n      if (peaks > 2) {\n        return false;\n      }\n    }\n  }\n\n  if (peaks === 2) {\n    isBimodal = true;\n  }\n\n  return isBimodal;\n}","map":{"version":3,"sources":["C:/Users/kuent/Documents/FinishDipshit/Creative/Ocean-Weather-Visualization/node_modules/image-js/src/image/transform/mask/minimum.js"],"names":["minimum","histogram","length","iterations","threshold","max","histogramCopy","Array","i","bimodalTest","smoothed","minimumBetweenPeeks","auHistogram","histogramBimodal","len","isBimodal","peaks","k"],"mappings":"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","sourcesContent":["// see https://github.com/fiji/Auto_Threshold/blob/master/src/main/java/fiji/threshold/Auto_Threshold.java\n// J. M. S. Prewitt and M. L. Mendelsohn, \"The analysis of cell images,\" in\n// Annals of the New York Academy of Sciences, vol. 128, pp. 1035-1053, 1966.\n// ported to ImageJ plugin by G.Landini from Antti Niemisto's Matlab code (GPL)\n// Original Matlab code Copyright (C) 2004 Antti Niemisto\n// See http://www.cs.tut.fi/~ant/histthresh/ for an excellent slide presentation\n// and the original Matlab code\nexport default function minimum(histogram) {\n  if (histogram.length < 2) {\n    // validate that the histogram has at least two color values\n    return 0;\n  }\n  let iterations = 0; // number of iterations of the smoothing process\n  let threshold = -1;\n  let max = -1; // maximum color value with a greater number of pixels to 0\n  let histogramCopy = new Array(histogram.length); // a copy of the histogram\n  for (let i = 0; i < histogram.length; i++) {\n    histogramCopy[i] = histogram[i];\n    if (histogram[i] > 0) {\n      max = i;\n    }\n  }\n  while (!bimodalTest(histogramCopy)) {\n    histogramCopy = smoothed(histogramCopy);\n    iterations++;\n    if (iterations > 10000) {\n      // if they occur more than 10000 iterations it returns -1\n      return threshold;\n    }\n  }\n  threshold = minimumBetweenPeeks(histogramCopy, max);\n  return threshold;\n}\nfunction smoothed(histogram) {\n  // Smooth with a 3 point running mean filter\n  let auHistogram = new Array(histogram.length); // a copy of the histograma for the smoothing process\n  for (let i = 1; i < histogram.length - 1; i++) {\n    auHistogram[i] = (histogram[i - 1] + histogram[i] + histogram[i + 1]) / 3;\n  }\n  auHistogram[0] = (histogram[0] + histogram[1]) / 3;\n  auHistogram[histogram.length - 1] =\n    (histogram[histogram.length - 2] + histogram[histogram.length - 1]) / 3;\n  return auHistogram;\n}\nfunction minimumBetweenPeeks(histogramBimodal, max) {\n  let threshold;\n  for (let i = 1; i < max; i++) {\n    if (\n      histogramBimodal[i - 1] > histogramBimodal[i] &&\n      histogramBimodal[i + 1] >= histogramBimodal[i]\n    ) {\n      threshold = i;\n      break;\n    }\n  }\n  return threshold;\n}\nfunction bimodalTest(histogram) {\n  // It is responsible for determining if a histogram is bimodal\n  let len = histogram.length;\n  let isBimodal = false;\n  let peaks = 0;\n  for (let k = 1; k < len - 1; k++) {\n    if (histogram[k - 1] < histogram[k] && histogram[k + 1] < histogram[k]) {\n      peaks++;\n      if (peaks > 2) {\n        return false;\n      }\n    }\n  }\n  if (peaks === 2) {\n    isBimodal = true;\n  }\n  return isBimodal;\n}\n"]},"metadata":{},"sourceType":"module"}