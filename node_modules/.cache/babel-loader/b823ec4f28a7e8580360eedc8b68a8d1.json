{"ast":null,"code":"import hasOwn from 'has-own';\nimport Image from '../image/Image';\nimport extend from './extend';\nlet computedPropertyDescriptor = {\n  configurable: true,\n  enumerable: false,\n  get: undefined\n};\n/**\n * Class representing stack of images\n * @class Stack\n */\n\nexport default class Stack extends Array {\n  constructor(images) {\n    if (Array.isArray(images)) {\n      super(images.length);\n\n      for (let i = 0; i < images.length; i++) {\n        this[i] = images[i];\n      }\n    } else if (typeof images === 'number') {\n      super(images);\n    } else {\n      super();\n    }\n\n    this.computed = null;\n  }\n\n  static load(urls) {\n    return Promise.all(urls.map(Image.load)).then(images => new Stack(images));\n  }\n\n  static extendMethod(name, method, options = {}) {\n    let {\n      inPlace = false,\n      returnThis = true,\n      partialArgs = []\n    } = options;\n\n    if (inPlace) {\n      Stack.prototype[name] = function (...args) {\n        // remove computed properties\n        this.computed = null;\n        let result = method.apply(this, [...partialArgs, ...args]);\n\n        if (returnThis) {\n          return this;\n        }\n\n        return result;\n      };\n    } else {\n      Stack.prototype[name] = function (...args) {\n        return method.apply(this, [...partialArgs, ...args]);\n      };\n    }\n\n    return Stack;\n  }\n\n  static extendProperty(name, method, options = {}) {\n    let {\n      partialArgs = []\n    } = options;\n\n    computedPropertyDescriptor.get = function () {\n      if (this.computed === null) {\n        this.computed = {};\n      } else if (hasOwn(name, this.computed)) {\n        return this.computed[name];\n      }\n\n      let result = method.apply(this, partialArgs);\n      this.computed[name] = result;\n      return result;\n    };\n\n    Object.defineProperty(Stack.prototype, name, computedPropertyDescriptor);\n    return Stack;\n  }\n  /**\n   * Check if a process can be applied on the stack\n   * @param {string} processName\n   * @param {object} [options]\n   * @private\n   */\n\n\n  checkProcessable(processName, options = {}) {\n    if (typeof processName !== 'string') {\n      throw new TypeError('checkProcessable requires as first parameter the processName (a string)');\n    }\n\n    if (this.size === 0) {\n      throw new TypeError(`The process: ${processName} can not be applied on an empty stack`);\n    }\n\n    this[0].checkProcessable(processName, options);\n\n    for (let i = 1; i < this.length; i++) {\n      if ((options.sameSize === undefined || options.sameSize) && this[0].width !== this[i].width) {\n        throw new TypeError(`The process: ${processName} can not be applied if width is not identical in all images`);\n      }\n\n      if ((options.sameSize === undefined || options.sameSize) && this[0].height !== this[i].height) {\n        throw new TypeError(`The process: ${processName} can not be applied if height is not identical in all images`);\n      }\n\n      if ((options.sameAlpha === undefined || options.sameAlpha) && this[0].alpha !== this[i].alpha) {\n        throw new TypeError(`The process: ${processName} can not be applied if alpha is not identical in all images`);\n      }\n\n      if ((options.sameBitDepth === undefined || options.sameBitDepth) && this[0].bitDepth !== this[i].bitDepth) {\n        throw new TypeError(`The process: ${processName} can not be applied if bitDepth is not identical in all images`);\n      }\n\n      if ((options.sameColorModel === undefined || options.sameColorModel) && this[0].colorModel !== this[i].colorModel) {\n        throw new TypeError(`The process: ${processName} can not be applied if colorModel is not identical in all images`);\n      }\n\n      if ((options.sameNumberChannels === undefined || options.sameNumberChannels) && this[0].channels !== this[i].channels) {\n        throw new TypeError(`The process: ${processName} can not be applied if channels is not identical in all images`);\n      }\n    }\n  }\n\n}\n\nif (!Array[Symbol.species]) {\n  // support old engines\n  Stack.prototype.map = function (cb, thisArg) {\n    if (typeof cb !== 'function') {\n      throw new TypeError(`${cb} is not a function`);\n    }\n\n    let newStack = new Stack(this.length);\n\n    for (let i = 0; i < this.length; i++) {\n      newStack[i] = cb.call(thisArg, this[i], i, this);\n    }\n\n    return newStack;\n  };\n}\n\nextend(Stack);","map":{"version":3,"sources":["C:/Users/kuent/Documents/FinishDipshit/Creative/Ocean-Weather-Visualization/node_modules/image-js/src/stack/Stack.js"],"names":["hasOwn","Image","extend","computedPropertyDescriptor","configurable","enumerable","get","undefined","Stack","Array","constructor","images","isArray","length","i","computed","load","urls","Promise","all","map","then","extendMethod","name","method","options","inPlace","returnThis","partialArgs","prototype","args","result","apply","extendProperty","Object","defineProperty","checkProcessable","processName","TypeError","size","sameSize","width","height","sameAlpha","alpha","sameBitDepth","bitDepth","sameColorModel","colorModel","sameNumberChannels","channels","Symbol","species","cb","thisArg","newStack","call"],"mappings":"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","sourcesContent":["import hasOwn from 'has-own';\n\nimport Image from '../image/Image';\n\nimport extend from './extend';\n\nlet computedPropertyDescriptor = {\n  configurable: true,\n  enumerable: false,\n  get: undefined,\n};\n\n/**\n * Class representing stack of images\n * @class Stack\n */\nexport default class Stack extends Array {\n  constructor(images) {\n    if (Array.isArray(images)) {\n      super(images.length);\n      for (let i = 0; i < images.length; i++) {\n        this[i] = images[i];\n      }\n    } else if (typeof images === 'number') {\n      super(images);\n    } else {\n      super();\n    }\n    this.computed = null;\n  }\n\n  static load(urls) {\n    return Promise.all(urls.map(Image.load)).then(\n      (images) => new Stack(images),\n    );\n  }\n\n  static extendMethod(name, method, options = {}) {\n    let { inPlace = false, returnThis = true, partialArgs = [] } = options;\n\n    if (inPlace) {\n      Stack.prototype[name] = function (...args) {\n        // remove computed properties\n        this.computed = null;\n        let result = method.apply(this, [...partialArgs, ...args]);\n        if (returnThis) {\n          return this;\n        }\n        return result;\n      };\n    } else {\n      Stack.prototype[name] = function (...args) {\n        return method.apply(this, [...partialArgs, ...args]);\n      };\n    }\n    return Stack;\n  }\n\n  static extendProperty(name, method, options = {}) {\n    let { partialArgs = [] } = options;\n\n    computedPropertyDescriptor.get = function () {\n      if (this.computed === null) {\n        this.computed = {};\n      } else if (hasOwn(name, this.computed)) {\n        return this.computed[name];\n      }\n      let result = method.apply(this, partialArgs);\n      this.computed[name] = result;\n      return result;\n    };\n    Object.defineProperty(Stack.prototype, name, computedPropertyDescriptor);\n    return Stack;\n  }\n\n  /**\n   * Check if a process can be applied on the stack\n   * @param {string} processName\n   * @param {object} [options]\n   * @private\n   */\n  checkProcessable(processName, options = {}) {\n    if (typeof processName !== 'string') {\n      throw new TypeError(\n        'checkProcessable requires as first parameter the processName (a string)',\n      );\n    }\n    if (this.size === 0) {\n      throw new TypeError(\n        `The process: ${processName} can not be applied on an empty stack`,\n      );\n    }\n    this[0].checkProcessable(processName, options);\n    for (let i = 1; i < this.length; i++) {\n      if (\n        (options.sameSize === undefined || options.sameSize) &&\n        this[0].width !== this[i].width\n      ) {\n        throw new TypeError(\n          `The process: ${processName} can not be applied if width is not identical in all images`,\n        );\n      }\n      if (\n        (options.sameSize === undefined || options.sameSize) &&\n        this[0].height !== this[i].height\n      ) {\n        throw new TypeError(\n          `The process: ${processName} can not be applied if height is not identical in all images`,\n        );\n      }\n      if (\n        (options.sameAlpha === undefined || options.sameAlpha) &&\n        this[0].alpha !== this[i].alpha\n      ) {\n        throw new TypeError(\n          `The process: ${processName} can not be applied if alpha is not identical in all images`,\n        );\n      }\n      if (\n        (options.sameBitDepth === undefined || options.sameBitDepth) &&\n        this[0].bitDepth !== this[i].bitDepth\n      ) {\n        throw new TypeError(\n          `The process: ${processName} can not be applied if bitDepth is not identical in all images`,\n        );\n      }\n      if (\n        (options.sameColorModel === undefined || options.sameColorModel) &&\n        this[0].colorModel !== this[i].colorModel\n      ) {\n        throw new TypeError(\n          `The process: ${processName} can not be applied if colorModel is not identical in all images`,\n        );\n      }\n      if (\n        (options.sameNumberChannels === undefined ||\n          options.sameNumberChannels) &&\n        this[0].channels !== this[i].channels\n      ) {\n        throw new TypeError(\n          `The process: ${processName} can not be applied if channels is not identical in all images`,\n        );\n      }\n    }\n  }\n}\n\nif (!Array[Symbol.species]) {\n  // support old engines\n  Stack.prototype.map = function (cb, thisArg) {\n    if (typeof cb !== 'function') {\n      throw new TypeError(`${cb} is not a function`);\n    }\n    let newStack = new Stack(this.length);\n    for (let i = 0; i < this.length; i++) {\n      newStack[i] = cb.call(thisArg, this[i], i, this);\n    }\n    return newStack;\n  };\n}\n\nextend(Stack);\n"]},"metadata":{},"sourceType":"module"}