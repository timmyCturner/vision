{"ast":null,"code":"'use strict';\n\nvar FFT = require('./fftlib');\n\nvar FFTUtils = {\n  DEBUG: false,\n\n  /**\n   * Calculates the inverse of a 2D Fourier transform\n   *\n   * @param ft\n   * @param ftRows\n   * @param ftCols\n   * @return\n   */\n  ifft2DArray: function (ft, ftRows, ftCols) {\n    var tempTransform = new Array(ftRows * ftCols);\n    var nRows = ftRows / 2;\n    var nCols = (ftCols - 1) * 2; // reverse transform columns\n\n    FFT.init(nRows);\n    var tmpCols = {\n      re: new Array(nRows),\n      im: new Array(nRows)\n    };\n\n    for (var iCol = 0; iCol < ftCols; iCol++) {\n      for (var iRow = nRows - 1; iRow >= 0; iRow--) {\n        tmpCols.re[iRow] = ft[iRow * 2 * ftCols + iCol];\n        tmpCols.im[iRow] = ft[(iRow * 2 + 1) * ftCols + iCol];\n      } //Unnormalized inverse transform\n\n\n      FFT.bt(tmpCols.re, tmpCols.im);\n\n      for (var iRow = nRows - 1; iRow >= 0; iRow--) {\n        tempTransform[iRow * 2 * ftCols + iCol] = tmpCols.re[iRow];\n        tempTransform[(iRow * 2 + 1) * ftCols + iCol] = tmpCols.im[iRow];\n      }\n    } // reverse row transform\n\n\n    var finalTransform = new Array(nRows * nCols);\n    FFT.init(nCols);\n    var tmpRows = {\n      re: new Array(nCols),\n      im: new Array(nCols)\n    };\n    var scale = nCols * nRows;\n\n    for (var iRow = 0; iRow < ftRows; iRow += 2) {\n      tmpRows.re[0] = tempTransform[iRow * ftCols];\n      tmpRows.im[0] = tempTransform[(iRow + 1) * ftCols];\n\n      for (var iCol = 1; iCol < ftCols; iCol++) {\n        tmpRows.re[iCol] = tempTransform[iRow * ftCols + iCol];\n        tmpRows.im[iCol] = tempTransform[(iRow + 1) * ftCols + iCol];\n        tmpRows.re[nCols - iCol] = tempTransform[iRow * ftCols + iCol];\n        tmpRows.im[nCols - iCol] = -tempTransform[(iRow + 1) * ftCols + iCol];\n      } //Unnormalized inverse transform\n\n\n      FFT.bt(tmpRows.re, tmpRows.im);\n      var indexB = iRow / 2 * nCols;\n\n      for (var iCol = nCols - 1; iCol >= 0; iCol--) {\n        finalTransform[indexB + iCol] = tmpRows.re[iCol] / scale;\n      }\n    }\n\n    return finalTransform;\n  },\n\n  /**\n   * Calculates the fourier transform of a matrix of size (nRows,nCols) It is\n   * assumed that both nRows and nCols are a power of two\n   *\n   * On exit the matrix has dimensions (nRows * 2, nCols / 2 + 1) where the\n   * even rows contain the real part and the odd rows the imaginary part of the\n   * transform\n   * @param data\n   * @param nRows\n   * @param nCols\n   * @return\n   */\n  fft2DArray: function (data, nRows, nCols, opt) {\n    var options = Object.assign({}, {\n      inplace: true\n    });\n    var ftCols = nCols / 2 + 1;\n    var ftRows = nRows * 2;\n    var tempTransform = new Array(ftRows * ftCols);\n    FFT.init(nCols); // transform rows\n\n    var tmpRows = {\n      re: new Array(nCols),\n      im: new Array(nCols)\n    };\n    var row1 = {\n      re: new Array(nCols),\n      im: new Array(nCols)\n    };\n    var row2 = {\n      re: new Array(nCols),\n      im: new Array(nCols)\n    };\n    var index, iRow0, iRow1, iRow2, iRow3;\n\n    for (var iRow = 0; iRow < nRows / 2; iRow++) {\n      index = iRow * 2 * nCols;\n      tmpRows.re = data.slice(index, index + nCols);\n      index = (iRow * 2 + 1) * nCols;\n      tmpRows.im = data.slice(index, index + nCols);\n      FFT.fft1d(tmpRows.re, tmpRows.im);\n      this.reconstructTwoRealFFT(tmpRows, row1, row2); //Now lets put back the result into the output array\n\n      iRow0 = iRow * 4 * ftCols;\n      iRow1 = (iRow * 4 + 1) * ftCols;\n      iRow2 = (iRow * 4 + 2) * ftCols;\n      iRow3 = (iRow * 4 + 3) * ftCols;\n\n      for (var k = ftCols - 1; k >= 0; k--) {\n        tempTransform[iRow0 + k] = row1.re[k];\n        tempTransform[iRow1 + k] = row1.im[k];\n        tempTransform[iRow2 + k] = row2.re[k];\n        tempTransform[iRow3 + k] = row2.im[k];\n      }\n    } //console.log(tempTransform);\n\n\n    row1 = null;\n    row2 = null; // transform columns\n\n    var finalTransform = new Array(ftRows * ftCols);\n    FFT.init(nRows);\n    var tmpCols = {\n      re: new Array(nRows),\n      im: new Array(nRows)\n    };\n\n    for (var iCol = ftCols - 1; iCol >= 0; iCol--) {\n      for (var iRow = nRows - 1; iRow >= 0; iRow--) {\n        tmpCols.re[iRow] = tempTransform[iRow * 2 * ftCols + iCol];\n        tmpCols.im[iRow] = tempTransform[(iRow * 2 + 1) * ftCols + iCol]; //TODO Chech why this happens\n\n        if (isNaN(tmpCols.re[iRow])) {\n          tmpCols.re[iRow] = 0;\n        }\n\n        if (isNaN(tmpCols.im[iRow])) {\n          tmpCols.im[iRow] = 0;\n        }\n      }\n\n      FFT.fft1d(tmpCols.re, tmpCols.im);\n\n      for (var iRow = nRows - 1; iRow >= 0; iRow--) {\n        finalTransform[iRow * 2 * ftCols + iCol] = tmpCols.re[iRow];\n        finalTransform[(iRow * 2 + 1) * ftCols + iCol] = tmpCols.im[iRow];\n      }\n    } //console.log(finalTransform);\n\n\n    return finalTransform;\n  },\n\n  /**\n   *\n   * @param fourierTransform\n   * @param realTransform1\n   * @param realTransform2\n   *\n   * Reconstructs the individual Fourier transforms of two simultaneously\n   * transformed series. Based on the Symmetry relationships (the asterisk\n   * denotes the complex conjugate)\n   *\n   * F_{N-n} = F_n^{*} for a purely real f transformed to F\n   *\n   * G_{N-n} = G_n^{*} for a purely imaginary g transformed to G\n   *\n   */\n  reconstructTwoRealFFT: function (fourierTransform, realTransform1, realTransform2) {\n    var length = fourierTransform.re.length; // the components n=0 are trivial\n\n    realTransform1.re[0] = fourierTransform.re[0];\n    realTransform1.im[0] = 0.0;\n    realTransform2.re[0] = fourierTransform.im[0];\n    realTransform2.im[0] = 0.0;\n    var rm, rp, im, ip, j;\n\n    for (var i = length / 2; i > 0; i--) {\n      j = length - i;\n      rm = 0.5 * (fourierTransform.re[i] - fourierTransform.re[j]);\n      rp = 0.5 * (fourierTransform.re[i] + fourierTransform.re[j]);\n      im = 0.5 * (fourierTransform.im[i] - fourierTransform.im[j]);\n      ip = 0.5 * (fourierTransform.im[i] + fourierTransform.im[j]);\n      realTransform1.re[i] = rp;\n      realTransform1.im[i] = im;\n      realTransform1.re[j] = rp;\n      realTransform1.im[j] = -im;\n      realTransform2.re[i] = ip;\n      realTransform2.im[i] = -rm;\n      realTransform2.re[j] = ip;\n      realTransform2.im[j] = rm;\n    }\n  },\n\n  /**\n   * In place version of convolute 2D\n   *\n   * @param ftSignal\n   * @param ftFilter\n   * @param ftRows\n   * @param ftCols\n   * @return\n   */\n  convolute2DI: function (ftSignal, ftFilter, ftRows, ftCols) {\n    var re, im;\n\n    for (var iRow = 0; iRow < ftRows / 2; iRow++) {\n      for (var iCol = 0; iCol < ftCols; iCol++) {\n        //\n        re = ftSignal[iRow * 2 * ftCols + iCol] * ftFilter[iRow * 2 * ftCols + iCol] - ftSignal[(iRow * 2 + 1) * ftCols + iCol] * ftFilter[(iRow * 2 + 1) * ftCols + iCol];\n        im = ftSignal[iRow * 2 * ftCols + iCol] * ftFilter[(iRow * 2 + 1) * ftCols + iCol] + ftSignal[(iRow * 2 + 1) * ftCols + iCol] * ftFilter[iRow * 2 * ftCols + iCol]; //\n\n        ftSignal[iRow * 2 * ftCols + iCol] = re;\n        ftSignal[(iRow * 2 + 1) * ftCols + iCol] = im;\n      }\n    }\n  },\n\n  /**\n   *\n   * @param data\n   * @param kernel\n   * @param nRows\n   * @param nCols\n   * @returns {*}\n   */\n  convolute: function (data, kernel, nRows, nCols, opt) {\n    var ftSpectrum = new Array(nCols * nRows);\n\n    for (var i = 0; i < nRows * nCols; i++) {\n      ftSpectrum[i] = data[i];\n    }\n\n    ftSpectrum = this.fft2DArray(ftSpectrum, nRows, nCols);\n    var dimR = kernel.length;\n    var dimC = kernel[0].length;\n    var ftFilterData = new Array(nCols * nRows);\n\n    for (var i = 0; i < nCols * nRows; i++) {\n      ftFilterData[i] = 0;\n    }\n\n    var iRow, iCol;\n    var shiftR = Math.floor((dimR - 1) / 2);\n    var shiftC = Math.floor((dimC - 1) / 2);\n\n    for (var ir = 0; ir < dimR; ir++) {\n      iRow = (ir - shiftR + nRows) % nRows;\n\n      for (var ic = 0; ic < dimC; ic++) {\n        iCol = (ic - shiftC + nCols) % nCols;\n        ftFilterData[iRow * nCols + iCol] = kernel[ir][ic];\n      }\n    }\n\n    ftFilterData = this.fft2DArray(ftFilterData, nRows, nCols);\n    var ftRows = nRows * 2;\n    var ftCols = nCols / 2 + 1;\n    this.convolute2DI(ftSpectrum, ftFilterData, ftRows, ftCols);\n    return this.ifft2DArray(ftSpectrum, ftRows, ftCols);\n  },\n  toRadix2: function (data, nRows, nCols) {\n    var i, j, irow, icol;\n    var cols = nCols,\n        rows = nRows,\n        prows = 0,\n        pcols = 0;\n\n    if (!(nCols !== 0 && (nCols & nCols - 1) === 0)) {\n      //Then we have to make a pading to next radix2\n      cols = 0;\n\n      while (nCols >> ++cols != 0);\n\n      cols = 1 << cols;\n      pcols = cols - nCols;\n    }\n\n    if (!(nRows !== 0 && (nRows & nRows - 1) === 0)) {\n      //Then we have to make a pading to next radix2\n      rows = 0;\n\n      while (nRows >> ++rows != 0);\n\n      rows = 1 << rows;\n      prows = (rows - nRows) * cols;\n    }\n\n    if (rows == nRows && cols == nCols) //Do nothing. Returns the same input!!! Be careful\n      return {\n        data: data,\n        rows: nRows,\n        cols: nCols\n      };\n    var output = new Array(rows * cols);\n    var shiftR = Math.floor((rows - nRows) / 2) - nRows;\n    var shiftC = Math.floor((cols - nCols) / 2) - nCols;\n\n    for (i = 0; i < rows; i++) {\n      irow = i * cols;\n      icol = (i - shiftR) % nRows * nCols;\n\n      for (j = 0; j < cols; j++) {\n        output[irow + j] = data[icol + (j - shiftC) % nCols];\n      }\n    }\n\n    return {\n      data: output,\n      rows: rows,\n      cols: cols\n    };\n  },\n\n  /**\n   * Crop the given matrix to fit the corresponding number of rows and columns\n   */\n  crop: function (data, rows, cols, nRows, nCols, opt) {\n    if (rows == nRows && cols == nCols) //Do nothing. Returns the same input!!! Be careful\n      return data;\n    var options = Object.assign({}, opt);\n    var output = new Array(nCols * nRows);\n    var shiftR = Math.floor((rows - nRows) / 2);\n    var shiftC = Math.floor((cols - nCols) / 2);\n    var destinyRow, sourceRow, i, j;\n\n    for (i = 0; i < nRows; i++) {\n      destinyRow = i * nCols;\n      sourceRow = (i + shiftR) * cols;\n\n      for (j = 0; j < nCols; j++) {\n        output[destinyRow + j] = data[sourceRow + (j + shiftC)];\n      }\n    }\n\n    return output;\n  }\n};\nmodule.exports = FFTUtils;","map":{"version":3,"sources":["C:/Users/kuent/Documents/FinishDipshit/Creative/Ocean-Weather-Visualization/node_modules/ml-fft/src/FFTUtils.js"],"names":["FFT","require","FFTUtils","DEBUG","ifft2DArray","ft","ftRows","ftCols","tempTransform","Array","nRows","nCols","init","tmpCols","re","im","iCol","iRow","bt","finalTransform","tmpRows","scale","indexB","fft2DArray","data","opt","options","Object","assign","inplace","row1","row2","index","iRow0","iRow1","iRow2","iRow3","slice","fft1d","reconstructTwoRealFFT","k","isNaN","fourierTransform","realTransform1","realTransform2","length","rm","rp","ip","j","i","convolute2DI","ftSignal","ftFilter","convolute","kernel","ftSpectrum","dimR","dimC","ftFilterData","shiftR","Math","floor","shiftC","ir","ic","toRadix2","irow","icol","cols","rows","prows","pcols","output","crop","destinyRow","sourceRow","module","exports"],"mappings":"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","sourcesContent":["'use strict'\n\nvar FFT = require('./fftlib');\n\nvar FFTUtils= {\n    DEBUG : false,\n\n    /**\n     * Calculates the inverse of a 2D Fourier transform\n     *\n     * @param ft\n     * @param ftRows\n     * @param ftCols\n     * @return\n     */\n    ifft2DArray : function(ft, ftRows, ftCols){\n        var tempTransform = new Array(ftRows * ftCols);\n        var nRows = ftRows / 2;\n        var nCols = (ftCols - 1) * 2;\n        // reverse transform columns\n        FFT.init(nRows);\n        var tmpCols = {re: new Array(nRows), im: new Array(nRows)};\n        for (var iCol = 0; iCol < ftCols; iCol++) {\n            for (var iRow = nRows - 1; iRow >= 0; iRow--) {\n                tmpCols.re[iRow] = ft[(iRow * 2) * ftCols + iCol];\n                tmpCols.im[iRow] = ft[(iRow * 2 + 1) * ftCols + iCol];\n            }\n            //Unnormalized inverse transform\n            FFT.bt(tmpCols.re, tmpCols.im);\n            for (var iRow = nRows - 1; iRow >= 0; iRow--) {\n                tempTransform[(iRow * 2) * ftCols + iCol] = tmpCols.re[iRow];\n                tempTransform[(iRow * 2 + 1) * ftCols + iCol] = tmpCols.im[iRow];\n            }\n        }\n\n        // reverse row transform\n        var finalTransform = new Array(nRows * nCols);\n        FFT.init(nCols);\n        var tmpRows = {re: new Array(nCols), im: new Array(nCols)};\n        var scale = nCols * nRows;\n        for (var iRow = 0; iRow < ftRows; iRow += 2) {\n            tmpRows.re[0] = tempTransform[iRow * ftCols];\n            tmpRows.im[0] = tempTransform[(iRow + 1) * ftCols];\n            for (var iCol = 1; iCol < ftCols; iCol++) {\n                tmpRows.re[iCol] = tempTransform[iRow * ftCols + iCol];\n                tmpRows.im[iCol] = tempTransform[(iRow + 1) * ftCols + iCol];\n                tmpRows.re[nCols - iCol] = tempTransform[iRow * ftCols + iCol];\n                tmpRows.im[nCols - iCol] = -tempTransform[(iRow + 1) * ftCols + iCol];\n            }\n            //Unnormalized inverse transform\n            FFT.bt(tmpRows.re, tmpRows.im);\n\n            var indexB = (iRow / 2) * nCols;\n            for (var iCol = nCols - 1; iCol >= 0; iCol--) {\n                finalTransform[indexB + iCol] = tmpRows.re[iCol] / scale;\n            }\n        }\n        return finalTransform;\n    },\n    /**\n     * Calculates the fourier transform of a matrix of size (nRows,nCols) It is\n     * assumed that both nRows and nCols are a power of two\n     *\n     * On exit the matrix has dimensions (nRows * 2, nCols / 2 + 1) where the\n     * even rows contain the real part and the odd rows the imaginary part of the\n     * transform\n     * @param data\n     * @param nRows\n     * @param nCols\n     * @return\n     */\n    fft2DArray:function(data, nRows, nCols, opt) {\n        var options = Object.assign({},{inplace:true})\n        var ftCols = (nCols / 2 + 1);\n        var ftRows = nRows * 2;\n        var tempTransform = new Array(ftRows * ftCols);\n        FFT.init(nCols);\n        // transform rows\n        var tmpRows = {re: new Array(nCols), im: new Array(nCols)};\n        var row1 = {re: new Array(nCols), im: new Array(nCols)}\n        var row2 = {re: new Array(nCols), im: new Array(nCols)}\n        var index, iRow0, iRow1, iRow2, iRow3;\n        for (var iRow = 0; iRow < nRows / 2; iRow++) {\n            index = (iRow * 2) * nCols;\n            tmpRows.re = data.slice(index, index + nCols);\n\n            index = (iRow * 2 + 1) * nCols;\n            tmpRows.im = data.slice(index, index + nCols);\n\n            FFT.fft1d(tmpRows.re, tmpRows.im);\n\n            this.reconstructTwoRealFFT(tmpRows, row1, row2);\n            //Now lets put back the result into the output array\n            iRow0 = (iRow * 4) * ftCols;\n            iRow1 = (iRow * 4 + 1) * ftCols;\n            iRow2 = (iRow * 4 + 2) * ftCols;\n            iRow3 = (iRow * 4 + 3) * ftCols;\n            for (var k = ftCols - 1; k >= 0; k--) {\n                tempTransform[iRow0 + k] = row1.re[k];\n                tempTransform[iRow1 + k] = row1.im[k];\n                tempTransform[iRow2 + k] = row2.re[k];\n                tempTransform[iRow3 + k] = row2.im[k];\n            }\n        }\n\n        //console.log(tempTransform);\n        row1 = null;\n        row2 = null;\n        // transform columns\n        var finalTransform = new Array(ftRows * ftCols);\n\n        FFT.init(nRows);\n        var tmpCols = {re: new Array(nRows), im: new Array(nRows)};\n        for (var iCol = ftCols - 1; iCol >= 0; iCol--) {\n            for (var iRow = nRows - 1; iRow >= 0; iRow--) {\n                tmpCols.re[iRow] = tempTransform[(iRow * 2) * ftCols + iCol];\n                tmpCols.im[iRow] = tempTransform[(iRow * 2 + 1) * ftCols + iCol];\n                //TODO Chech why this happens\n                if(isNaN(tmpCols.re[iRow])){\n                    tmpCols.re[iRow]=0;\n                }\n                if(isNaN(tmpCols.im[iRow])){\n                    tmpCols.im[iRow]=0;\n                }\n            }\n            FFT.fft1d(tmpCols.re, tmpCols.im);\n            for (var iRow = nRows - 1; iRow >= 0; iRow--) {\n                finalTransform[(iRow * 2) * ftCols + iCol] = tmpCols.re[iRow];\n                finalTransform[(iRow * 2 + 1) * ftCols + iCol] = tmpCols.im[iRow];\n            }\n        }\n\n        //console.log(finalTransform);\n        return finalTransform;\n\n    },\n    /**\n     *\n     * @param fourierTransform\n     * @param realTransform1\n     * @param realTransform2\n     *\n     * Reconstructs the individual Fourier transforms of two simultaneously\n     * transformed series. Based on the Symmetry relationships (the asterisk\n     * denotes the complex conjugate)\n     *\n     * F_{N-n} = F_n^{*} for a purely real f transformed to F\n     *\n     * G_{N-n} = G_n^{*} for a purely imaginary g transformed to G\n     *\n     */\n    reconstructTwoRealFFT:function(fourierTransform, realTransform1, realTransform2) {\n        var length = fourierTransform.re.length;\n\n        // the components n=0 are trivial\n        realTransform1.re[0] = fourierTransform.re[0];\n        realTransform1.im[0] = 0.0;\n        realTransform2.re[0] = fourierTransform.im[0];\n        realTransform2.im[0] = 0.0;\n        var rm, rp, im, ip, j;\n        for (var i = length / 2; i > 0; i--) {\n            j = length - i;\n            rm = 0.5 * (fourierTransform.re[i] - fourierTransform.re[j]);\n            rp = 0.5 * (fourierTransform.re[i] + fourierTransform.re[j]);\n            im = 0.5 * (fourierTransform.im[i] - fourierTransform.im[j]);\n            ip = 0.5 * (fourierTransform.im[i] + fourierTransform.im[j]);\n            realTransform1.re[i] = rp;\n            realTransform1.im[i] = im;\n            realTransform1.re[j] = rp;\n            realTransform1.im[j] = -im;\n            realTransform2.re[i] = ip;\n            realTransform2.im[i] = -rm;\n            realTransform2.re[j] = ip;\n            realTransform2.im[j] = rm;\n        }\n    },\n\n    /**\n     * In place version of convolute 2D\n     *\n     * @param ftSignal\n     * @param ftFilter\n     * @param ftRows\n     * @param ftCols\n     * @return\n     */\n    convolute2DI:function(ftSignal, ftFilter, ftRows, ftCols) {\n        var re, im;\n        for (var iRow = 0; iRow < ftRows / 2; iRow++) {\n            for (var iCol = 0; iCol < ftCols; iCol++) {\n                //\n                re = ftSignal[(iRow * 2) * ftCols + iCol]\n                    * ftFilter[(iRow * 2) * ftCols + iCol]\n                    - ftSignal[(iRow * 2 + 1) * ftCols + iCol]\n                    * ftFilter[(iRow * 2 + 1) * ftCols + iCol];\n                im = ftSignal[(iRow * 2) * ftCols + iCol]\n                    * ftFilter[(iRow * 2 + 1) * ftCols + iCol]\n                    + ftSignal[(iRow * 2 + 1) * ftCols + iCol]\n                    * ftFilter[(iRow * 2) * ftCols + iCol];\n                //\n                ftSignal[(iRow * 2) * ftCols + iCol] = re;\n                ftSignal[(iRow * 2 + 1) * ftCols + iCol] = im;\n            }\n        }\n    },\n    /**\n     *\n     * @param data\n     * @param kernel\n     * @param nRows\n     * @param nCols\n     * @returns {*}\n     */\n    convolute:function(data, kernel, nRows, nCols, opt) {\n        var ftSpectrum = new Array(nCols * nRows);\n        for (var i = 0; i<nRows * nCols; i++) {\n            ftSpectrum[i] = data[i];\n        }\n\n        ftSpectrum = this.fft2DArray(ftSpectrum, nRows, nCols);\n\n\n        var dimR = kernel.length;\n        var dimC = kernel[0].length;\n        var ftFilterData = new Array(nCols * nRows);\n        for(var i = 0; i < nCols * nRows; i++) {\n            ftFilterData[i] = 0;\n        }\n\n        var iRow, iCol;\n        var shiftR = Math.floor((dimR - 1) / 2);\n        var shiftC = Math.floor((dimC - 1) / 2);\n        for (var ir = 0; ir < dimR; ir++) {\n            iRow = (ir - shiftR + nRows) % nRows;\n            for (var ic = 0; ic < dimC; ic++) {\n                iCol = (ic - shiftC + nCols) % nCols;\n                ftFilterData[iRow * nCols + iCol] = kernel[ir][ic];\n            }\n        }\n        ftFilterData = this.fft2DArray(ftFilterData, nRows, nCols);\n\n        var ftRows = nRows * 2;\n        var ftCols = nCols / 2 + 1;\n        this.convolute2DI(ftSpectrum, ftFilterData, ftRows, ftCols);\n\n        return this.ifft2DArray(ftSpectrum, ftRows, ftCols);\n    },\n\n\n    toRadix2:function(data, nRows, nCols) {\n        var i, j, irow, icol;\n        var cols = nCols, rows = nRows, prows=0, pcols=0;\n        if(!(nCols !== 0 && (nCols & (nCols - 1)) === 0)) {\n            //Then we have to make a pading to next radix2\n            cols = 0;\n            while((nCols>>++cols)!=0);\n            cols=1<<cols;\n            pcols = cols-nCols;\n        }\n        if(!(nRows !== 0 && (nRows & (nRows - 1)) === 0)) {\n            //Then we have to make a pading to next radix2\n            rows = 0;\n            while((nRows>>++rows)!=0);\n            rows=1<<rows;\n            prows = (rows-nRows)*cols;\n        }\n        if(rows==nRows&&cols==nCols)//Do nothing. Returns the same input!!! Be careful\n            return {data:data, rows:nRows, cols:nCols};\n\n        var output = new Array(rows*cols);\n        var shiftR = Math.floor((rows-nRows)/2)-nRows;\n        var shiftC = Math.floor((cols-nCols)/2)-nCols;\n\n        for( i = 0; i < rows; i++) {\n            irow = i*cols;\n            icol = ((i-shiftR) % nRows) * nCols;\n            for( j = 0; j < cols; j++) {\n                output[irow+j] = data[(icol+(j-shiftC) % nCols) ];\n            }\n        }\n        return {data:output, rows:rows, cols:cols};\n    },\n\n    /**\n     * Crop the given matrix to fit the corresponding number of rows and columns\n     */\n    crop:function(data, rows, cols, nRows, nCols, opt) {\n\n        if(rows == nRows && cols == nCols)//Do nothing. Returns the same input!!! Be careful\n            return data;\n\n        var options = Object.assign({}, opt);\n\n        var output = new Array(nCols*nRows);\n\n        var shiftR = Math.floor((rows-nRows)/2);\n        var shiftC = Math.floor((cols-nCols)/2);\n        var destinyRow, sourceRow, i, j;\n        for( i = 0; i < nRows; i++) {\n            destinyRow = i*nCols;\n            sourceRow = (i+shiftR)*cols;\n            for( j = 0;j < nCols; j++) {\n                output[destinyRow+j] = data[sourceRow+(j+shiftC)];\n            }\n        }\n\n        return output;\n    }\n}\n\nmodule.exports = FFTUtils;\n"]},"metadata":{},"sourceType":"script"}