{"ast":null,"code":"import array from 'new-array';\nimport Image from '../Image';\nimport copy from '../internal/copy';\n/**\n * @memberof Image\n * @instance\n * @param {object} [options]\n * @param {number} [options.size=0]\n * @param {string} [options.algorithm='copy']\n * @param {array<number>} [options.color]\n * @return {Image}\n */\n\nexport default function pad(options = {}) {\n  let {\n    size = 0,\n    algorithm = 'copy',\n    color\n  } = options;\n  this.checkProcessable('pad', {\n    bitDepth: [8, 16]\n  });\n\n  if (algorithm === 'set') {\n    if (color.length !== this.channels) {\n      throw new Error(`pad: the color array must have the same length as the number of channels. Here: ${this.channels}`);\n    }\n\n    for (let i = 0; i < color.length; i++) {\n      if (color[i] === 0) {\n        color[i] = 0.001;\n      }\n    }\n  } else {\n    color = array(this.channels, null);\n  }\n\n  if (!Array.isArray(size)) {\n    size = [size, size];\n  }\n\n  let newWidth = this.width + size[0] * 2;\n  let newHeight = this.height + size[1] * 2;\n  let channels = this.channels;\n  let newImage = Image.createFrom(this, {\n    width: newWidth,\n    height: newHeight\n  });\n  copy(this, newImage, size[0], size[1]);\n\n  for (let i = size[0]; i < newWidth - size[0]; i++) {\n    for (let k = 0; k < channels; k++) {\n      let value = color[k] || newImage.data[(size[1] * newWidth + i) * channels + k];\n\n      for (let j = 0; j < size[1]; j++) {\n        newImage.data[(j * newWidth + i) * channels + k] = value;\n      }\n\n      value = color[k] || newImage.data[((newHeight - size[1] - 1) * newWidth + i) * channels + k];\n\n      for (let j = newHeight - size[1]; j < newHeight; j++) {\n        newImage.data[(j * newWidth + i) * channels + k] = value;\n      }\n    }\n  }\n\n  for (let j = 0; j < newHeight; j++) {\n    for (let k = 0; k < channels; k++) {\n      let value = color[k] || newImage.data[(j * newWidth + size[0]) * channels + k];\n\n      for (let i = 0; i < size[0]; i++) {\n        newImage.data[(j * newWidth + i) * channels + k] = value;\n      }\n\n      value = color[k] || newImage.data[(j * newWidth + newWidth - size[0] - 1) * channels + k];\n\n      for (let i = newWidth - size[0]; i < newWidth; i++) {\n        newImage.data[(j * newWidth + i) * channels + k] = value;\n      }\n    }\n  }\n\n  return newImage;\n}","map":{"version":3,"sources":["C:/Users/kuent/Documents/FinishDipshit/Creative/Ocean-Weather-Visualization/node_modules/image-js/src/image/transform/pad.js"],"names":["array","Image","copy","pad","options","size","algorithm","color","checkProcessable","bitDepth","length","channels","Error","i","Array","isArray","newWidth","width","newHeight","height","newImage","createFrom","k","value","data","j"],"mappings":"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","sourcesContent":["import array from 'new-array';\n\nimport Image from '../Image';\nimport copy from '../internal/copy';\n\n/**\n * @memberof Image\n * @instance\n * @param {object} [options]\n * @param {number} [options.size=0]\n * @param {string} [options.algorithm='copy']\n * @param {array<number>} [options.color]\n * @return {Image}\n */\nexport default function pad(options = {}) {\n  let { size = 0, algorithm = 'copy', color } = options;\n\n  this.checkProcessable('pad', {\n    bitDepth: [8, 16],\n  });\n\n  if (algorithm === 'set') {\n    if (color.length !== this.channels) {\n      throw new Error(\n        `pad: the color array must have the same length as the number of channels. Here: ${this.channels}`,\n      );\n    }\n    for (let i = 0; i < color.length; i++) {\n      if (color[i] === 0) {\n        color[i] = 0.001;\n      }\n    }\n  } else {\n    color = array(this.channels, null);\n  }\n\n  if (!Array.isArray(size)) {\n    size = [size, size];\n  }\n\n  let newWidth = this.width + size[0] * 2;\n  let newHeight = this.height + size[1] * 2;\n  let channels = this.channels;\n\n  let newImage = Image.createFrom(this, { width: newWidth, height: newHeight });\n\n  copy(this, newImage, size[0], size[1]);\n\n  for (let i = size[0]; i < newWidth - size[0]; i++) {\n    for (let k = 0; k < channels; k++) {\n      let value =\n        color[k] || newImage.data[(size[1] * newWidth + i) * channels + k];\n      for (let j = 0; j < size[1]; j++) {\n        newImage.data[(j * newWidth + i) * channels + k] = value;\n      }\n      value =\n        color[k] ||\n        newImage.data[\n          ((newHeight - size[1] - 1) * newWidth + i) * channels + k\n        ];\n      for (let j = newHeight - size[1]; j < newHeight; j++) {\n        newImage.data[(j * newWidth + i) * channels + k] = value;\n      }\n    }\n  }\n\n  for (let j = 0; j < newHeight; j++) {\n    for (let k = 0; k < channels; k++) {\n      let value =\n        color[k] || newImage.data[(j * newWidth + size[0]) * channels + k];\n      for (let i = 0; i < size[0]; i++) {\n        newImage.data[(j * newWidth + i) * channels + k] = value;\n      }\n      value =\n        color[k] ||\n        newImage.data[(j * newWidth + newWidth - size[0] - 1) * channels + k];\n      for (let i = newWidth - size[0]; i < newWidth; i++) {\n        newImage.data[(j * newWidth + i) * channels + k] = value;\n      }\n    }\n  }\n\n  return newImage;\n}\n"]},"metadata":{},"sourceType":"module"}