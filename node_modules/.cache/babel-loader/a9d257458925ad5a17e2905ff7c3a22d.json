{"ast":null,"code":"import { IOBuffer } from 'iobuffer';\nimport { deflate } from 'pako';\nimport { pngSignature, crc } from './common';\nimport { ColorType, CompressionMethod, FilterMethod, InterlaceMethod } from './internalTypes';\nconst defaultZlibOptions = {\n  level: 3\n};\nexport default class PNGEncoder extends IOBuffer {\n  constructor(data, options = {}) {\n    super();\n    this._colorType = ColorType.UNKNOWN;\n    this._zlibOptions = Object.assign({}, defaultZlibOptions, options.zlib);\n    this._png = this._checkData(data);\n    this.setBigEndian();\n  }\n\n  encode() {\n    this.encodeSignature();\n    this.encodeIHDR();\n    this.encodeData();\n    this.encodeIEND();\n    return this.toArray();\n  } // https://www.w3.org/TR/PNG/#5PNG-file-signature\n\n\n  encodeSignature() {\n    this.writeBytes(pngSignature);\n  } // https://www.w3.org/TR/PNG/#11IHDR\n\n\n  encodeIHDR() {\n    this.writeUint32(13);\n    this.writeChars('IHDR');\n    this.writeUint32(this._png.width);\n    this.writeUint32(this._png.height);\n    this.writeByte(this._png.depth);\n    this.writeByte(this._colorType);\n    this.writeByte(CompressionMethod.DEFLATE);\n    this.writeByte(FilterMethod.ADAPTIVE);\n    this.writeByte(InterlaceMethod.NO_INTERLACE);\n    this.writeCrc(17);\n  } // https://www.w3.org/TR/PNG/#11IEND\n\n\n  encodeIEND() {\n    this.writeUint32(0);\n    this.writeChars('IEND');\n    this.writeCrc(4);\n  } // https://www.w3.org/TR/PNG/#11IDAT\n\n\n  encodeIDAT(data) {\n    this.writeUint32(data.length);\n    this.writeChars('IDAT');\n    this.writeBytes(data);\n    this.writeCrc(data.length + 4);\n  }\n\n  encodeData() {\n    const {\n      width,\n      height,\n      channels,\n      depth,\n      data\n    } = this._png;\n    const slotsPerLine = channels * width;\n    const newData = new IOBuffer().setBigEndian();\n    let offset = 0;\n\n    for (let i = 0; i < height; i++) {\n      newData.writeByte(0); // no filter\n\n      /* istanbul ignore else */\n\n      if (depth === 8) {\n        offset = writeDataBytes(data, newData, slotsPerLine, offset);\n      } else if (depth === 16) {\n        offset = writeDataUint16(data, newData, slotsPerLine, offset);\n      } else {\n        throw new Error('unreachable');\n      }\n    }\n\n    const buffer = newData.toArray();\n    const compressed = deflate(buffer, this._zlibOptions);\n    this.encodeIDAT(compressed);\n  }\n\n  _checkData(data) {\n    const {\n      colorType,\n      channels,\n      depth\n    } = getColorType(data);\n    const png = {\n      width: checkInteger(data.width, 'width'),\n      height: checkInteger(data.height, 'height'),\n      channels: channels,\n      data: data.data,\n      depth: depth,\n      text: {}\n    };\n    this._colorType = colorType;\n    const expectedSize = png.width * png.height * channels;\n\n    if (png.data.length !== expectedSize) {\n      throw new RangeError(`wrong data size. Found ${png.data.length}, expected ${expectedSize}`);\n    }\n\n    return png;\n  }\n\n  writeCrc(length) {\n    this.writeUint32(crc(new Uint8Array(this.buffer, this.byteOffset + this.offset - length, length), length));\n  }\n\n}\n\nfunction checkInteger(value, name) {\n  if (Number.isInteger(value) && value > 0) {\n    return value;\n  }\n\n  throw new TypeError(`${name} must be a positive integer`);\n}\n\nfunction getColorType(data) {\n  const {\n    channels = 4,\n    depth = 8\n  } = data;\n\n  if (channels !== 4 && channels !== 3 && channels !== 2 && channels !== 1) {\n    throw new RangeError(`unsupported number of channels: ${channels}`);\n  }\n\n  if (depth !== 8 && depth !== 16) {\n    throw new RangeError(`unsupported bit depth: ${depth}`);\n  }\n\n  const returnValue = {\n    channels,\n    depth,\n    colorType: ColorType.UNKNOWN\n  };\n\n  switch (channels) {\n    case 4:\n      returnValue.colorType = ColorType.TRUECOLOUR_ALPHA;\n      break;\n\n    case 3:\n      returnValue.colorType = ColorType.TRUECOLOUR;\n      break;\n\n    case 1:\n      returnValue.colorType = ColorType.GREYSCALE;\n      break;\n\n    case 2:\n      returnValue.colorType = ColorType.GREYSCALE_ALPHA;\n      break;\n\n    default:\n      throw new Error(`unsupported number of channels: ${channels}`);\n  }\n\n  return returnValue;\n}\n\nfunction writeDataBytes(data, newData, slotsPerLine, offset) {\n  for (let j = 0; j < slotsPerLine; j++) {\n    newData.writeByte(data[offset++]);\n  }\n\n  return offset;\n}\n\nfunction writeDataUint16(data, newData, slotsPerLine, offset) {\n  for (let j = 0; j < slotsPerLine; j++) {\n    newData.writeUint16(data[offset++]);\n  }\n\n  return offset;\n}","map":{"version":3,"sources":["../src/PNGEncoder.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { IOBuffer } from 'iobuffer';\r\nimport { deflate } from 'pako';\r\nimport { pngSignature, crc } from './common';\r\nimport { ColorType, CompressionMethod, FilterMethod, InterlaceMethod, } from './internalTypes';\r\nconst defaultZlibOptions = {\r\n    level: 3,\r\n};\r\nexport default class PNGEncoder extends IOBuffer {\r\n    constructor(data, options = {}) {\r\n        super();\r\n        this._colorType = ColorType.UNKNOWN;\r\n        this._zlibOptions = Object.assign({}, defaultZlibOptions, options.zlib);\r\n        this._png = this._checkData(data);\r\n        this.setBigEndian();\r\n    }\r\n    encode() {\r\n        this.encodeSignature();\r\n        this.encodeIHDR();\r\n        this.encodeData();\r\n        this.encodeIEND();\r\n        return this.toArray();\r\n    }\r\n    // https://www.w3.org/TR/PNG/#5PNG-file-signature\r\n    encodeSignature() {\r\n        this.writeBytes(pngSignature);\r\n    }\r\n    // https://www.w3.org/TR/PNG/#11IHDR\r\n    encodeIHDR() {\r\n        this.writeUint32(13);\r\n        this.writeChars('IHDR');\r\n        this.writeUint32(this._png.width);\r\n        this.writeUint32(this._png.height);\r\n        this.writeByte(this._png.depth);\r\n        this.writeByte(this._colorType);\r\n        this.writeByte(CompressionMethod.DEFLATE);\r\n        this.writeByte(FilterMethod.ADAPTIVE);\r\n        this.writeByte(InterlaceMethod.NO_INTERLACE);\r\n        this.writeCrc(17);\r\n    }\r\n    // https://www.w3.org/TR/PNG/#11IEND\r\n    encodeIEND() {\r\n        this.writeUint32(0);\r\n        this.writeChars('IEND');\r\n        this.writeCrc(4);\r\n    }\r\n    // https://www.w3.org/TR/PNG/#11IDAT\r\n    encodeIDAT(data) {\r\n        this.writeUint32(data.length);\r\n        this.writeChars('IDAT');\r\n        this.writeBytes(data);\r\n        this.writeCrc(data.length + 4);\r\n    }\r\n    encodeData() {\r\n        const { width, height, channels, depth, data } = this._png;\r\n        const slotsPerLine = channels * width;\r\n        const newData = new IOBuffer().setBigEndian();\r\n        let offset = 0;\r\n        for (let i = 0; i < height; i++) {\r\n            newData.writeByte(0); // no filter\r\n            /* istanbul ignore else */\r\n            if (depth === 8) {\r\n                offset = writeDataBytes(data, newData, slotsPerLine, offset);\r\n            }\r\n            else if (depth === 16) {\r\n                offset = writeDataUint16(data, newData, slotsPerLine, offset);\r\n            }\r\n            else {\r\n                throw new Error('unreachable');\r\n            }\r\n        }\r\n        const buffer = newData.toArray();\r\n        const compressed = deflate(buffer, this._zlibOptions);\r\n        this.encodeIDAT(compressed);\r\n    }\r\n    _checkData(data) {\r\n        const { colorType, channels, depth } = getColorType(data);\r\n        const png = {\r\n            width: checkInteger(data.width, 'width'),\r\n            height: checkInteger(data.height, 'height'),\r\n            channels: channels,\r\n            data: data.data,\r\n            depth: depth,\r\n            text: {},\r\n        };\r\n        this._colorType = colorType;\r\n        const expectedSize = png.width * png.height * channels;\r\n        if (png.data.length !== expectedSize) {\r\n            throw new RangeError(`wrong data size. Found ${png.data.length}, expected ${expectedSize}`);\r\n        }\r\n        return png;\r\n    }\r\n    writeCrc(length) {\r\n        this.writeUint32(crc(new Uint8Array(this.buffer, this.byteOffset + this.offset - length, length), length));\r\n    }\r\n}\r\nfunction checkInteger(value, name) {\r\n    if (Number.isInteger(value) && value > 0) {\r\n        return value;\r\n    }\r\n    throw new TypeError(`${name} must be a positive integer`);\r\n}\r\nfunction getColorType(data) {\r\n    const { channels = 4, depth = 8 } = data;\r\n    if (channels !== 4 && channels !== 3 && channels !== 2 && channels !== 1) {\r\n        throw new RangeError(`unsupported number of channels: ${channels}`);\r\n    }\r\n    if (depth !== 8 && depth !== 16) {\r\n        throw new RangeError(`unsupported bit depth: ${depth}`);\r\n    }\r\n    const returnValue = { channels, depth, colorType: ColorType.UNKNOWN };\r\n    switch (channels) {\r\n        case 4:\r\n            returnValue.colorType = ColorType.TRUECOLOUR_ALPHA;\r\n            break;\r\n        case 3:\r\n            returnValue.colorType = ColorType.TRUECOLOUR;\r\n            break;\r\n        case 1:\r\n            returnValue.colorType = ColorType.GREYSCALE;\r\n            break;\r\n        case 2:\r\n            returnValue.colorType = ColorType.GREYSCALE_ALPHA;\r\n            break;\r\n        default:\r\n            throw new Error(`unsupported number of channels: ${channels}`);\r\n    }\r\n    return returnValue;\r\n}\r\nfunction writeDataBytes(data, newData, slotsPerLine, offset) {\r\n    for (let j = 0; j < slotsPerLine; j++) {\r\n        newData.writeByte(data[offset++]);\r\n    }\r\n    return offset;\r\n}\r\nfunction writeDataUint16(data, newData, slotsPerLine, offset) {\r\n    for (let j = 0; j < slotsPerLine; j++) {\r\n        newData.writeUint16(data[offset++]);\r\n    }\r\n    return offset;\r\n}\r\n//# sourceMappingURL=PNGEncoder.js.map"]},"metadata":{},"sourceType":"module"}