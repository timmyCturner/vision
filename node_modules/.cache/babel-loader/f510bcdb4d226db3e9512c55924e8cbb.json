{"ast":null,"code":"'use strict';\n\nconst IOBuffer = require('iobuffer');\n\nconst IFD = require('./ifd');\n\nconst TiffIFD = require('./tiffIfd');\n\nconst IFDValue = require('./ifdValue');\n\nconst defaultOptions = {\n  ignoreImageData: false,\n  onlyFirst: false\n};\n\nclass TIFFDecoder extends IOBuffer {\n  constructor(data, options) {\n    super(data, options);\n    this._nextIFD = 0;\n  }\n\n  decode(options) {\n    options = Object.assign({}, defaultOptions, options);\n    const result = [];\n    this.decodeHeader();\n\n    while (this._nextIFD) {\n      result.push(this.decodeIFD(options));\n\n      if (options.onlyFirst) {\n        return result[0];\n      }\n    }\n\n    return result;\n  }\n\n  decodeHeader() {\n    // Byte offset\n    let value = this.readUint16();\n\n    if (value === 0x4949) {\n      this.setLittleEndian();\n    } else if (value === 0x4D4D) {\n      this.setBigEndian();\n    } else {\n      throw new Error('invalid byte order: 0x' + value.toString(16));\n    } // Magic number\n\n\n    value = this.readUint16();\n\n    if (value !== 42) {\n      throw new Error('not a TIFF file');\n    } // Offset of the first IFD\n\n\n    this._nextIFD = this.readUint32();\n  }\n\n  decodeIFD(options) {\n    this.seek(this._nextIFD);\n    var ifd;\n\n    if (!options.kind) {\n      ifd = new TiffIFD();\n    } else {\n      ifd = new IFD(options.kind);\n    }\n\n    const numEntries = this.readUint16();\n\n    for (var i = 0; i < numEntries; i++) {\n      this.decodeIFDEntry(ifd);\n    }\n\n    if (!options.ignoreImageData) {\n      this.decodeImageData(ifd);\n    }\n\n    this._nextIFD = this.readUint32();\n    return ifd;\n  }\n\n  decodeIFDEntry(ifd) {\n    const offset = this.offset;\n    const tag = this.readUint16();\n    const type = this.readUint16();\n    const numValues = this.readUint32();\n\n    if (type < 1 || type > 12) {\n      this.skip(4); // unknown type, skip this value\n\n      return;\n    }\n\n    const valueByteLength = IFDValue.getByteLength(type, numValues);\n\n    if (valueByteLength > 4) {\n      this.seek(this.readUint32());\n    }\n\n    const value = IFDValue.readData(this, type, numValues);\n    ifd.fields.set(tag, value); // Read sub-IFDs\n\n    if (tag === 0x8769 || tag === 0x8825) {\n      let currentOffset = this.offset;\n      let kind;\n\n      if (tag === 0x8769) {\n        kind = 'exif';\n      } else if (tag === 0x8825) {\n        kind = 'gps';\n      }\n\n      this._nextIFD = value;\n      ifd[kind] = this.decodeIFD({\n        kind,\n        ignoreImageData: true\n      });\n      this.offset = currentOffset;\n    } // go to the next entry\n\n\n    this.seek(offset);\n    this.skip(12);\n  }\n\n  decodeImageData(ifd) {\n    const orientation = ifd.orientation;\n\n    if (orientation && orientation !== 1) {\n      unsupported('orientation', orientation);\n    }\n\n    switch (ifd.type) {\n      case 1: // BlackIsZero\n\n      case 2:\n        // RGB\n        this.readStripData(ifd);\n        break;\n\n      default:\n        unsupported('image type', ifd.type);\n        break;\n    }\n  }\n\n  readStripData(ifd) {\n    const width = ifd.width;\n    const height = ifd.height;\n    const bitDepth = validateBitDepth(ifd.bitsPerSample);\n    const sampleFormat = ifd.sampleFormat;\n    let size = width * height;\n    const data = getDataArray(size, 1, bitDepth, sampleFormat);\n    const compression = ifd.compression;\n    const rowsPerStrip = ifd.rowsPerStrip;\n    const maxPixels = rowsPerStrip * width;\n    const stripOffsets = ifd.stripOffsets;\n    const stripByteCounts = ifd.stripByteCounts;\n    var pixel = 0;\n\n    for (var i = 0; i < stripOffsets.length; i++) {\n      var stripData = this.getStripData(compression, stripOffsets[i], stripByteCounts[i]); // Last strip can be smaller\n\n      var length = size > maxPixels ? maxPixels : size;\n      size -= length;\n\n      if (bitDepth === 8) {\n        pixel = fill8bit(data, stripData, pixel, length);\n      } else if (bitDepth === 16) {\n        pixel = fill16bit(data, stripData, pixel, length, this.isLittleEndian());\n      } else if (bitDepth === 32 && sampleFormat === 3) {\n        pixel = fillFloat32(data, stripData, pixel, length, this.isLittleEndian());\n      } else {\n        unsupported('bitDepth', bitDepth);\n      }\n    }\n\n    ifd.data = data;\n  }\n\n  getStripData(compression, offset, byteCounts) {\n    switch (compression) {\n      case 1:\n        // No compression\n        return new DataView(this.buffer, offset, byteCounts);\n\n      case 2: // CCITT Group 3 1-Dimensional Modified Huffman run length encoding\n\n      case 32773:\n        // PackBits compression\n        return unsupported('Compression', compression);\n\n      default:\n        throw new Error('invalid compression: ' + compression);\n    }\n  }\n\n}\n\nmodule.exports = TIFFDecoder;\n\nfunction getDataArray(size, channels, bitDepth, sampleFormat) {\n  if (bitDepth === 8) {\n    return new Uint8Array(size * channels);\n  } else if (bitDepth === 16) {\n    return new Uint16Array(size * channels);\n  } else if (bitDepth === 32 && sampleFormat === 3) {\n    return new Float32Array(size * channels);\n  } else {\n    return unsupported('bit depth / sample format', bitDepth + ' / ' + sampleFormat);\n  }\n}\n\nfunction fill8bit(dataTo, dataFrom, index, length) {\n  for (var i = 0; i < length; i++) {\n    dataTo[index++] = dataFrom.getUint8(i);\n  }\n\n  return index;\n}\n\nfunction fill16bit(dataTo, dataFrom, index, length, littleEndian) {\n  for (var i = 0; i < length * 2; i += 2) {\n    dataTo[index++] = dataFrom.getUint16(i, littleEndian);\n  }\n\n  return index;\n}\n\nfunction fillFloat32(dataTo, dataFrom, index, length, littleEndian) {\n  for (var i = 0; i < length * 4; i += 4) {\n    dataTo[index++] = dataFrom.getFloat32(i, littleEndian);\n  }\n\n  return index;\n}\n\nfunction unsupported(type, value) {\n  throw new Error('Unsupported ' + type + ': ' + value);\n}\n\nfunction validateBitDepth(bitDepth) {\n  if (bitDepth.length) {\n    const bitDepthArray = bitDepth;\n    bitDepth = bitDepthArray[0];\n\n    for (var i = 0; i < bitDepthArray.length; i++) {\n      if (bitDepthArray[i] !== bitDepth) {\n        unsupported('bit depth', bitDepthArray);\n      }\n    }\n  }\n\n  return bitDepth;\n}","map":{"version":3,"sources":["C:/Users/kuent/Documents/FinishDipshit/Creative/Ocean-Weather-Visualization/node_modules/fast-jpeg/node_modules/tiff/src/tiffDecoder.js"],"names":["IOBuffer","require","IFD","TiffIFD","IFDValue","defaultOptions","ignoreImageData","onlyFirst","TIFFDecoder","constructor","data","options","_nextIFD","decode","Object","assign","result","decodeHeader","push","decodeIFD","value","readUint16","setLittleEndian","setBigEndian","Error","toString","readUint32","seek","ifd","kind","numEntries","i","decodeIFDEntry","decodeImageData","offset","tag","type","numValues","skip","valueByteLength","getByteLength","readData","fields","set","currentOffset","orientation","unsupported","readStripData","width","height","bitDepth","validateBitDepth","bitsPerSample","sampleFormat","size","getDataArray","compression","rowsPerStrip","maxPixels","stripOffsets","stripByteCounts","pixel","length","stripData","getStripData","fill8bit","fill16bit","isLittleEndian","fillFloat32","byteCounts","DataView","buffer","module","exports","channels","Uint8Array","Uint16Array","Float32Array","dataTo","dataFrom","index","getUint8","littleEndian","getUint16","getFloat32","bitDepthArray"],"mappings":"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","sourcesContent":["'use strict';\n\nconst IOBuffer = require('iobuffer');\nconst IFD = require('./ifd');\nconst TiffIFD = require('./tiffIfd');\nconst IFDValue = require('./ifdValue');\n\nconst defaultOptions = {\n    ignoreImageData: false,\n    onlyFirst: false\n};\n\nclass TIFFDecoder extends IOBuffer {\n    constructor(data, options) {\n        super(data, options);\n        this._nextIFD = 0;\n    }\n\n    decode(options) {\n        options = Object.assign({}, defaultOptions, options);\n        const result = [];\n        this.decodeHeader();\n        while (this._nextIFD) {\n            result.push(this.decodeIFD(options));\n            if (options.onlyFirst) {\n                return result[0];\n            }\n        }\n        return result;\n    }\n\n    decodeHeader() {\n        // Byte offset\n        let value = this.readUint16();\n        if (value === 0x4949) {\n            this.setLittleEndian();\n        } else if (value === 0x4D4D) {\n            this.setBigEndian();\n        } else {\n            throw new Error('invalid byte order: 0x' + value.toString(16));\n        }\n\n        // Magic number\n        value = this.readUint16();\n        if (value !== 42) {\n            throw new Error('not a TIFF file');\n        }\n\n        // Offset of the first IFD\n        this._nextIFD = this.readUint32();\n    }\n\n    decodeIFD(options) {\n        this.seek(this._nextIFD);\n\n        var ifd;\n        if (!options.kind) {\n            ifd = new TiffIFD();\n        } else {\n            ifd = new IFD(options.kind);\n        }\n\n        const numEntries = this.readUint16();\n        for (var i = 0; i < numEntries; i++) {\n            this.decodeIFDEntry(ifd);\n        }\n        if (!options.ignoreImageData) {\n            this.decodeImageData(ifd);\n        }\n        this._nextIFD = this.readUint32();\n        return ifd;\n    }\n\n    decodeIFDEntry(ifd) {\n        const offset = this.offset;\n        const tag = this.readUint16();\n        const type = this.readUint16();\n        const numValues = this.readUint32();\n\n        if (type < 1 || type > 12) {\n            this.skip(4); // unknown type, skip this value\n            return;\n        }\n\n        const valueByteLength = IFDValue.getByteLength(type, numValues);\n        if (valueByteLength > 4) {\n            this.seek(this.readUint32());\n        }\n\n        const value = IFDValue.readData(this, type, numValues);\n        ifd.fields.set(tag, value);\n\n        // Read sub-IFDs\n        if (tag === 0x8769 || tag === 0x8825) {\n            let currentOffset = this.offset;\n            let kind;\n            if (tag === 0x8769) {\n                kind = 'exif';\n            } else if (tag === 0x8825) {\n                kind = 'gps';\n            }\n            this._nextIFD = value;\n            ifd[kind] = this.decodeIFD({\n                kind,\n                ignoreImageData: true\n            });\n            this.offset = currentOffset;\n        }\n\n        // go to the next entry\n        this.seek(offset);\n        this.skip(12);\n    }\n\n    decodeImageData(ifd) {\n        const orientation = ifd.orientation;\n        if (orientation && orientation !== 1) {\n            unsupported('orientation', orientation);\n        }\n        switch (ifd.type) {\n            case 1: // BlackIsZero\n            case 2: // RGB\n                this.readStripData(ifd);\n                break;\n            default:\n                unsupported('image type', ifd.type);\n                break;\n        }\n    }\n\n    readStripData(ifd) {\n        const width = ifd.width;\n        const height = ifd.height;\n\n        const bitDepth = validateBitDepth(ifd.bitsPerSample);\n        const sampleFormat = ifd.sampleFormat;\n        let size = width * height;\n        const data = getDataArray(size, 1, bitDepth, sampleFormat);\n\n        const compression = ifd.compression;\n        const rowsPerStrip = ifd.rowsPerStrip;\n        const maxPixels = rowsPerStrip * width;\n        const stripOffsets = ifd.stripOffsets;\n        const stripByteCounts = ifd.stripByteCounts;\n\n        var pixel = 0;\n        for (var i = 0; i < stripOffsets.length; i++) {\n            var stripData = this.getStripData(compression, stripOffsets[i], stripByteCounts[i]);\n            // Last strip can be smaller\n            var length = size > maxPixels ? maxPixels : size;\n            size -= length;\n            if (bitDepth === 8) {\n                pixel = fill8bit(data, stripData, pixel, length);\n            } else if (bitDepth === 16) {\n                pixel = fill16bit(data, stripData, pixel, length, this.isLittleEndian());\n            } else if (bitDepth === 32 && sampleFormat === 3) {\n                pixel = fillFloat32(data, stripData, pixel, length, this.isLittleEndian());\n            } else {\n                unsupported('bitDepth', bitDepth);\n            }\n        }\n\n        ifd.data = data;\n    }\n\n    getStripData(compression, offset, byteCounts) {\n        switch (compression) {\n            case 1: // No compression\n                return new DataView(this.buffer, offset, byteCounts);\n            case 2: // CCITT Group 3 1-Dimensional Modified Huffman run length encoding\n            case 32773: // PackBits compression\n                return unsupported('Compression', compression);\n            default:\n                throw new Error('invalid compression: ' + compression);\n        }\n    }\n}\n\nmodule.exports = TIFFDecoder;\n\nfunction getDataArray(size, channels, bitDepth, sampleFormat) {\n    if (bitDepth === 8) {\n        return new Uint8Array(size * channels);\n    } else if (bitDepth === 16) {\n        return new Uint16Array(size * channels);\n    } else if (bitDepth === 32 && sampleFormat === 3) {\n        return new Float32Array(size * channels);\n    } else {\n        return unsupported('bit depth / sample format', bitDepth + ' / ' + sampleFormat);\n    }\n}\n\nfunction fill8bit(dataTo, dataFrom, index, length) {\n    for (var i = 0; i < length; i++) {\n        dataTo[index++] = dataFrom.getUint8(i);\n    }\n    return index;\n}\n\nfunction fill16bit(dataTo, dataFrom, index, length, littleEndian) {\n    for (var i = 0; i < length * 2; i += 2) {\n        dataTo[index++] = dataFrom.getUint16(i, littleEndian);\n    }\n    return index;\n}\n\nfunction fillFloat32(dataTo, dataFrom, index, length, littleEndian) {\n    for (var i = 0; i < length * 4; i += 4) {\n        dataTo[index++] = dataFrom.getFloat32(i, littleEndian);\n    }\n    return index;\n}\n\nfunction unsupported(type, value) {\n    throw new Error('Unsupported ' + type + ': ' + value);\n}\n\nfunction validateBitDepth(bitDepth) {\n    if (bitDepth.length) {\n        const bitDepthArray = bitDepth;\n        bitDepth = bitDepthArray[0];\n        for (var i = 0; i < bitDepthArray.length; i++) {\n            if (bitDepthArray[i] !== bitDepth) {\n                unsupported('bit depth', bitDepthArray);\n            }\n        }\n    }\n    return bitDepth;\n}\n"]},"metadata":{},"sourceType":"script"}