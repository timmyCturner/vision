{"ast":null,"code":"import BaseRegression, { checkArrayLength, maybeToPrecision } from 'ml-regression-base';\nimport median from 'ml-array-median';\nexport default class TheilSenRegression extends BaseRegression {\n  /**\n   * Theil–Sen estimator\n   * https://en.wikipedia.org/wiki/Theil%E2%80%93Sen_estimator\n   * @param {Array<number>|boolean} x\n   * @param {Array<number>|object} y\n   * @constructor\n   */\n  constructor(x, y) {\n    super();\n\n    if (x === true) {\n      // loads the model\n      this.slope = y.slope;\n      this.intercept = y.intercept;\n      this.coefficients = y.coefficients;\n    } else {\n      // creates the model\n      checkArrayLength(x, y);\n      theilSen(this, x, y);\n    }\n  }\n\n  toJSON() {\n    return {\n      name: 'TheilSenRegression',\n      slope: this.slope,\n      intercept: this.intercept\n    };\n  }\n\n  _predict(input) {\n    return this.slope * input + this.intercept;\n  }\n\n  computeX(input) {\n    return (input - this.intercept) / this.slope;\n  }\n\n  toString(precision) {\n    var result = 'f(x) = ';\n\n    if (this.slope) {\n      var xFactor = maybeToPrecision(this.slope, precision);\n      result += `${Math.abs(xFactor - 1) < 1e-5 ? '' : `${xFactor} * `}x`;\n\n      if (this.intercept) {\n        var absIntercept = Math.abs(this.intercept);\n        var operator = absIntercept === this.intercept ? '+' : '-';\n        result += ` ${operator} ${maybeToPrecision(absIntercept, precision)}`;\n      }\n    } else {\n      result += maybeToPrecision(this.intercept, precision);\n    }\n\n    return result;\n  }\n\n  toLaTeX(precision) {\n    return this.toString(precision);\n  }\n\n  static load(json) {\n    if (json.name !== 'TheilSenRegression') {\n      throw new TypeError('not a Theil-Sen model');\n    }\n\n    return new TheilSenRegression(true, json);\n  }\n\n}\n\nfunction theilSen(regression, x, y) {\n  let len = x.length;\n  let slopes = new Array(len * len);\n  let count = 0;\n\n  for (let i = 0; i < len; ++i) {\n    for (let j = i + 1; j < len; ++j) {\n      if (x[i] !== x[j]) {\n        slopes[count++] = (y[j] - y[i]) / (x[j] - x[i]);\n      }\n    }\n  }\n\n  slopes.length = count;\n  let medianSlope = median(slopes);\n  let cuts = new Array(len);\n\n  for (let i = 0; i < len; ++i) {\n    cuts[i] = y[i] - medianSlope * x[i];\n  }\n\n  regression.slope = medianSlope;\n  regression.intercept = median(cuts);\n  regression.coefficients = [regression.intercept, regression.slope];\n}","map":{"version":3,"sources":["C:/Users/kuent/Documents/FinishDipshit/Creative/Ocean-Weather-Visualization/node_modules/ml-regression-theil-sen/src/index.js"],"names":["BaseRegression","checkArrayLength","maybeToPrecision","median","TheilSenRegression","constructor","x","y","slope","intercept","coefficients","theilSen","toJSON","name","_predict","input","computeX","toString","precision","result","xFactor","Math","abs","absIntercept","operator","toLaTeX","load","json","TypeError","regression","len","length","slopes","Array","count","i","j","medianSlope","cuts"],"mappings":"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","sourcesContent":["import BaseRegression, {\n  checkArrayLength,\n  maybeToPrecision\n} from 'ml-regression-base';\nimport median from 'ml-array-median';\n\nexport default class TheilSenRegression extends BaseRegression {\n  /**\n   * Theil–Sen estimator\n   * https://en.wikipedia.org/wiki/Theil%E2%80%93Sen_estimator\n   * @param {Array<number>|boolean} x\n   * @param {Array<number>|object} y\n   * @constructor\n   */\n  constructor(x, y) {\n    super();\n    if (x === true) {\n      // loads the model\n      this.slope = y.slope;\n      this.intercept = y.intercept;\n      this.coefficients = y.coefficients;\n    } else {\n      // creates the model\n      checkArrayLength(x, y);\n      theilSen(this, x, y);\n    }\n  }\n\n  toJSON() {\n    return {\n      name: 'TheilSenRegression',\n      slope: this.slope,\n      intercept: this.intercept\n    };\n  }\n\n  _predict(input) {\n    return this.slope * input + this.intercept;\n  }\n\n  computeX(input) {\n    return (input - this.intercept) / this.slope;\n  }\n\n  toString(precision) {\n    var result = 'f(x) = ';\n    if (this.slope) {\n      var xFactor = maybeToPrecision(this.slope, precision);\n      result += `${Math.abs(xFactor - 1) < 1e-5 ? '' : `${xFactor} * `}x`;\n      if (this.intercept) {\n        var absIntercept = Math.abs(this.intercept);\n        var operator = absIntercept === this.intercept ? '+' : '-';\n        result +=\n          ` ${operator} ${maybeToPrecision(absIntercept, precision)}`;\n      }\n    } else {\n      result += maybeToPrecision(this.intercept, precision);\n    }\n    return result;\n  }\n\n  toLaTeX(precision) {\n    return this.toString(precision);\n  }\n\n  static load(json) {\n    if (json.name !== 'TheilSenRegression') {\n      throw new TypeError('not a Theil-Sen model');\n    }\n    return new TheilSenRegression(true, json);\n  }\n}\n\nfunction theilSen(regression, x, y) {\n  let len = x.length;\n  let slopes = new Array(len * len);\n  let count = 0;\n  for (let i = 0; i < len; ++i) {\n    for (let j = i + 1; j < len; ++j) {\n      if (x[i] !== x[j]) {\n        slopes[count++] = (y[j] - y[i]) / (x[j] - x[i]);\n      }\n    }\n  }\n  slopes.length = count;\n  let medianSlope = median(slopes);\n\n  let cuts = new Array(len);\n  for (let i = 0; i < len; ++i) {\n    cuts[i] = y[i] - medianSlope * x[i];\n  }\n\n  regression.slope = medianSlope;\n  regression.intercept = median(cuts);\n  regression.coefficients = [regression.intercept, regression.slope];\n}\n"]},"metadata":{},"sourceType":"module"}