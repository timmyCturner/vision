{"ast":null,"code":"import * as ColorModel from '../model/model';\nimport * as Kind from './kindNames';\nconst kinds = {};\nkinds[Kind.BINARY] = {\n  components: 1,\n  alpha: 0,\n  bitDepth: 1,\n  colorModel: ColorModel.GREY\n};\nkinds[Kind.GREYA] = {\n  components: 1,\n  alpha: 1,\n  bitDepth: 8,\n  colorModel: ColorModel.GREY\n};\nkinds[Kind.GREY] = {\n  components: 1,\n  alpha: 0,\n  bitDepth: 8,\n  colorModel: ColorModel.GREY\n};\nkinds[Kind.RGBA] = {\n  components: 3,\n  alpha: 1,\n  bitDepth: 8,\n  colorModel: ColorModel.RGB\n};\nkinds[Kind.RGB] = {\n  components: 3,\n  alpha: 0,\n  bitDepth: 8,\n  colorModel: ColorModel.RGB\n};\nkinds[Kind.CMYK] = {\n  components: 4,\n  alpha: 0,\n  bitDepth: 8,\n  colorModel: ColorModel.CMYK\n};\nkinds[Kind.CMYKA] = {\n  components: 4,\n  alpha: 1,\n  bitDepth: 8,\n  colorModel: ColorModel.CMYK\n};\nexport function getKind(kind) {\n  const result = kinds[kind];\n\n  if (!result) {\n    throw new RangeError(`invalid image kind: ${kind}`);\n  }\n\n  return result;\n}\nconst validBitDepth = [1, 8, 16, 32];\nexport function verifyKindDefinition(definition) {\n  const {\n    components,\n    alpha,\n    bitDepth,\n    colorModel\n  } = definition;\n\n  if (!Number.isInteger(components) || components <= 0) {\n    throw new RangeError(`invalid components: ${components}. Must be a positive integer`);\n  }\n\n  if (alpha !== 0 && alpha !== 1 && typeof alpha !== 'boolean') {\n    throw new TypeError(`invalid alpha: ${alpha}: must be a boolean, 0 or 1`);\n  }\n\n  if (!validBitDepth.includes(bitDepth)) {\n    throw new RangeError(`invalid bitDepth: ${bitDepth}. Must be one of ${validBitDepth.join(', ')}`);\n  } // eslint-disable-next-line import/namespace\n\n\n  if (!ColorModel[colorModel]) {\n    throw new RangeError(`invalid colorModel: ${colorModel}. Must be one of ${Object.keys(ColorModel).join(', ')}`);\n  }\n}\nexport function getTheoreticalPixelArraySize(size, channels, bitDepth) {\n  let length = channels * size;\n\n  if (bitDepth === 1) {\n    length = Math.ceil(length / 8);\n  }\n\n  return length;\n}\nexport function createPixelArray(size, components, alpha, channels, bitDepth, maxValue) {\n  const length = channels * size;\n  let arr;\n\n  switch (bitDepth) {\n    case 1:\n      arr = new Uint8Array(Math.ceil(length / 8));\n      break;\n\n    case 8:\n      arr = new Uint8Array(length);\n      break;\n\n    case 16:\n      arr = new Uint16Array(length);\n      break;\n\n    case 32:\n      arr = new Float32Array(length);\n      break;\n\n    default:\n      throw new Error(`Cannot create pixel array for bit depth ${bitDepth}`);\n  } // alpha channel is 100% by default\n\n\n  if (alpha) {\n    for (let i = components; i < arr.length; i += channels) {\n      arr[i] = maxValue;\n    }\n  }\n\n  return arr;\n}","map":{"version":3,"sources":["C:/Users/kuent/Documents/FinishDipshit/Creative/Ocean-Weather-Visualization/node_modules/image-js/src/image/core/kind.js"],"names":["ColorModel","Kind","kinds","BINARY","components","alpha","bitDepth","colorModel","GREY","GREYA","RGBA","RGB","CMYK","CMYKA","getKind","kind","result","RangeError","validBitDepth","verifyKindDefinition","definition","Number","isInteger","TypeError","includes","join","Object","keys","getTheoreticalPixelArraySize","size","channels","length","Math","ceil","createPixelArray","maxValue","arr","Uint8Array","Uint16Array","Float32Array","Error","i"],"mappings":"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","sourcesContent":["import * as ColorModel from '../model/model';\n\nimport * as Kind from './kindNames';\n\nconst kinds = {};\n\nkinds[Kind.BINARY] = {\n  components: 1,\n  alpha: 0,\n  bitDepth: 1,\n  colorModel: ColorModel.GREY,\n};\n\nkinds[Kind.GREYA] = {\n  components: 1,\n  alpha: 1,\n  bitDepth: 8,\n  colorModel: ColorModel.GREY,\n};\n\nkinds[Kind.GREY] = {\n  components: 1,\n  alpha: 0,\n  bitDepth: 8,\n  colorModel: ColorModel.GREY,\n};\n\nkinds[Kind.RGBA] = {\n  components: 3,\n  alpha: 1,\n  bitDepth: 8,\n  colorModel: ColorModel.RGB,\n};\n\nkinds[Kind.RGB] = {\n  components: 3,\n  alpha: 0,\n  bitDepth: 8,\n  colorModel: ColorModel.RGB,\n};\n\nkinds[Kind.CMYK] = {\n  components: 4,\n  alpha: 0,\n  bitDepth: 8,\n  colorModel: ColorModel.CMYK,\n};\n\nkinds[Kind.CMYKA] = {\n  components: 4,\n  alpha: 1,\n  bitDepth: 8,\n  colorModel: ColorModel.CMYK,\n};\n\nexport function getKind(kind) {\n  const result = kinds[kind];\n  if (!result) {\n    throw new RangeError(`invalid image kind: ${kind}`);\n  }\n  return result;\n}\nconst validBitDepth = [1, 8, 16, 32];\nexport function verifyKindDefinition(definition) {\n  const { components, alpha, bitDepth, colorModel } = definition;\n  if (!Number.isInteger(components) || components <= 0) {\n    throw new RangeError(\n      `invalid components: ${components}. Must be a positive integer`,\n    );\n  }\n  if (alpha !== 0 && alpha !== 1 && typeof alpha !== 'boolean') {\n    throw new TypeError(`invalid alpha: ${alpha}: must be a boolean, 0 or 1`);\n  }\n  if (!validBitDepth.includes(bitDepth)) {\n    throw new RangeError(\n      `invalid bitDepth: ${bitDepth}. Must be one of ${validBitDepth.join(\n        ', ',\n      )}`,\n    );\n  }\n  // eslint-disable-next-line import/namespace\n  if (!ColorModel[colorModel]) {\n    throw new RangeError(\n      `invalid colorModel: ${colorModel}. Must be one of ${Object.keys(\n        ColorModel,\n      ).join(', ')}`,\n    );\n  }\n}\n\nexport function getTheoreticalPixelArraySize(size, channels, bitDepth) {\n  let length = channels * size;\n  if (bitDepth === 1) {\n    length = Math.ceil(length / 8);\n  }\n  return length;\n}\n\nexport function createPixelArray(\n  size,\n  components,\n  alpha,\n  channels,\n  bitDepth,\n  maxValue,\n) {\n  const length = channels * size;\n  let arr;\n  switch (bitDepth) {\n    case 1:\n      arr = new Uint8Array(Math.ceil(length / 8));\n      break;\n    case 8:\n      arr = new Uint8Array(length);\n      break;\n    case 16:\n      arr = new Uint16Array(length);\n      break;\n    case 32:\n      arr = new Float32Array(length);\n      break;\n    default:\n      throw new Error(`Cannot create pixel array for bit depth ${bitDepth}`);\n  }\n\n  // alpha channel is 100% by default\n  if (alpha) {\n    for (let i = components; i < arr.length; i += channels) {\n      arr[i] = maxValue;\n    }\n  }\n\n  return arr;\n}\n"]},"metadata":{},"sourceType":"module"}