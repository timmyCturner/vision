{"ast":null,"code":"/**\n * Returns an array of object with position.\n * @memberof Image\n * @instance\n * @param {object} [options]\n * @param {Image} [options.mask] - Region of the image that is analyzed. The rest is omitted.\n * @param {number} [options.region=3] -  1, 2 or 3. Define the region around each points that is analyzed. 1 corresponds to 4 cross points, 2 to\n *        the 8 points around and 3 to the 12 points around the central pixel.\n * @param {number} [options.removeClosePoints=0] - Remove pts which have a distance between them smaller than this param.\n * @param {boolean} [options.invert=false] - Search for minima instead of maxima\n * @param {number} [options.maxEquals=2] - Maximal number of values that may be equal to the maximum\n * @return {number[]} Array whose size is the number of channels\n */\nexport default function localMaxima(options = {}) {\n  let {\n    mask,\n    region = 3,\n    removeClosePoints = 0,\n    invert = false,\n    maxEquals = 2\n  } = options;\n  let image = this;\n  this.checkProcessable('localMaxima', {\n    bitDepth: [8, 16],\n    components: 1\n  });\n  region *= 4;\n  let maskExpectedValue = invert ? 0 : 1;\n  let dx = [+1, 0, -1, 0, +1, +1, -1, -1, +2, 0, -2, 0, +2, +2, -2, -2];\n  let dy = [0, +1, 0, -1, +1, -1, +1, -1, 0, +2, 0, -2, +2, -2, +2, -2];\n  let shift = region <= 8 ? 1 : 2;\n  let points = [];\n\n  for (let currentY = shift; currentY < image.height - shift; currentY++) {\n    for (let currentX = shift; currentX < image.width - shift; currentX++) {\n      if (mask && mask.getBitXY(currentX, currentY) !== maskExpectedValue) {\n        continue;\n      }\n\n      let counter = 0;\n      let nbEquals = 0;\n      let currentValue = image.data[currentX + currentY * image.width];\n\n      for (let dir = 0; dir < region; dir++) {\n        if (invert) {\n          // we search for minima\n          if (image.data[currentX + dx[dir] + (currentY + dy[dir]) * image.width] > currentValue) {\n            counter++;\n          }\n        } else {\n          if (image.data[currentX + dx[dir] + (currentY + dy[dir]) * image.width] < currentValue) {\n            counter++;\n          }\n        }\n\n        if (image.data[currentX + dx[dir] + (currentY + dy[dir]) * image.width] === currentValue) {\n          nbEquals++;\n        }\n      }\n\n      if (counter + nbEquals === region && nbEquals <= maxEquals) {\n        points.push([currentX, currentY]);\n      }\n    }\n  } // TODO How to make a more performant and general way\n  // we don't deal correctly here with groups of points that should be grouped if at the\n  // beginning one of them is closer to another\n  // Seems that we would ened to calculate a matrix and then split this matrix in 'independant matrices'\n  // Or to assign a cluster to each point and regroup them if 2 clusters are close to each other\n  // later approach seems much better\n\n\n  if (removeClosePoints > 0) {\n    for (let i = 0; i < points.length; i++) {\n      for (let j = i + 1; j < points.length; j++) {\n        if (Math.sqrt(Math.pow(points[i][0] - points[j][0], 2) + Math.pow(points[i][1] - points[j][1], 2)) < removeClosePoints) {\n          points[i][0] = points[i][0] + points[j][0] >> 1;\n          points[i][1] = points[i][1] + points[j][1] >> 1;\n          points.splice(j, 1);\n          j--;\n        }\n      }\n    }\n  }\n\n  return points;\n}","map":{"version":3,"sources":["C:/Users/kuent/Documents/FinishDipshit/Creative/Ocean-Weather-Visualization/node_modules/image-js/src/image/compute/localMaxima.js"],"names":["localMaxima","options","mask","region","removeClosePoints","invert","maxEquals","image","checkProcessable","bitDepth","components","maskExpectedValue","dx","dy","shift","points","currentY","height","currentX","width","getBitXY","counter","nbEquals","currentValue","data","dir","push","i","length","j","Math","sqrt","pow","splice"],"mappings":"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","sourcesContent":["/**\n * Returns an array of object with position.\n * @memberof Image\n * @instance\n * @param {object} [options]\n * @param {Image} [options.mask] - Region of the image that is analyzed. The rest is omitted.\n * @param {number} [options.region=3] -  1, 2 or 3. Define the region around each points that is analyzed. 1 corresponds to 4 cross points, 2 to\n *        the 8 points around and 3 to the 12 points around the central pixel.\n * @param {number} [options.removeClosePoints=0] - Remove pts which have a distance between them smaller than this param.\n * @param {boolean} [options.invert=false] - Search for minima instead of maxima\n * @param {number} [options.maxEquals=2] - Maximal number of values that may be equal to the maximum\n * @return {number[]} Array whose size is the number of channels\n */\nexport default function localMaxima(options = {}) {\n  let {\n    mask,\n    region = 3,\n    removeClosePoints = 0,\n    invert = false,\n    maxEquals = 2,\n  } = options;\n  let image = this;\n  this.checkProcessable('localMaxima', {\n    bitDepth: [8, 16],\n    components: 1,\n  });\n  region *= 4;\n\n  let maskExpectedValue = invert ? 0 : 1;\n\n  let dx = [+1, 0, -1, 0, +1, +1, -1, -1, +2, 0, -2, 0, +2, +2, -2, -2];\n  let dy = [0, +1, 0, -1, +1, -1, +1, -1, 0, +2, 0, -2, +2, -2, +2, -2];\n  let shift = region <= 8 ? 1 : 2;\n  let points = [];\n  for (let currentY = shift; currentY < image.height - shift; currentY++) {\n    for (let currentX = shift; currentX < image.width - shift; currentX++) {\n      if (mask && mask.getBitXY(currentX, currentY) !== maskExpectedValue) {\n        continue;\n      }\n      let counter = 0;\n      let nbEquals = 0;\n      let currentValue = image.data[currentX + currentY * image.width];\n      for (let dir = 0; dir < region; dir++) {\n        if (invert) {\n          // we search for minima\n          if (\n            image.data[\n              currentX + dx[dir] + (currentY + dy[dir]) * image.width\n            ] > currentValue\n          ) {\n            counter++;\n          }\n        } else {\n          if (\n            image.data[\n              currentX + dx[dir] + (currentY + dy[dir]) * image.width\n            ] < currentValue\n          ) {\n            counter++;\n          }\n        }\n        if (\n          image.data[\n            currentX + dx[dir] + (currentY + dy[dir]) * image.width\n          ] === currentValue\n        ) {\n          nbEquals++;\n        }\n      }\n      if (counter + nbEquals === region && nbEquals <= maxEquals) {\n        points.push([currentX, currentY]);\n      }\n    }\n  }\n  // TODO How to make a more performant and general way\n  // we don't deal correctly here with groups of points that should be grouped if at the\n  // beginning one of them is closer to another\n  // Seems that we would ened to calculate a matrix and then split this matrix in 'independant matrices'\n  // Or to assign a cluster to each point and regroup them if 2 clusters are close to each other\n  // later approach seems much better\n  if (removeClosePoints > 0) {\n    for (let i = 0; i < points.length; i++) {\n      for (let j = i + 1; j < points.length; j++) {\n        if (\n          Math.sqrt(\n            Math.pow(points[i][0] - points[j][0], 2) +\n              Math.pow(points[i][1] - points[j][1], 2),\n          ) < removeClosePoints\n        ) {\n          points[i][0] = (points[i][0] + points[j][0]) >> 1;\n          points[i][1] = (points[i][1] + points[j][1]) >> 1;\n          points.splice(j, 1);\n          j--;\n        }\n      }\n    }\n  }\n  return points;\n}\n"]},"metadata":{},"sourceType":"module"}