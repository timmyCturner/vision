{"ast":null,"code":"import { factorDimensions } from '../../../util/converter';\nimport Image from '../../Image';\nimport { validInterpolations, checkInterpolation } from '../../internal/checks';\nimport nearestNeighbor from './nearestNeighbor';\n/**\n * Resize an image\n * @memberof Image\n * @instance\n * @param {object} [options]\n * @param {number} [options.width=this.width] - new width\n * @param {number} [options.height=this.height] - new height\n * @param {number} [options.factor=1] - scaling factor (applied to the new width and height values)\n * @param {InterpolationAlgorithm} [options.interpolation='nearestNeighbor']\n * @param {boolean} [options.preserveAspectRatio=true] - preserve width/height ratio if only one of them is defined\n * @return {Image}\n */\n\nexport default function resize(options = {}) {\n  const {\n    factor = 1,\n    interpolation = validInterpolations.nearestneighbor,\n    preserveAspectRatio = true\n  } = options;\n  const interpolationToUse = checkInterpolation(interpolation);\n  let width = options.width;\n  let height = options.height;\n\n  if (!width) {\n    if (height && preserveAspectRatio) {\n      width = Math.round(height * (this.width / this.height));\n    } else {\n      width = this.width;\n    }\n  }\n\n  if (!height) {\n    if (preserveAspectRatio) {\n      height = Math.round(width * (this.height / this.width));\n    } else {\n      height = this.height;\n    }\n  }\n\n  ({\n    width,\n    height\n  } = factorDimensions(factor, width, height));\n\n  if (width === this.width && height === this.height) {\n    const newImage = this.clone();\n    newImage.position = [0, 0];\n    return newImage;\n  }\n\n  let shiftX = Math.round((this.width - width) / 2);\n  let shiftY = Math.round((this.height - height) / 2);\n  const newImage = Image.createFrom(this, {\n    width,\n    height,\n    position: [shiftX, shiftY]\n  });\n\n  switch (interpolationToUse) {\n    case validInterpolations.nearestneighbor:\n      nearestNeighbor.call(this, newImage, width, height);\n      break;\n\n    default:\n      throw new Error(`unsupported resize interpolation: ${interpolationToUse}`);\n  }\n\n  return newImage;\n}","map":{"version":3,"sources":["C:/Users/kuent/Documents/FinishDipshit/Creative/Ocean-Weather-Visualization/node_modules/image-js/src/image/transform/resize/resize.js"],"names":["factorDimensions","Image","validInterpolations","checkInterpolation","nearestNeighbor","resize","options","factor","interpolation","nearestneighbor","preserveAspectRatio","interpolationToUse","width","height","Math","round","newImage","clone","position","shiftX","shiftY","createFrom","call","Error"],"mappings":"AAAA,SAASA,gBAAT,QAAiC,yBAAjC;AACA,OAAOC,KAAP,MAAkB,aAAlB;AACA,SAASC,mBAAT,EAA8BC,kBAA9B,QAAwD,uBAAxD;AAEA,OAAOC,eAAP,MAA4B,mBAA5B;AAEA;;;;;;;;;;;;;AAYA,eAAe,SAASC,MAAT,CAAgBC,OAAO,GAAG,EAA1B,EAA8B;AAC3C,QAAM;AACJC,IAAAA,MAAM,GAAG,CADL;AAEJC,IAAAA,aAAa,GAAGN,mBAAmB,CAACO,eAFhC;AAGJC,IAAAA,mBAAmB,GAAG;AAHlB,MAIFJ,OAJJ;AAMA,QAAMK,kBAAkB,GAAGR,kBAAkB,CAACK,aAAD,CAA7C;AAEA,MAAII,KAAK,GAAGN,OAAO,CAACM,KAApB;AACA,MAAIC,MAAM,GAAGP,OAAO,CAACO,MAArB;;AAEA,MAAI,CAACD,KAAL,EAAY;AACV,QAAIC,MAAM,IAAIH,mBAAd,EAAmC;AACjCE,MAAAA,KAAK,GAAGE,IAAI,CAACC,KAAL,CAAWF,MAAM,IAAI,KAAKD,KAAL,GAAa,KAAKC,MAAtB,CAAjB,CAAR;AACD,KAFD,MAEO;AACLD,MAAAA,KAAK,GAAG,KAAKA,KAAb;AACD;AACF;;AACD,MAAI,CAACC,MAAL,EAAa;AACX,QAAIH,mBAAJ,EAAyB;AACvBG,MAAAA,MAAM,GAAGC,IAAI,CAACC,KAAL,CAAWH,KAAK,IAAI,KAAKC,MAAL,GAAc,KAAKD,KAAvB,CAAhB,CAAT;AACD,KAFD,MAEO;AACLC,MAAAA,MAAM,GAAG,KAAKA,MAAd;AACD;AACF;;AAED,GAAC;AAAED,IAAAA,KAAF;AAASC,IAAAA;AAAT,MAAoBb,gBAAgB,CAACO,MAAD,EAASK,KAAT,EAAgBC,MAAhB,CAArC;;AAEA,MAAID,KAAK,KAAK,KAAKA,KAAf,IAAwBC,MAAM,KAAK,KAAKA,MAA5C,EAAoD;AAClD,UAAMG,QAAQ,GAAG,KAAKC,KAAL,EAAjB;AACAD,IAAAA,QAAQ,CAACE,QAAT,GAAoB,CAAC,CAAD,EAAI,CAAJ,CAApB;AACA,WAAOF,QAAP;AACD;;AAED,MAAIG,MAAM,GAAGL,IAAI,CAACC,KAAL,CAAW,CAAC,KAAKH,KAAL,GAAaA,KAAd,IAAuB,CAAlC,CAAb;AACA,MAAIQ,MAAM,GAAGN,IAAI,CAACC,KAAL,CAAW,CAAC,KAAKF,MAAL,GAAcA,MAAf,IAAyB,CAApC,CAAb;AACA,QAAMG,QAAQ,GAAGf,KAAK,CAACoB,UAAN,CAAiB,IAAjB,EAAuB;AACtCT,IAAAA,KADsC;AAEtCC,IAAAA,MAFsC;AAGtCK,IAAAA,QAAQ,EAAE,CAACC,MAAD,EAASC,MAAT;AAH4B,GAAvB,CAAjB;;AAMA,UAAQT,kBAAR;AACE,SAAKT,mBAAmB,CAACO,eAAzB;AACEL,MAAAA,eAAe,CAACkB,IAAhB,CAAqB,IAArB,EAA2BN,QAA3B,EAAqCJ,KAArC,EAA4CC,MAA5C;AACA;;AACF;AACE,YAAM,IAAIU,KAAJ,CACH,qCAAoCZ,kBAAmB,EADpD,CAAN;AALJ;;AAUA,SAAOK,QAAP;AACD","sourcesContent":["import { factorDimensions } from '../../../util/converter';\nimport Image from '../../Image';\nimport { validInterpolations, checkInterpolation } from '../../internal/checks';\n\nimport nearestNeighbor from './nearestNeighbor';\n\n/**\n * Resize an image\n * @memberof Image\n * @instance\n * @param {object} [options]\n * @param {number} [options.width=this.width] - new width\n * @param {number} [options.height=this.height] - new height\n * @param {number} [options.factor=1] - scaling factor (applied to the new width and height values)\n * @param {InterpolationAlgorithm} [options.interpolation='nearestNeighbor']\n * @param {boolean} [options.preserveAspectRatio=true] - preserve width/height ratio if only one of them is defined\n * @return {Image}\n */\nexport default function resize(options = {}) {\n  const {\n    factor = 1,\n    interpolation = validInterpolations.nearestneighbor,\n    preserveAspectRatio = true,\n  } = options;\n\n  const interpolationToUse = checkInterpolation(interpolation);\n\n  let width = options.width;\n  let height = options.height;\n\n  if (!width) {\n    if (height && preserveAspectRatio) {\n      width = Math.round(height * (this.width / this.height));\n    } else {\n      width = this.width;\n    }\n  }\n  if (!height) {\n    if (preserveAspectRatio) {\n      height = Math.round(width * (this.height / this.width));\n    } else {\n      height = this.height;\n    }\n  }\n\n  ({ width, height } = factorDimensions(factor, width, height));\n\n  if (width === this.width && height === this.height) {\n    const newImage = this.clone();\n    newImage.position = [0, 0];\n    return newImage;\n  }\n\n  let shiftX = Math.round((this.width - width) / 2);\n  let shiftY = Math.round((this.height - height) / 2);\n  const newImage = Image.createFrom(this, {\n    width,\n    height,\n    position: [shiftX, shiftY],\n  });\n\n  switch (interpolationToUse) {\n    case validInterpolations.nearestneighbor:\n      nearestNeighbor.call(this, newImage, width, height);\n      break;\n    default:\n      throw new Error(\n        `unsupported resize interpolation: ${interpolationToUse}`,\n      );\n  }\n\n  return newImage;\n}\n"]},"metadata":{},"sourceType":"module"}