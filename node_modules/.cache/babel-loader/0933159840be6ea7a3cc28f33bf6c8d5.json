{"ast":null,"code":"/**\n * Paint a polygon defined by an array of points.\n * @memberof Image\n * @instance\n * @param {Array<Array<number>>} points - Array of [x,y] points\n * @param {object} [options]\n * @param {Array<number>} [options.color=[max,0,0]] - Array of 3 elements (R, G, B), default is red.\n * @param {Array<number>} [options.filled=false] - If you want the polygon to be filled or not.\n * @return {this} The original painted image\n */\nexport default function paintPolygon(points, options = {}) {\n  let {\n    color = [this.maxValue, 0, 0],\n    filled = false\n  } = options;\n  this.checkProcessable('paintPoints', {\n    bitDepth: [1, 8, 16]\n  });\n  options.closed = true;\n  let filteredPoints = deleteDouble(points);\n\n  if (filled === false) {\n    return this.paintPolyline(points, options);\n  } else {\n    let matrixBinary = Array(this.height);\n\n    for (let i = 0; i < this.height; i++) {\n      matrixBinary[i] = [];\n\n      for (let j = 0; j < this.width; j++) {\n        matrixBinary[i].push(0);\n      }\n    }\n\n    for (let p = 0; p < filteredPoints.length; p++) {\n      const line = lineBetweenTwoPoints(filteredPoints[p], filteredPoints[(p + 1) % filteredPoints.length]);\n\n      for (let y = 0; y < this.height; y++) {\n        for (let x = 0; x < this.width; x++) {\n          if (isAtTheRightOfTheLine(x, y, line, this.height)) {\n            matrixBinary[y][x] = matrixBinary[y][x] === 0 ? 1 : 0;\n          }\n        }\n      }\n    }\n\n    for (let y = 0; y < this.height; y++) {\n      for (let x = 0; x < this.width; x++) {\n        if (matrixBinary[y][x] === 1) {\n          if (this.bitDepth === 1) {\n            this.setBitXY(x, y);\n          } else {\n            let numberChannels = Math.min(this.channels, color.length);\n            let position = (x + y * this.width) * this.channels;\n\n            for (let channel = 0; channel < numberChannels; channel++) {\n              this.data[position + channel] = color[channel];\n            }\n          }\n        }\n      }\n    }\n\n    return this.paintPolyline(points, options);\n  }\n}\n\nfunction deleteDouble(points) {\n  let finalPoints = [];\n\n  for (let i = 0; i < points.length; i++) {\n    if (points[i][0] === points[(i + 1) % points.length][0] && points[i][1] === points[(i + 1) % points.length][1]) {\n      continue;\n    } else if (points[i][0] === points[(i - 1 + points.length) % points.length][0] && points[i][1] === points[(i - 1 + points.length) % points.length][1]) {\n      continue;\n    } else if (points[(i + 1) % points.length][0] === points[(i - 1 + points.length) % points.length][0] && points[(i - 1 + points.length) % points.length][1] === points[(i + 1) % points.length][1]) {\n      continue; // we don't consider this point only\n    } else {\n      finalPoints.push(points[i]);\n    }\n  }\n\n  return finalPoints;\n}\n\nfunction lineBetweenTwoPoints(p1, p2) {\n  if (p1[0] === p2[0]) {\n    return {\n      a: 0,\n      b: p1[0],\n      vertical: true\n    }; // we store the x of the vertical line into b\n  } else {\n    const coeffA = (p2[1] - p1[1]) / (p2[0] - p1[0]);\n    const coeffB = p1[1] - coeffA * p1[0];\n    return {\n      a: coeffA,\n      b: coeffB,\n      vertical: false\n    };\n  }\n}\n\nfunction isAtTheRightOfTheLine(x, y, line, height) {\n  if (line.vertical === true) {\n    return line.b <= x;\n  } else {\n    if (line.a === 0) {\n      return false;\n    } else {\n      const xline = (y - line.b) / line.a;\n      return xline < x && xline >= 0 && xline <= height;\n    }\n  }\n}","map":{"version":3,"sources":["C:/Users/kuent/Documents/FinishDipshit/Creative/Ocean-Weather-Visualization/node_modules/image-js/src/image/operator/paintPolygon.js"],"names":["paintPolygon","points","options","color","maxValue","filled","checkProcessable","bitDepth","closed","filteredPoints","deleteDouble","paintPolyline","matrixBinary","Array","height","i","j","width","push","p","length","line","lineBetweenTwoPoints","y","x","isAtTheRightOfTheLine","setBitXY","numberChannels","Math","min","channels","position","channel","data","finalPoints","p1","p2","a","b","vertical","coeffA","coeffB","xline"],"mappings":"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","sourcesContent":["/**\n * Paint a polygon defined by an array of points.\n * @memberof Image\n * @instance\n * @param {Array<Array<number>>} points - Array of [x,y] points\n * @param {object} [options]\n * @param {Array<number>} [options.color=[max,0,0]] - Array of 3 elements (R, G, B), default is red.\n * @param {Array<number>} [options.filled=false] - If you want the polygon to be filled or not.\n * @return {this} The original painted image\n */\nexport default function paintPolygon(points, options = {}) {\n  let { color = [this.maxValue, 0, 0], filled = false } = options;\n\n  this.checkProcessable('paintPoints', {\n    bitDepth: [1, 8, 16],\n  });\n\n  options.closed = true;\n\n  let filteredPoints = deleteDouble(points);\n  if (filled === false) {\n    return this.paintPolyline(points, options);\n  } else {\n    let matrixBinary = Array(this.height);\n    for (let i = 0; i < this.height; i++) {\n      matrixBinary[i] = [];\n      for (let j = 0; j < this.width; j++) {\n        matrixBinary[i].push(0);\n      }\n    }\n    for (let p = 0; p < filteredPoints.length; p++) {\n      const line = lineBetweenTwoPoints(\n        filteredPoints[p],\n        filteredPoints[(p + 1) % filteredPoints.length],\n      );\n      for (let y = 0; y < this.height; y++) {\n        for (let x = 0; x < this.width; x++) {\n          if (isAtTheRightOfTheLine(x, y, line, this.height)) {\n            matrixBinary[y][x] = matrixBinary[y][x] === 0 ? 1 : 0;\n          }\n        }\n      }\n    }\n    for (let y = 0; y < this.height; y++) {\n      for (let x = 0; x < this.width; x++) {\n        if (matrixBinary[y][x] === 1) {\n          if (this.bitDepth === 1) {\n            this.setBitXY(x, y);\n          } else {\n            let numberChannels = Math.min(this.channels, color.length);\n            let position = (x + y * this.width) * this.channels;\n            for (let channel = 0; channel < numberChannels; channel++) {\n              this.data[position + channel] = color[channel];\n            }\n          }\n        }\n      }\n    }\n    return this.paintPolyline(points, options);\n  }\n}\n\nfunction deleteDouble(points) {\n  let finalPoints = [];\n  for (let i = 0; i < points.length; i++) {\n    if (\n      points[i][0] === points[(i + 1) % points.length][0] &&\n      points[i][1] === points[(i + 1) % points.length][1]\n    ) {\n      continue;\n    } else if (\n      points[i][0] === points[(i - 1 + points.length) % points.length][0] &&\n      points[i][1] === points[(i - 1 + points.length) % points.length][1]\n    ) {\n      continue;\n    } else if (\n      points[(i + 1) % points.length][0] ===\n        points[(i - 1 + points.length) % points.length][0] &&\n      points[(i - 1 + points.length) % points.length][1] ===\n        points[(i + 1) % points.length][1]\n    ) {\n      continue; // we don't consider this point only\n    } else {\n      finalPoints.push(points[i]);\n    }\n  }\n  return finalPoints;\n}\n\nfunction lineBetweenTwoPoints(p1, p2) {\n  if (p1[0] === p2[0]) {\n    return { a: 0, b: p1[0], vertical: true }; // we store the x of the vertical line into b\n  } else {\n    const coeffA = (p2[1] - p1[1]) / (p2[0] - p1[0]);\n    const coeffB = p1[1] - coeffA * p1[0];\n    return { a: coeffA, b: coeffB, vertical: false };\n  }\n}\n\nfunction isAtTheRightOfTheLine(x, y, line, height) {\n  if (line.vertical === true) {\n    return line.b <= x;\n  } else {\n    if (line.a === 0) {\n      return false;\n    } else {\n      const xline = (y - line.b) / line.a;\n      return xline < x && xline >= 0 && xline <= height;\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"module"}