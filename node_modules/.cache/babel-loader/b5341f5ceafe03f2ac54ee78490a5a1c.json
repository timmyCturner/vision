{"ast":null,"code":"// see https://github.com/fiji/Auto_Threshold/blob/master/src/main/java/fiji/threshold/Auto_Threshold.java\n// W. Tsai, \"Moment-preserving thresholding: a new approach,\" Computer Vision,\n// Graphics, and Image Processing, vol. 29, pp. 377-393, 1985.\n// Ported to ImageJ plugin by G.Landini from the the open source project FOURIER 0.8\n// by M. Emre Celebi , Department of Computer Science, Louisiana State University in Shreveport\n// Shreveport, LA 71115, USA\n// http://sourceforge.net/projects/fourier-ipal\n// http://www.lsus.edu/faculty/~ecelebi/fourier.htm\nexport default function moments(histogram, total) {\n  // moments\n  let m0 = 1.0;\n  let m1 = 0.0;\n  let m2 = 0.0;\n  let m3 = 0.0;\n  let sum = 0.0;\n  let p0;\n  let cd, c0, c1, z0, z1;\n  /* auxiliary variables */\n\n  let threshold = -1;\n  let histogramLength = histogram.length;\n  let normalizedHistogram = new Array(histogramLength);\n\n  for (let i = 0; i < histogramLength; i++) {\n    normalizedHistogram[i] = histogram[i] / total;\n  }\n  /* Calculate the first, second, and third order moments */\n\n\n  for (let i = 0; i < histogramLength; i++) {\n    m1 += i * normalizedHistogram[i];\n    m2 += i * i * normalizedHistogram[i];\n    m3 += i * i * i * normalizedHistogram[i];\n  }\n  /*\n     First 4 moments of the gray-level image should match the first 4 moments\n     of the target binary image. This leads to 4 equalities whose solutions\n     are given in the Appendix of Ref. 1\n     */\n\n\n  cd = m0 * m2 - m1 * m1; // determinant of the matriz of hankel for moments 2x2\n\n  c0 = (-m2 * m2 + m1 * m3) / cd;\n  c1 = (m0 * -m3 + m2 * m1) / cd; // new two gray values where z0<z1\n\n  z0 = 0.5 * (-c1 - Math.sqrt(c1 * c1 - 4.0 * c0));\n  z1 = 0.5 * (-c1 + Math.sqrt(c1 * c1 - 4.0 * c0));\n  p0 = (z1 - m1) / (z1 - z0);\n  /* Fraction of the object pixels in the target binary image (p0z0+p1z1=m1) */\n  // The threshold is the gray-level closest to the p0-tile of the normalized histogram\n\n  for (let i = 0; i < histogramLength; i++) {\n    sum += normalizedHistogram[i];\n\n    if (sum > p0) {\n      threshold = i;\n      break;\n    }\n  }\n\n  return threshold;\n}","map":{"version":3,"sources":["C:/Users/kuent/Documents/FinishDipshit/Creative/Ocean-Weather-Visualization/node_modules/image-js/src/image/transform/mask/moments.js"],"names":["moments","histogram","total","m0","m1","m2","m3","sum","p0","cd","c0","c1","z0","z1","threshold","histogramLength","length","normalizedHistogram","Array","i","Math","sqrt"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,SAASA,OAAT,CAAiBC,SAAjB,EAA4BC,KAA5B,EAAmC;AAChD;AACA,MAAIC,EAAE,GAAG,GAAT;AACA,MAAIC,EAAE,GAAG,GAAT;AACA,MAAIC,EAAE,GAAG,GAAT;AACA,MAAIC,EAAE,GAAG,GAAT;AACA,MAAIC,GAAG,GAAG,GAAV;AACA,MAAIC,EAAJ;AACA,MAAIC,EAAJ,EAAQC,EAAR,EAAYC,EAAZ,EAAgBC,EAAhB,EAAoBC,EAApB;AAAwB;;AACxB,MAAIC,SAAS,GAAG,CAAC,CAAjB;AACA,MAAIC,eAAe,GAAGd,SAAS,CAACe,MAAhC;AACA,MAAIC,mBAAmB,GAAG,IAAIC,KAAJ,CAAUH,eAAV,CAA1B;;AACA,OAAK,IAAII,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGJ,eAApB,EAAqCI,CAAC,EAAtC,EAA0C;AACxCF,IAAAA,mBAAmB,CAACE,CAAD,CAAnB,GAAyBlB,SAAS,CAACkB,CAAD,CAAT,GAAejB,KAAxC;AACD;AACD;;;AACA,OAAK,IAAIiB,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGJ,eAApB,EAAqCI,CAAC,EAAtC,EAA0C;AACxCf,IAAAA,EAAE,IAAIe,CAAC,GAAGF,mBAAmB,CAACE,CAAD,CAA7B;AACAd,IAAAA,EAAE,IAAIc,CAAC,GAAGA,CAAJ,GAAQF,mBAAmB,CAACE,CAAD,CAAjC;AACAb,IAAAA,EAAE,IAAIa,CAAC,GAAGA,CAAJ,GAAQA,CAAR,GAAYF,mBAAmB,CAACE,CAAD,CAArC;AACD;AACD;;;;;;;AAKAV,EAAAA,EAAE,GAAGN,EAAE,GAAGE,EAAL,GAAUD,EAAE,GAAGA,EAApB,CA1BgD,CA0BxB;;AACxBM,EAAAA,EAAE,GAAG,CAAC,CAACL,EAAD,GAAMA,EAAN,GAAWD,EAAE,GAAGE,EAAjB,IAAuBG,EAA5B;AACAE,EAAAA,EAAE,GAAG,CAACR,EAAE,GAAG,CAACG,EAAN,GAAWD,EAAE,GAAGD,EAAjB,IAAuBK,EAA5B,CA5BgD,CA6BhD;;AACAG,EAAAA,EAAE,GAAG,OAAO,CAACD,EAAD,GAAMS,IAAI,CAACC,IAAL,CAAUV,EAAE,GAAGA,EAAL,GAAU,MAAMD,EAA1B,CAAb,CAAL;AACAG,EAAAA,EAAE,GAAG,OAAO,CAACF,EAAD,GAAMS,IAAI,CAACC,IAAL,CAAUV,EAAE,GAAGA,EAAL,GAAU,MAAMD,EAA1B,CAAb,CAAL;AACAF,EAAAA,EAAE,GACA,CAACK,EAAE,GAAGT,EAAN,KACCS,EAAE,GACDD,EAFF,CADF;AAGS;AACT;;AACA,OAAK,IAAIO,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGJ,eAApB,EAAqCI,CAAC,EAAtC,EAA0C;AACxCZ,IAAAA,GAAG,IAAIU,mBAAmB,CAACE,CAAD,CAA1B;;AACA,QAAIZ,GAAG,GAAGC,EAAV,EAAc;AACZM,MAAAA,SAAS,GAAGK,CAAZ;AACA;AACD;AACF;;AACD,SAAOL,SAAP;AACD","sourcesContent":["// see https://github.com/fiji/Auto_Threshold/blob/master/src/main/java/fiji/threshold/Auto_Threshold.java\n// W. Tsai, \"Moment-preserving thresholding: a new approach,\" Computer Vision,\n// Graphics, and Image Processing, vol. 29, pp. 377-393, 1985.\n// Ported to ImageJ plugin by G.Landini from the the open source project FOURIER 0.8\n// by M. Emre Celebi , Department of Computer Science, Louisiana State University in Shreveport\n// Shreveport, LA 71115, USA\n// http://sourceforge.net/projects/fourier-ipal\n// http://www.lsus.edu/faculty/~ecelebi/fourier.htm\nexport default function moments(histogram, total) {\n  // moments\n  let m0 = 1.0;\n  let m1 = 0.0;\n  let m2 = 0.0;\n  let m3 = 0.0;\n  let sum = 0.0;\n  let p0;\n  let cd, c0, c1, z0, z1; /* auxiliary variables */\n  let threshold = -1;\n  let histogramLength = histogram.length;\n  let normalizedHistogram = new Array(histogramLength);\n  for (let i = 0; i < histogramLength; i++) {\n    normalizedHistogram[i] = histogram[i] / total;\n  }\n  /* Calculate the first, second, and third order moments */\n  for (let i = 0; i < histogramLength; i++) {\n    m1 += i * normalizedHistogram[i];\n    m2 += i * i * normalizedHistogram[i];\n    m3 += i * i * i * normalizedHistogram[i];\n  }\n  /*\n     First 4 moments of the gray-level image should match the first 4 moments\n     of the target binary image. This leads to 4 equalities whose solutions\n     are given in the Appendix of Ref. 1\n     */\n  cd = m0 * m2 - m1 * m1; // determinant of the matriz of hankel for moments 2x2\n  c0 = (-m2 * m2 + m1 * m3) / cd;\n  c1 = (m0 * -m3 + m2 * m1) / cd;\n  // new two gray values where z0<z1\n  z0 = 0.5 * (-c1 - Math.sqrt(c1 * c1 - 4.0 * c0));\n  z1 = 0.5 * (-c1 + Math.sqrt(c1 * c1 - 4.0 * c0));\n  p0 =\n    (z1 - m1) /\n    (z1 -\n      z0); /* Fraction of the object pixels in the target binary image (p0z0+p1z1=m1) */\n  // The threshold is the gray-level closest to the p0-tile of the normalized histogram\n  for (let i = 0; i < histogramLength; i++) {\n    sum += normalizedHistogram[i];\n    if (sum > p0) {\n      threshold = i;\n      break;\n    }\n  }\n  return threshold;\n}\n"]},"metadata":{},"sourceType":"module"}