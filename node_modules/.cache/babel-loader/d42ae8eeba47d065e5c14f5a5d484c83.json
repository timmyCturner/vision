{"ast":null,"code":"import { css2array } from '../../util/color';\nimport { RGB } from '../model/model';\n/**\n * Paint a mask or masks on the current image.\n * @memberof Image\n * @instance\n *\n * @param {Array<string>}       [labels] - Array of labels to display. Should the the same size as masks.\n * @param {Array<Array>}        [positions] - Array of labels to display. Should the the same size as masks.\n * @param {object}              [options]\n * @param {number[]|string}     [options.color='red'] - Array of 3 elements (R, G, B) or a valid css color.\n * @param {Array<Array<number>>|Array<string>} [options.colors] - Array of Array of 3 elements (R, G, B) for each color of each mask\n * @param {string|Array<string>} [options.font='12px Helvetica'] - Paint the labels in a different CSS style\n * @param {number|Array<number>} [options.rotate=0] - Rotate each label of a define angle\n * @return {this} The original painted image\n */\n\nexport default function paintLabels(labels, positions, options = {}) {\n  let {\n    color = 'blue',\n    colors,\n    font = '12px Helvetica',\n    rotate = 0\n  } = options;\n  this.checkProcessable('paintMasks', {\n    channels: [3, 4],\n    bitDepth: [8, 16],\n    colorModel: RGB\n  });\n\n  if (!Array.isArray(labels)) {\n    throw Error('paintLabels: labels must be an array');\n  }\n\n  if (!Array.isArray(positions)) {\n    throw Error('paintLabels: positions must be an array');\n  }\n\n  if (color && !Array.isArray(color)) {\n    color = css2array(color);\n  }\n\n  if (colors) {\n    colors = colors.map(function (color) {\n      if (!Array.isArray(color)) {\n        return css2array(color);\n      }\n\n      return color;\n    });\n  } else {\n    colors = [color];\n  }\n\n  if (labels.length !== positions.length) {\n    throw Error('paintLabels: positions and labels must be arrays from the same size');\n  } // We convert everything to array so that we can simply loop thourgh all the labels\n\n\n  if (!Array.isArray(font)) font = [font];\n  if (!Array.isArray(rotate)) rotate = [rotate];\n  let canvas = this.getCanvas();\n  let ctx = canvas.getContext('2d');\n\n  for (let i = 0; i < labels.length; i++) {\n    ctx.save();\n    let color = colors[i % colors.length];\n    ctx.fillStyle = `rgba(${color[0]},${color[1]},${color[2]},${color[3] / this.maxValue})`;\n    ctx.font = font[i % font.length];\n    let position = positions[i];\n    ctx.translate(position[0], position[1]);\n    ctx.rotate(rotate[i % rotate.length] / 180 * Math.PI);\n    ctx.fillText(labels[i], 0, 0);\n    ctx.restore();\n  }\n\n  this.data = Uint8Array.from(ctx.getImageData(0, 0, this.width, this.height).data);\n  return this;\n}","map":{"version":3,"sources":["C:/Users/kuent/Documents/FinishDipshit/Creative/Ocean-Weather-Visualization/node_modules/image-js/src/image/operator/paintLabels.js"],"names":["css2array","RGB","paintLabels","labels","positions","options","color","colors","font","rotate","checkProcessable","channels","bitDepth","colorModel","Array","isArray","Error","map","length","canvas","getCanvas","ctx","getContext","i","save","fillStyle","maxValue","position","translate","Math","PI","fillText","restore","data","Uint8Array","from","getImageData","width","height"],"mappings":"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","sourcesContent":["import { css2array } from '../../util/color';\nimport { RGB } from '../model/model';\n\n/**\n * Paint a mask or masks on the current image.\n * @memberof Image\n * @instance\n *\n * @param {Array<string>}       [labels] - Array of labels to display. Should the the same size as masks.\n * @param {Array<Array>}        [positions] - Array of labels to display. Should the the same size as masks.\n * @param {object}              [options]\n * @param {number[]|string}     [options.color='red'] - Array of 3 elements (R, G, B) or a valid css color.\n * @param {Array<Array<number>>|Array<string>} [options.colors] - Array of Array of 3 elements (R, G, B) for each color of each mask\n * @param {string|Array<string>} [options.font='12px Helvetica'] - Paint the labels in a different CSS style\n * @param {number|Array<number>} [options.rotate=0] - Rotate each label of a define angle\n * @return {this} The original painted image\n */\nexport default function paintLabels(labels, positions, options = {}) {\n  let { color = 'blue', colors, font = '12px Helvetica', rotate = 0 } = options;\n\n  this.checkProcessable('paintMasks', {\n    channels: [3, 4],\n    bitDepth: [8, 16],\n    colorModel: RGB,\n  });\n\n  if (!Array.isArray(labels)) {\n    throw Error('paintLabels: labels must be an array');\n  }\n\n  if (!Array.isArray(positions)) {\n    throw Error('paintLabels: positions must be an array');\n  }\n\n  if (color && !Array.isArray(color)) {\n    color = css2array(color);\n  }\n\n  if (colors) {\n    colors = colors.map(function (color) {\n      if (!Array.isArray(color)) {\n        return css2array(color);\n      }\n      return color;\n    });\n  } else {\n    colors = [color];\n  }\n\n  if (labels.length !== positions.length) {\n    throw Error(\n      'paintLabels: positions and labels must be arrays from the same size',\n    );\n  }\n\n  // We convert everything to array so that we can simply loop thourgh all the labels\n  if (!Array.isArray(font)) font = [font];\n  if (!Array.isArray(rotate)) rotate = [rotate];\n\n  let canvas = this.getCanvas();\n  let ctx = canvas.getContext('2d');\n  for (let i = 0; i < labels.length; i++) {\n    ctx.save();\n    let color = colors[i % colors.length];\n    ctx.fillStyle = `rgba(${color[0]},${color[1]},${color[2]},${\n      color[3] / this.maxValue\n    })`;\n    ctx.font = font[i % font.length];\n    let position = positions[i];\n    ctx.translate(position[0], position[1]);\n    ctx.rotate((rotate[i % rotate.length] / 180) * Math.PI);\n    ctx.fillText(labels[i], 0, 0);\n    ctx.restore();\n  }\n  this.data = Uint8Array.from(\n    ctx.getImageData(0, 0, this.width, this.height).data,\n  );\n\n  return this;\n}\n"]},"metadata":{},"sourceType":"module"}