{"ast":null,"code":"import mcch from 'monotone-chain-convex-hull';\nimport Shape from '../../util/Shape';\nimport { round, minMax as minMaxFct, moveToZeroZero, perimeter, surface } from '../../util/points';\nimport Image from '../Image';\nimport minimalBoundingRectangle from '../compute/minimalBoundingRectangle';\nimport * as KindNames from '../core/kindNames';\nimport feretDiameters from './feretDiameters'; // Many measurements:\n// https://www.sympatec.com/en/particle-measurement/glossary/particle-shape/#\n\n/**\n * Class to manage Region Of Interests\n * @class Roi\n */\n\nexport default class Roi {\n  constructor(map, id) {\n    this.map = map;\n    this.id = id;\n    this.minX = Number.POSITIVE_INFINITY;\n    this.maxX = Number.NEGATIVE_INFINITY;\n    this.minY = Number.POSITIVE_INFINITY;\n    this.maxY = Number.NEGATIVE_INFINITY;\n    this.meanX = 0;\n    this.meanY = 0;\n    this.surface = 0;\n    this.computed = {};\n  }\n  /**\n   * Returns a binary image (mask) for the corresponding ROI\n   * @param {object} [options]\n   * @param {number} [options.scale=1] - Scaling factor to apply to the mask\n   * @param {string} [options.kind='normal'] - 'contour', 'box', 'filled', 'center', 'hull' or 'normal'\n   * @return {Image} - Returns a mask (1 bit Image)\n   */\n\n\n  getMask(options = {}) {\n    const {\n      scale = 1,\n      kind = ''\n    } = options;\n    let mask;\n\n    switch (kind) {\n      case 'contour':\n        mask = this.contourMask;\n        break;\n\n      case 'box':\n        mask = this.boxMask;\n        break;\n\n      case 'filled':\n        mask = this.filledMask;\n        break;\n\n      case 'center':\n        mask = this.centerMask;\n        break;\n\n      case 'hull':\n        mask = this.convexHullMask;\n        break;\n\n      case 'mbr':\n        mask = this.mbrMask;\n        break;\n\n      case 'feret':\n        mask = this.feretMask;\n        break;\n\n      default:\n        mask = this.mask;\n    }\n\n    if (scale < 1) {\n      // by reassigning the mask we loose the parent and therefore the position\n      // we will have to force it back\n      mask = mask.resize({\n        factor: scale\n      });\n      mask.parent = this.mask.parent;\n      mask.position[0] += this.minX;\n      mask.position[1] += this.minY;\n    }\n\n    return mask;\n  }\n\n  get mean() {\n    throw new Error('Roi mean not implemented yet'); // return [this.meanX,this.meanY];\n  }\n\n  get center() {\n    if (!this.computed.center) {\n      this.computed.center = [this.width / 2 >> 0, this.height / 2 >> 0];\n    }\n\n    return this.computed.center;\n  }\n\n  get ratio() {\n    return this.width / this.height;\n  }\n\n  get width() {\n    return this.maxX - this.minX + 1;\n  }\n\n  get height() {\n    return this.maxY - this.minY + 1;\n  }\n\n  _computExternalIDs() {\n    // take all the borders and remove the internal one ...\n    let borders = this.borderIDs;\n    let lengths = this.borderLengths;\n    this.computed.externalIDs = [];\n    this.computed.externalLengths = [];\n    let internals = this.internalIDs;\n\n    for (let i = 0; i < borders.length; i++) {\n      if (!internals.includes(borders[i])) {\n        this.computed.externalIDs.push(borders[i]);\n        this.computed.externalLengths.push(lengths[i]);\n      }\n    }\n  }\n\n  get externalIDs() {\n    if (this.computed.externalIDs) {\n      return this.computed.externalIDs;\n    }\n\n    this._computExternalIDs();\n\n    return this.computed.externalIDs;\n  }\n\n  get externalLengths() {\n    if (this.computed.externalLengths) {\n      return this.computed.externalLengths;\n    }\n\n    this._computExternalIDs();\n\n    return this.computed.externalLengths;\n  }\n\n  _computeBorderIDs() {\n    let borders = getBorders(this);\n    this.computed.borderIDs = borders.ids;\n    this.computed.borderLengths = borders.lengths;\n  }\n  /**\n     Retrieve all the IDs (array of number) of the regions that are in contact with this\n     specific region. It may be external or internal\n     */\n\n\n  get borderIDs() {\n    if (this.computed.borderIDs) {\n      return this.computed.borderIDs;\n    }\n\n    this._computeBorderIDs();\n\n    return this.computed.borderIDs;\n  }\n  /**\n     Retrieve all the length (array of number) of the contacts with this\n     specific region. It may be external or internal\n     */\n\n\n  get borderLengths() {\n    if (this.computed.borderLengths) {\n      return this.computed.borderLengths;\n    }\n\n    this._computeBorderIDs();\n\n    return this.computed.borderLengths;\n  }\n  /**\n     Retrieve all the IDs or the Roi touching the box surrouding the region\n      It should really be an array to solve complex cases related to border effect\n      Like the image\n     <pre>\n     0000\n     1111\n     0000\n     1111\n     </pre>\n      The first row of 1 will be surrouned by 2 differents zones\n      Or even worse\n     <pre>\n     010\n     111\n     010\n     </pre>\n     The cross will be surrouned by 4 differents zones\n      However in most of the cases it will be an array of one element\n     */\n\n\n  get boxIDs() {\n    if (!this.computed.boxIDs) {\n      this.computed.boxIDs = getBoxIDs(this);\n    }\n\n    return this.computed.boxIDs;\n  }\n\n  get internalIDs() {\n    if (!this.computed.internalIDs) {\n      this.computed.internalIDs = getInternalIDs(this);\n    }\n\n    return this.computed.internalIDs;\n  }\n  /**\n     Number of pixels of the Roi that touch the rectangle\n     This is useful for the calculation of the border\n     because we will ignore those special pixels of the rectangle\n     border that don't have neighbours all around them.\n     */\n\n\n  get box() {\n    // points of the Roi that touch the rectangular shape\n    if (!this.computed.box) {\n      this.computed.box = getBox(this);\n    }\n\n    return this.computed.box;\n  }\n  /**\n     Calculates the number of pixels that are in the external border of the Roi\n     Contour are all the pixels that touch an external \"zone\".\n     All the pixels that touch the box are part of the border and\n     are calculated in the getBoxPixels procedure\n     */\n\n\n  get external() {\n    if (!this.computed.external) {\n      this.computed.external = getExternal(this);\n    }\n\n    return this.computed.external;\n  }\n  /**\n     Calculates the number of pixels that are involved in border\n     Border are all the pixels that touch another \"zone\". It could be external\n     or internal. If there is a hole in the zone it will be counted as a border.\n     All the pixels that touch the box are part of the border and\n     are calculated in the getBoxPixels procedure\n     */\n\n\n  get border() {\n    if (!this.computed.border) {\n      this.computed.border = getBorder(this);\n    }\n\n    return this.computed.border;\n  }\n  /**\n    Returns a binary image (mask) containing only the border of the mask\n  */\n\n\n  get contourMask() {\n    if (!this.computed.contourMask) {\n      let img = new Image(this.width, this.height, {\n        kind: KindNames.BINARY,\n        position: [this.minX, this.minY],\n        parent: this.map.parent\n      });\n\n      for (let x = 0; x < this.width; x++) {\n        for (let y = 0; y < this.height; y++) {\n          if (this.map.data[x + this.minX + (y + this.minY) * this.map.width] === this.id) {\n            // it also has to be on a border ...\n            if (x > 0 && x < this.width - 1 && y > 0 && y < this.height - 1) {\n              if (this.map.data[x - 1 + this.minX + (y + this.minY) * this.map.width] !== this.id || this.map.data[x + 1 + this.minX + (y + this.minY) * this.map.width] !== this.id || this.map.data[x + this.minX + (y - 1 + this.minY) * this.map.width] !== this.id || this.map.data[x + this.minX + (y + 1 + this.minY) * this.map.width] !== this.id) {\n                img.setBitXY(x, y);\n              }\n            } else {\n              img.setBitXY(x, y);\n            }\n          }\n        }\n      }\n\n      this.computed.contourMask = img;\n    }\n\n    return this.computed.contourMask;\n  }\n\n  get boxMask() {\n    if (!this.computed.boxMask) {\n      let img = new Image(this.width, this.height, {\n        kind: KindNames.BINARY,\n        position: [this.minX, this.minY],\n        parent: this.map.parent\n      });\n\n      for (let x = 0; x < this.width; x++) {\n        img.setBitXY(x, 0);\n        img.setBitXY(x, this.height - 1);\n      }\n\n      for (let y = 0; y < this.height; y++) {\n        img.setBitXY(0, y);\n        img.setBitXY(this.width - 1, y);\n      }\n\n      this.computed.boxMask = img;\n    }\n\n    return this.computed.boxMask;\n  }\n  /**\n     Returns a binary image containing the mask\n     */\n\n\n  get mask() {\n    if (!this.computed.mask) {\n      let img = new Image(this.width, this.height, {\n        kind: KindNames.BINARY,\n        position: [this.minX, this.minY],\n        parent: this.map.parent\n      });\n\n      for (let x = 0; x < this.width; x++) {\n        for (let y = 0; y < this.height; y++) {\n          if (this.map.data[x + this.minX + (y + this.minY) * this.map.width] === this.id) {\n            img.setBitXY(x, y);\n          }\n        }\n      }\n\n      this.computed.mask = img;\n    }\n\n    return this.computed.mask;\n  }\n\n  get filledMask() {\n    if (!this.computed.filledMask) {\n      let img = new Image(this.width, this.height, {\n        kind: KindNames.BINARY,\n        position: [this.minX, this.minY],\n        parent: this.map.parent\n      });\n\n      for (let x = 0; x < this.width; x++) {\n        for (let y = 0; y < this.height; y++) {\n          let target = x + this.minX + (y + this.minY) * this.map.width;\n\n          if (this.internalIDs.includes(this.map.data[target])) {\n            img.setBitXY(x, y);\n          } // by default a pixel is to 0 so no problems, it will be transparent\n\n        }\n      }\n\n      this.computed.filledMask = img;\n    }\n\n    return this.computed.filledMask;\n  }\n\n  get centerMask() {\n    if (!this.computed.centerMask) {\n      let img = new Shape({\n        kind: 'smallCross'\n      }).getMask();\n      img.parent = this.map.parent;\n      img.position = [this.minX + this.center[0] - 1, this.minY + this.center[1] - 1];\n      this.computed.centerMask = img;\n    }\n\n    return this.computed.centerMask;\n  }\n\n  get convexHull() {\n    if (!this.computed.convexHull) {\n      const calculationPoints = []; // slow approach, we check all the points\n      // for each point we take the 4 corners !!!!\n\n      for (let x = 0; x < this.width; x++) {\n        for (let y = 0; y < this.height; y++) {\n          if (this.map.data[x + this.minX + (y + this.minY) * this.map.width] === this.id) {\n            // it also has to be on a border ...\n            if (x > 0 && x < this.width - 1 && y > 0 && y < this.height - 1) {\n              if (this.map.data[x - 1 + this.minX + (y + this.minY) * this.map.width] !== this.id || this.map.data[x + 1 + this.minX + (y + this.minY) * this.map.width] !== this.id || this.map.data[x + this.minX + (y - 1 + this.minY) * this.map.width] !== this.id || this.map.data[x + this.minX + (y + 1 + this.minY) * this.map.width] !== this.id) {\n                calculationPoints.push([x, y]);\n                calculationPoints.push([x + 1, y]);\n                calculationPoints.push([x, y + 1]);\n                calculationPoints.push([x + 1, y + 1]);\n              }\n            } else {\n              calculationPoints.push([x, y]);\n              calculationPoints.push([x + 1, y]);\n              calculationPoints.push([x, y + 1]);\n              calculationPoints.push([x + 1, y + 1]);\n            }\n          }\n        }\n      }\n\n      const convexHull = mcch(calculationPoints);\n      this.computed.convexHull = {\n        polyline: convexHull,\n        surface: surface(convexHull),\n        perimeter: perimeter(convexHull)\n      };\n    }\n\n    return this.computed.convexHull;\n  }\n\n  get convexHullMask() {\n    if (!this.computed.convexHullMask) {\n      const convexHull = this.convexHull;\n      const img = new Image(this.width + 1, this.height + 1, {\n        kind: KindNames.BINARY,\n        position: [this.minX, this.minY],\n        parent: this.map.parent\n      });\n      img.paintPolyline(convexHull.polyline, {\n        closed: true\n      });\n      this.computed.convexHullMask = img;\n    }\n\n    return this.computed.convexHullMask;\n  }\n\n  get mbr() {\n    if (!this.computed.mbr) {\n      let mbr = minimalBoundingRectangle({\n        originalPoints: this.convexHull.polyline\n      });\n\n      if (mbr.length === 0) {\n        this.computed.mbr = {\n          width: 0,\n          height: 0,\n          surface: 0,\n          perimeter: 0,\n          rectangle: mbr\n        };\n      } else {\n        let first = mbr[0];\n        let second = mbr[1];\n        let third = mbr[2];\n        let width = Math.sqrt((first[0] - second[0]) ** 2 + (first[1] - second[1]) ** 2);\n        let height = Math.sqrt((third[0] - second[0]) ** 2 + (third[1] - second[1]) ** 2);\n        this.computed.mbr = {\n          width,\n          height,\n          elongation: 1 - width / height,\n          aspectRatio: width / height,\n          surface: width * height,\n          perimeter: (width + height) * 2,\n          rectangle: mbr\n        };\n      }\n    }\n\n    return this.computed.mbr;\n  }\n\n  get feretDiameters() {\n    if (!this.computed.feretDiameters) {\n      this.computed.feretDiameters = feretDiameters({\n        originalPoints: this.convexHull.polyline\n      });\n    }\n\n    return this.computed.feretDiameters;\n  }\n  /**\n   * Diameter of a circle of equal projection area\n   */\n\n\n  get eqpc() {\n    if (!this.computed.eqpc) {\n      this.computed.eqpc = 2 * Math.sqrt(this.surface / Math.PI);\n    }\n\n    return this.computed.eqpc;\n  }\n  /**\n   * Get the category in which each external pixel belongs\n   */\n\n\n  get perimeterInfo() {\n    if (!this.computed.perimeterInfo) {\n      this.computed.perimeterInfo = getPerimeterInfo(this);\n    }\n\n    return this.computed.perimeterInfo;\n  }\n  /**\n   * Return the perimeter of the ROI\n   */\n\n\n  get perimeter() {\n    let info = this.perimeterInfo;\n    let delta = 2 - Math.sqrt(2);\n    return info.one + info.two * 2 + info.three * 3 + info.four * 4 - delta * (info.two + info.three * 2 + info.four);\n  }\n  /**\n   * Diameter of a circle of equal perimeter\n   */\n\n\n  get ped() {\n    if (!this.computed.ped) {\n      this.computed.ped = this.perimeter / Math.PI;\n    }\n\n    return this.computed.ped;\n  }\n\n  get feretMask() {\n    if (!this.computed.feretMask) {\n      const image = new Image(this.width + 1, this.height + 1, {\n        kind: KindNames.BINARY,\n        position: [this.minX, this.minY],\n        parent: this.map.parent\n      });\n      image.paintPolyline(this.feretDiameters.minLine);\n      image.paintPolyline(this.feretDiameters.maxLine);\n      this.computed.feretMask = image;\n    }\n\n    return this.computed.feretMask;\n  }\n\n  get mbrMask() {\n    if (!this.computed.mbrMask) {\n      let rectangle = round(this.mbr.rectangle);\n\n      if (rectangle.length > 0) {\n        // the problem is that the rectangle may be outside the roi\n        const minMax = minMaxFct(rectangle);\n        const img = new Image(minMax[1][0] - minMax[0][0] + 1, minMax[1][1] - minMax[0][1] + 1, {\n          kind: KindNames.BINARY,\n          position: [this.minX + minMax[0][0], this.minY + minMax[0][1]],\n          parent: this.map.parent\n        });\n        rectangle = moveToZeroZero(rectangle);\n        img.paintPolyline(rectangle, {\n          closed: true\n        });\n        this.computed.mbrMask = img;\n      } else {\n        this.computed.mbrMask = new Image(1, 1, {\n          kind: KindNames.BINARY,\n          position: [this.minX, this.minY],\n          parent: this.map.parent\n        });\n      }\n    }\n\n    return this.computed.mbrMask;\n  }\n\n  get points() {\n    if (!this.computed.points) {\n      let points = [];\n\n      for (let y = 0; y < this.height; y++) {\n        for (let x = 0; x < this.width; x++) {\n          let target = (y + this.minY) * this.map.width + x + this.minX;\n\n          if (this.map.data[target] === this.id) {\n            points.push([x, y]);\n          }\n        }\n      }\n\n      this.computed.points = points;\n    }\n\n    return this.computed.points;\n  }\n\n  get maxLengthPoints() {\n    if (!this.computed.maxLengthPoints) {\n      let maxLength = 0;\n      let maxLengthPoints;\n      const points = this.points;\n\n      for (let i = 0; i < points.length; i++) {\n        for (let j = i + 1; j < points.length; j++) {\n          let currentML = Math.pow(points[i][0] - points[j][0], 2) + Math.pow(points[i][1] - points[j][1], 2);\n\n          if (currentML >= maxLength) {\n            maxLength = currentML;\n            maxLengthPoints = [points[i], points[j]];\n          }\n        }\n      }\n\n      this.computed.maxLengthPoints = maxLengthPoints;\n    }\n\n    return this.computed.maxLengthPoints;\n  }\n  /**\n        Calculates the maximum length between two pixels of the Roi.\n     */\n\n\n  get maxLength() {\n    if (!this.computed.maxLength) {\n      let maxLength = Math.sqrt(Math.pow(this.maxLengthPoints[0][0] - this.maxLengthPoints[1][0], 2) + Math.pow(this.maxLengthPoints[0][1] - this.maxLengthPoints[1][1], 2));\n      this.computed.maxLength = maxLength;\n    }\n\n    return this.computed.maxLength;\n  }\n\n  get roundness() {\n    /*Slide 24 https://static.horiba.com/fileadmin/Horiba/Products/Scientific/Particle_Characterization/Webinars/Slides/TE011.pdf */\n    return 4 * this.surface / (Math.PI * this.feretDiameters.max) ** 2;\n  }\n\n  get sphericity() {\n    return 2 * Math.sqrt(this.surface * Math.PI) / this.perimeter;\n  }\n\n  get convexity() {\n    return this.surface / this.convexHull.surface;\n  }\n\n  get angle() {\n    if (!this.computed.angle) {\n      let points = this.maxLengthPoints;\n      let angle = -Math.atan2(points[0][1] - points[1][1], points[0][0] - points[1][0]) * 180 / Math.PI;\n      this.computed.angle = angle;\n    }\n\n    return this.computed.angle;\n  }\n\n  toJSON() {\n    return {\n      id: this.id,\n      minX: this.minX,\n      maxX: this.maxX,\n      minY: this.minY,\n      maxY: this.maxY,\n      meanX: this.meanX,\n      meanY: this.meanY,\n      height: this.height,\n      width: this.width,\n      surface: this.surface,\n      mbrWidth: this.mbr.width,\n      mbrHeight: this.mbr.height,\n      mbrSurface: this.mbr.surface,\n      eqpc: this.eqpc,\n      ped: this.ped,\n      feretDiameterMin: this.feretDiameters.min,\n      feretDiameterMax: this.feretDiameters.max,\n      aspectRatio: this.feretDiameters.aspectRatio,\n      sphericity: this.sphericity,\n      roundness: this.roundness,\n      convexity: this.convexity,\n      perimeter: this.perimeter\n    };\n  }\n\n} // TODO we should follow the region in order to increase the speed\n\nfunction getBorders(roi) {\n  let roiMap = roi.map;\n  let data = roiMap.data;\n  let surroudingIDs = new Set(); // allows to get a unique list without indexOf\n\n  let surroundingBorders = new Map();\n  let visitedData = new Set();\n  let dx = [+1, 0, -1, 0];\n  let dy = [0, +1, 0, -1];\n\n  for (let x = roi.minX; x <= roi.maxX; x++) {\n    for (let y = roi.minY; y <= roi.maxY; y++) {\n      let target = x + y * roiMap.width;\n\n      if (data[target] === roi.id) {\n        for (let dir = 0; dir < 4; dir++) {\n          let newX = x + dx[dir];\n          let newY = y + dy[dir];\n\n          if (newX >= 0 && newY >= 0 && newX < roiMap.width && newY < roiMap.height) {\n            let neighbour = newX + newY * roiMap.width;\n\n            if (data[neighbour] !== roi.id && !visitedData.has(neighbour)) {\n              visitedData.add(neighbour);\n              surroudingIDs.add(data[neighbour]);\n              let surroundingBorder = surroundingBorders.get(data[neighbour]);\n\n              if (!surroundingBorder) {\n                surroundingBorders.set(data[neighbour], 1);\n              } else {\n                surroundingBorders.set(data[neighbour], ++surroundingBorder);\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n\n  let ids = Array.from(surroudingIDs);\n  let borderLengths = ids.map(function (id) {\n    return surroundingBorders.get(id);\n  });\n  return {\n    ids: ids,\n    lengths: borderLengths\n  };\n}\n\nfunction getBoxIDs(roi) {\n  let surroundingIDs = new Set(); // allows to get a unique list without indexOf\n\n  let roiMap = roi.map;\n  let data = roiMap.data; // we check the first line and the last line\n\n  for (let y of [0, roi.height - 1]) {\n    for (let x = 0; x < roi.width; x++) {\n      let target = (y + roi.minY) * roiMap.width + x + roi.minX;\n\n      if (x - roi.minX > 0 && data[target] === roi.id && data[target - 1] !== roi.id) {\n        let value = data[target - 1];\n        surroundingIDs.add(value);\n      }\n\n      if (roiMap.width - x - roi.minX > 1 && data[target] === roi.id && data[target + 1] !== roi.id) {\n        let value = data[target + 1];\n        surroundingIDs.add(value);\n      }\n    }\n  } // we check the first column and the last column\n\n\n  for (let x of [0, roi.width - 1]) {\n    for (let y = 0; y < roi.height; y++) {\n      let target = (y + roi.minY) * roiMap.width + x + roi.minX;\n\n      if (y - roi.minY > 0 && data[target] === roi.id && data[target - roiMap.width] !== roi.id) {\n        let value = data[target - roiMap.width];\n        surroundingIDs.add(value);\n      }\n\n      if (roiMap.height - y - roi.minY > 1 && data[target] === roi.id && data[target + roiMap.width] !== roi.id) {\n        let value = data[target + roiMap.width];\n        surroundingIDs.add(value);\n      }\n    }\n  }\n\n  return Array.from(surroundingIDs); // the selection takes the whole rectangle\n}\n\nfunction getBox(roi) {\n  let total = 0;\n  let roiMap = roi.map;\n  let data = roiMap.data;\n  let topBottom = [0];\n\n  if (roi.height > 1) {\n    topBottom[1] = roi.height - 1;\n  }\n\n  for (let y of topBottom) {\n    for (let x = 1; x < roi.width - 1; x++) {\n      let target = (y + roi.minY) * roiMap.width + x + roi.minX;\n\n      if (data[target] === roi.id) {\n        total++;\n      }\n    }\n  }\n\n  let leftRight = [0];\n\n  if (roi.width > 1) {\n    leftRight[1] = roi.width - 1;\n  }\n\n  for (let x of leftRight) {\n    for (let y = 0; y < roi.height; y++) {\n      let target = (y + roi.minY) * roiMap.width + x + roi.minX;\n\n      if (data[target] === roi.id) {\n        total++;\n      }\n    }\n  }\n\n  return total;\n}\n\nfunction getBorder(roi) {\n  let total = 0;\n  let roiMap = roi.map;\n  let data = roiMap.data;\n\n  for (let x = 1; x < roi.width - 1; x++) {\n    for (let y = 1; y < roi.height - 1; y++) {\n      let target = (y + roi.minY) * roiMap.width + x + roi.minX;\n\n      if (data[target] === roi.id) {\n        // if a point around is not roi.id it is a border\n        if (data[target - 1] !== roi.id || data[target + 1] !== roi.id || data[target - roiMap.width] !== roi.id || data[target + roiMap.width] !== roi.id) {\n          total++;\n        }\n      }\n    }\n  }\n\n  return total + roi.box;\n}\n\nfunction getPerimeterInfo(roi) {\n  let roiMap = roi.map;\n  let data = roiMap.data;\n  let one = 0;\n  let two = 0;\n  let three = 0;\n  let four = 0;\n\n  for (let x = 0; x < roi.width; x++) {\n    for (let y = 0; y < roi.height; y++) {\n      let target = (y + roi.minY) * roiMap.width + x + roi.minX;\n\n      if (data[target] === roi.id) {\n        let nbAround = 0;\n\n        if (x === 0) {\n          nbAround++;\n        } else if (roi.externalIDs.includes(data[target - 1])) {\n          nbAround++;\n        }\n\n        if (x === roi.width - 1) {\n          nbAround++;\n        } else if (roi.externalIDs.includes(data[target + 1])) {\n          nbAround++;\n        }\n\n        if (y === 0) {\n          nbAround++;\n        } else if (roi.externalIDs.includes(data[target - roiMap.width])) {\n          nbAround++;\n        }\n\n        if (y === roi.height - 1) {\n          nbAround++;\n        } else if (roi.externalIDs.includes(data[target + roiMap.width])) {\n          nbAround++;\n        }\n\n        switch (nbAround) {\n          case 1:\n            one++;\n            break;\n\n          case 2:\n            two++;\n            break;\n\n          case 3:\n            three++;\n            break;\n\n          case 4:\n            four++;\n            break;\n\n          default:\n        }\n      }\n    }\n  }\n\n  return {\n    one,\n    two,\n    three,\n    four\n  };\n}\n\nfunction getExternal(roi) {\n  let total = 0;\n  let roiMap = roi.map;\n  let data = roiMap.data;\n\n  for (let x = 1; x < roi.width - 1; x++) {\n    for (let y = 1; y < roi.height - 1; y++) {\n      let target = (y + roi.minY) * roiMap.width + x + roi.minX;\n\n      if (data[target] === roi.id) {\n        // if a point around is not roi.id it is a border\n        if (roi.externalIDs.includes(data[target - 1]) || roi.externalIDs.includes(data[target + 1]) || roi.externalIDs.includes(data[target - roiMap.width]) || roi.externalIDs.includes(data[target + roiMap.width])) {\n          total++;\n        }\n      }\n    }\n  }\n\n  return total + roi.box;\n}\n/*\nWe will calculate all the ids of the map that are \"internal\"\nThis will allow to extract the 'plain' image\n */\n\n\nfunction getInternalIDs(roi) {\n  let internal = [roi.id];\n  let roiMap = roi.map;\n  let data = roiMap.data;\n\n  if (roi.height > 2) {\n    for (let x = 0; x < roi.width; x++) {\n      let target = roi.minY * roiMap.width + x + roi.minX;\n\n      if (internal.includes(data[target])) {\n        let id = data[target + roiMap.width];\n\n        if (!internal.includes(id) && !roi.boxIDs.includes(id)) {\n          internal.push(id);\n        }\n      }\n    }\n  }\n\n  let array = new Array(4);\n\n  for (let x = 1; x < roi.width - 1; x++) {\n    for (let y = 1; y < roi.height - 1; y++) {\n      let target = (y + roi.minY) * roiMap.width + x + roi.minX;\n\n      if (internal.includes(data[target])) {\n        // we check if one of the neighbour is not yet in\n        array[0] = data[target - 1];\n        array[1] = data[target + 1];\n        array[2] = data[target - roiMap.width];\n        array[3] = data[target + roiMap.width];\n\n        for (let i = 0; i < 4; i++) {\n          let id = array[i];\n\n          if (!internal.includes(id) && !roi.boxIDs.includes(id)) {\n            internal.push(id);\n          }\n        }\n      }\n    }\n  }\n\n  return internal;\n}","map":{"version":3,"sources":["C:/Users/kuent/Documents/FinishDipshit/Creative/Ocean-Weather-Visualization/node_modules/image-js/src/image/roi/Roi.js"],"names":["mcch","Shape","round","minMax","minMaxFct","moveToZeroZero","perimeter","surface","Image","minimalBoundingRectangle","KindNames","feretDiameters","Roi","constructor","map","id","minX","Number","POSITIVE_INFINITY","maxX","NEGATIVE_INFINITY","minY","maxY","meanX","meanY","computed","getMask","options","scale","kind","mask","contourMask","boxMask","filledMask","centerMask","convexHullMask","mbrMask","feretMask","resize","factor","parent","position","mean","Error","center","width","height","ratio","_computExternalIDs","borders","borderIDs","lengths","borderLengths","externalIDs","externalLengths","internals","internalIDs","i","length","includes","push","_computeBorderIDs","getBorders","ids","boxIDs","getBoxIDs","getInternalIDs","box","getBox","external","getExternal","border","getBorder","img","BINARY","x","y","data","setBitXY","target","convexHull","calculationPoints","polyline","paintPolyline","closed","mbr","originalPoints","rectangle","first","second","third","Math","sqrt","elongation","aspectRatio","eqpc","PI","perimeterInfo","getPerimeterInfo","info","delta","one","two","three","four","ped","image","minLine","maxLine","points","maxLengthPoints","maxLength","j","currentML","pow","roundness","max","sphericity","convexity","angle","atan2","toJSON","mbrWidth","mbrHeight","mbrSurface","feretDiameterMin","min","feretDiameterMax","roi","roiMap","surroudingIDs","Set","surroundingBorders","Map","visitedData","dx","dy","dir","newX","newY","neighbour","has","add","surroundingBorder","get","set","Array","from","surroundingIDs","value","total","topBottom","leftRight","nbAround","internal","array"],"mappings":"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","sourcesContent":["import mcch from 'monotone-chain-convex-hull';\n\nimport Shape from '../../util/Shape';\nimport {\n  round,\n  minMax as minMaxFct,\n  moveToZeroZero,\n  perimeter,\n  surface,\n} from '../../util/points';\nimport Image from '../Image';\nimport minimalBoundingRectangle from '../compute/minimalBoundingRectangle';\nimport * as KindNames from '../core/kindNames';\n\nimport feretDiameters from './feretDiameters';\n\n// Many measurements:\n// https://www.sympatec.com/en/particle-measurement/glossary/particle-shape/#\n\n/**\n * Class to manage Region Of Interests\n * @class Roi\n */\nexport default class Roi {\n  constructor(map, id) {\n    this.map = map;\n    this.id = id;\n    this.minX = Number.POSITIVE_INFINITY;\n    this.maxX = Number.NEGATIVE_INFINITY;\n    this.minY = Number.POSITIVE_INFINITY;\n    this.maxY = Number.NEGATIVE_INFINITY;\n    this.meanX = 0;\n    this.meanY = 0;\n    this.surface = 0;\n    this.computed = {};\n  }\n\n  /**\n   * Returns a binary image (mask) for the corresponding ROI\n   * @param {object} [options]\n   * @param {number} [options.scale=1] - Scaling factor to apply to the mask\n   * @param {string} [options.kind='normal'] - 'contour', 'box', 'filled', 'center', 'hull' or 'normal'\n   * @return {Image} - Returns a mask (1 bit Image)\n   */\n  getMask(options = {}) {\n    const { scale = 1, kind = '' } = options;\n    let mask;\n    switch (kind) {\n      case 'contour':\n        mask = this.contourMask;\n        break;\n      case 'box':\n        mask = this.boxMask;\n        break;\n      case 'filled':\n        mask = this.filledMask;\n        break;\n      case 'center':\n        mask = this.centerMask;\n        break;\n      case 'hull':\n        mask = this.convexHullMask;\n        break;\n      case 'mbr':\n        mask = this.mbrMask;\n        break;\n      case 'feret':\n        mask = this.feretMask;\n        break;\n      default:\n        mask = this.mask;\n    }\n\n    if (scale < 1) {\n      // by reassigning the mask we loose the parent and therefore the position\n      // we will have to force it back\n      mask = mask.resize({ factor: scale });\n      mask.parent = this.mask.parent;\n      mask.position[0] += this.minX;\n      mask.position[1] += this.minY;\n    }\n\n    return mask;\n  }\n\n  get mean() {\n    throw new Error('Roi mean not implemented yet');\n    // return [this.meanX,this.meanY];\n  }\n\n  get center() {\n    if (!this.computed.center) {\n      this.computed.center = [(this.width / 2) >> 0, (this.height / 2) >> 0];\n    }\n    return this.computed.center;\n  }\n\n  get ratio() {\n    return this.width / this.height;\n  }\n\n  get width() {\n    return this.maxX - this.minX + 1;\n  }\n\n  get height() {\n    return this.maxY - this.minY + 1;\n  }\n\n  _computExternalIDs() {\n    // take all the borders and remove the internal one ...\n    let borders = this.borderIDs;\n    let lengths = this.borderLengths;\n\n    this.computed.externalIDs = [];\n    this.computed.externalLengths = [];\n\n    let internals = this.internalIDs;\n\n    for (let i = 0; i < borders.length; i++) {\n      if (!internals.includes(borders[i])) {\n        this.computed.externalIDs.push(borders[i]);\n        this.computed.externalLengths.push(lengths[i]);\n      }\n    }\n  }\n\n  get externalIDs() {\n    if (this.computed.externalIDs) {\n      return this.computed.externalIDs;\n    }\n    this._computExternalIDs();\n    return this.computed.externalIDs;\n  }\n\n  get externalLengths() {\n    if (this.computed.externalLengths) {\n      return this.computed.externalLengths;\n    }\n    this._computExternalIDs();\n    return this.computed.externalLengths;\n  }\n\n  _computeBorderIDs() {\n    let borders = getBorders(this);\n    this.computed.borderIDs = borders.ids;\n    this.computed.borderLengths = borders.lengths;\n  }\n\n  /**\n     Retrieve all the IDs (array of number) of the regions that are in contact with this\n     specific region. It may be external or internal\n     */\n  get borderIDs() {\n    if (this.computed.borderIDs) {\n      return this.computed.borderIDs;\n    }\n    this._computeBorderIDs();\n    return this.computed.borderIDs;\n  }\n\n  /**\n     Retrieve all the length (array of number) of the contacts with this\n     specific region. It may be external or internal\n     */\n  get borderLengths() {\n    if (this.computed.borderLengths) {\n      return this.computed.borderLengths;\n    }\n    this._computeBorderIDs();\n    return this.computed.borderLengths;\n  }\n\n  /**\n     Retrieve all the IDs or the Roi touching the box surrouding the region\n\n     It should really be an array to solve complex cases related to border effect\n\n     Like the image\n     <pre>\n     0000\n     1111\n     0000\n     1111\n     </pre>\n\n     The first row of 1 will be surrouned by 2 differents zones\n\n     Or even worse\n     <pre>\n     010\n     111\n     010\n     </pre>\n     The cross will be surrouned by 4 differents zones\n\n     However in most of the cases it will be an array of one element\n     */\n  get boxIDs() {\n    if (!this.computed.boxIDs) {\n      this.computed.boxIDs = getBoxIDs(this);\n    }\n    return this.computed.boxIDs;\n  }\n\n  get internalIDs() {\n    if (!this.computed.internalIDs) {\n      this.computed.internalIDs = getInternalIDs(this);\n    }\n    return this.computed.internalIDs;\n  }\n\n  /**\n     Number of pixels of the Roi that touch the rectangle\n     This is useful for the calculation of the border\n     because we will ignore those special pixels of the rectangle\n     border that don't have neighbours all around them.\n     */\n  get box() {\n    // points of the Roi that touch the rectangular shape\n    if (!this.computed.box) {\n      this.computed.box = getBox(this);\n    }\n    return this.computed.box;\n  }\n\n  /**\n     Calculates the number of pixels that are in the external border of the Roi\n     Contour are all the pixels that touch an external \"zone\".\n     All the pixels that touch the box are part of the border and\n     are calculated in the getBoxPixels procedure\n     */\n  get external() {\n    if (!this.computed.external) {\n      this.computed.external = getExternal(this);\n    }\n    return this.computed.external;\n  }\n\n  /**\n     Calculates the number of pixels that are involved in border\n     Border are all the pixels that touch another \"zone\". It could be external\n     or internal. If there is a hole in the zone it will be counted as a border.\n     All the pixels that touch the box are part of the border and\n     are calculated in the getBoxPixels procedure\n     */\n  get border() {\n    if (!this.computed.border) {\n      this.computed.border = getBorder(this);\n    }\n    return this.computed.border;\n  }\n\n  /**\n    Returns a binary image (mask) containing only the border of the mask\n  */\n  get contourMask() {\n    if (!this.computed.contourMask) {\n      let img = new Image(this.width, this.height, {\n        kind: KindNames.BINARY,\n        position: [this.minX, this.minY],\n        parent: this.map.parent,\n      });\n\n      for (let x = 0; x < this.width; x++) {\n        for (let y = 0; y < this.height; y++) {\n          if (\n            this.map.data[x + this.minX + (y + this.minY) * this.map.width] ===\n            this.id\n          ) {\n            // it also has to be on a border ...\n            if (x > 0 && x < this.width - 1 && y > 0 && y < this.height - 1) {\n              if (\n                this.map.data[\n                  x - 1 + this.minX + (y + this.minY) * this.map.width\n                ] !== this.id ||\n                this.map.data[\n                  x + 1 + this.minX + (y + this.minY) * this.map.width\n                ] !== this.id ||\n                this.map.data[\n                  x + this.minX + (y - 1 + this.minY) * this.map.width\n                ] !== this.id ||\n                this.map.data[\n                  x + this.minX + (y + 1 + this.minY) * this.map.width\n                ] !== this.id\n              ) {\n                img.setBitXY(x, y);\n              }\n            } else {\n              img.setBitXY(x, y);\n            }\n          }\n        }\n      }\n      this.computed.contourMask = img;\n    }\n    return this.computed.contourMask;\n  }\n\n  get boxMask() {\n    if (!this.computed.boxMask) {\n      let img = new Image(this.width, this.height, {\n        kind: KindNames.BINARY,\n        position: [this.minX, this.minY],\n        parent: this.map.parent,\n      });\n\n      for (let x = 0; x < this.width; x++) {\n        img.setBitXY(x, 0);\n        img.setBitXY(x, this.height - 1);\n      }\n      for (let y = 0; y < this.height; y++) {\n        img.setBitXY(0, y);\n        img.setBitXY(this.width - 1, y);\n      }\n      this.computed.boxMask = img;\n    }\n    return this.computed.boxMask;\n  }\n\n  /**\n     Returns a binary image containing the mask\n     */\n  get mask() {\n    if (!this.computed.mask) {\n      let img = new Image(this.width, this.height, {\n        kind: KindNames.BINARY,\n        position: [this.minX, this.minY],\n        parent: this.map.parent,\n      });\n\n      for (let x = 0; x < this.width; x++) {\n        for (let y = 0; y < this.height; y++) {\n          if (\n            this.map.data[x + this.minX + (y + this.minY) * this.map.width] ===\n            this.id\n          ) {\n            img.setBitXY(x, y);\n          }\n        }\n      }\n      this.computed.mask = img;\n    }\n    return this.computed.mask;\n  }\n\n  get filledMask() {\n    if (!this.computed.filledMask) {\n      let img = new Image(this.width, this.height, {\n        kind: KindNames.BINARY,\n        position: [this.minX, this.minY],\n        parent: this.map.parent,\n      });\n\n      for (let x = 0; x < this.width; x++) {\n        for (let y = 0; y < this.height; y++) {\n          let target = x + this.minX + (y + this.minY) * this.map.width;\n          if (this.internalIDs.includes(this.map.data[target])) {\n            img.setBitXY(x, y);\n          } // by default a pixel is to 0 so no problems, it will be transparent\n        }\n      }\n      this.computed.filledMask = img;\n    }\n    return this.computed.filledMask;\n  }\n\n  get centerMask() {\n    if (!this.computed.centerMask) {\n      let img = new Shape({ kind: 'smallCross' }).getMask();\n\n      img.parent = this.map.parent;\n      img.position = [\n        this.minX + this.center[0] - 1,\n        this.minY + this.center[1] - 1,\n      ];\n\n      this.computed.centerMask = img;\n    }\n    return this.computed.centerMask;\n  }\n\n  get convexHull() {\n    if (!this.computed.convexHull) {\n      const calculationPoints = [];\n      // slow approach, we check all the points\n      // for each point we take the 4 corners !!!!\n\n      for (let x = 0; x < this.width; x++) {\n        for (let y = 0; y < this.height; y++) {\n          if (\n            this.map.data[x + this.minX + (y + this.minY) * this.map.width] ===\n            this.id\n          ) {\n            // it also has to be on a border ...\n            if (x > 0 && x < this.width - 1 && y > 0 && y < this.height - 1) {\n              if (\n                this.map.data[\n                  x - 1 + this.minX + (y + this.minY) * this.map.width\n                ] !== this.id ||\n                this.map.data[\n                  x + 1 + this.minX + (y + this.minY) * this.map.width\n                ] !== this.id ||\n                this.map.data[\n                  x + this.minX + (y - 1 + this.minY) * this.map.width\n                ] !== this.id ||\n                this.map.data[\n                  x + this.minX + (y + 1 + this.minY) * this.map.width\n                ] !== this.id\n              ) {\n                calculationPoints.push([x, y]);\n                calculationPoints.push([x + 1, y]);\n                calculationPoints.push([x, y + 1]);\n                calculationPoints.push([x + 1, y + 1]);\n              }\n            } else {\n              calculationPoints.push([x, y]);\n              calculationPoints.push([x + 1, y]);\n              calculationPoints.push([x, y + 1]);\n              calculationPoints.push([x + 1, y + 1]);\n            }\n          }\n        }\n      }\n\n      const convexHull = mcch(calculationPoints);\n\n      this.computed.convexHull = {\n        polyline: convexHull,\n        surface: surface(convexHull),\n        perimeter: perimeter(convexHull),\n      };\n    }\n    return this.computed.convexHull;\n  }\n\n  get convexHullMask() {\n    if (!this.computed.convexHullMask) {\n      const convexHull = this.convexHull;\n      const img = new Image(this.width + 1, this.height + 1, {\n        kind: KindNames.BINARY,\n        position: [this.minX, this.minY],\n        parent: this.map.parent,\n      });\n      img.paintPolyline(convexHull.polyline, { closed: true });\n      this.computed.convexHullMask = img;\n    }\n    return this.computed.convexHullMask;\n  }\n\n  get mbr() {\n    if (!this.computed.mbr) {\n      let mbr = minimalBoundingRectangle({\n        originalPoints: this.convexHull.polyline,\n      });\n      if (mbr.length === 0) {\n        this.computed.mbr = {\n          width: 0,\n          height: 0,\n          surface: 0,\n          perimeter: 0,\n          rectangle: mbr,\n        };\n      } else {\n        let first = mbr[0];\n        let second = mbr[1];\n        let third = mbr[2];\n        let width = Math.sqrt(\n          (first[0] - second[0]) ** 2 + (first[1] - second[1]) ** 2,\n        );\n        let height = Math.sqrt(\n          (third[0] - second[0]) ** 2 + (third[1] - second[1]) ** 2,\n        );\n        this.computed.mbr = {\n          width,\n          height,\n          elongation: 1 - width / height,\n          aspectRatio: width / height,\n          surface: width * height,\n          perimeter: (width + height) * 2,\n          rectangle: mbr,\n        };\n      }\n    }\n    return this.computed.mbr;\n  }\n\n  get feretDiameters() {\n    if (!this.computed.feretDiameters) {\n      this.computed.feretDiameters = feretDiameters({\n        originalPoints: this.convexHull.polyline,\n      });\n    }\n    return this.computed.feretDiameters;\n  }\n\n  /**\n   * Diameter of a circle of equal projection area\n   */\n  get eqpc() {\n    if (!this.computed.eqpc) {\n      this.computed.eqpc = 2 * Math.sqrt(this.surface / Math.PI);\n    }\n    return this.computed.eqpc;\n  }\n\n  /**\n   * Get the category in which each external pixel belongs\n   */\n  get perimeterInfo() {\n    if (!this.computed.perimeterInfo) {\n      this.computed.perimeterInfo = getPerimeterInfo(this);\n    }\n    return this.computed.perimeterInfo;\n  }\n\n  /**\n   * Return the perimeter of the ROI\n   */\n  get perimeter() {\n    let info = this.perimeterInfo;\n    let delta = 2 - Math.sqrt(2);\n    return (\n      info.one +\n      info.two * 2 +\n      info.three * 3 +\n      info.four * 4 -\n      delta * (info.two + info.three * 2 + info.four)\n    );\n  }\n\n  /**\n   * Diameter of a circle of equal perimeter\n   */\n  get ped() {\n    if (!this.computed.ped) {\n      this.computed.ped = this.perimeter / Math.PI;\n    }\n    return this.computed.ped;\n  }\n\n  get feretMask() {\n    if (!this.computed.feretMask) {\n      const image = new Image(this.width + 1, this.height + 1, {\n        kind: KindNames.BINARY,\n        position: [this.minX, this.minY],\n        parent: this.map.parent,\n      });\n\n      image.paintPolyline(this.feretDiameters.minLine);\n      image.paintPolyline(this.feretDiameters.maxLine);\n      this.computed.feretMask = image;\n    }\n    return this.computed.feretMask;\n  }\n\n  get mbrMask() {\n    if (!this.computed.mbrMask) {\n      let rectangle = round(this.mbr.rectangle);\n      if (rectangle.length > 0) {\n        // the problem is that the rectangle may be outside the roi\n        const minMax = minMaxFct(rectangle);\n\n        const img = new Image(\n          minMax[1][0] - minMax[0][0] + 1,\n          minMax[1][1] - minMax[0][1] + 1,\n          {\n            kind: KindNames.BINARY,\n            position: [this.minX + minMax[0][0], this.minY + minMax[0][1]],\n            parent: this.map.parent,\n          },\n        );\n\n        rectangle = moveToZeroZero(rectangle);\n\n        img.paintPolyline(rectangle, { closed: true });\n        this.computed.mbrMask = img;\n      } else {\n        this.computed.mbrMask = new Image(1, 1, {\n          kind: KindNames.BINARY,\n          position: [this.minX, this.minY],\n          parent: this.map.parent,\n        });\n      }\n    }\n    return this.computed.mbrMask;\n  }\n\n  get points() {\n    if (!this.computed.points) {\n      let points = [];\n      for (let y = 0; y < this.height; y++) {\n        for (let x = 0; x < this.width; x++) {\n          let target = (y + this.minY) * this.map.width + x + this.minX;\n          if (this.map.data[target] === this.id) {\n            points.push([x, y]);\n          }\n        }\n      }\n      this.computed.points = points;\n    }\n    return this.computed.points;\n  }\n\n  get maxLengthPoints() {\n    if (!this.computed.maxLengthPoints) {\n      let maxLength = 0;\n      let maxLengthPoints;\n      const points = this.points;\n\n      for (let i = 0; i < points.length; i++) {\n        for (let j = i + 1; j < points.length; j++) {\n          let currentML =\n            Math.pow(points[i][0] - points[j][0], 2) +\n            Math.pow(points[i][1] - points[j][1], 2);\n          if (currentML >= maxLength) {\n            maxLength = currentML;\n            maxLengthPoints = [points[i], points[j]];\n          }\n        }\n      }\n      this.computed.maxLengthPoints = maxLengthPoints;\n    }\n    return this.computed.maxLengthPoints;\n  }\n\n  /**\n        Calculates the maximum length between two pixels of the Roi.\n     */\n  get maxLength() {\n    if (!this.computed.maxLength) {\n      let maxLength = Math.sqrt(\n        Math.pow(this.maxLengthPoints[0][0] - this.maxLengthPoints[1][0], 2) +\n          Math.pow(this.maxLengthPoints[0][1] - this.maxLengthPoints[1][1], 2),\n      );\n      this.computed.maxLength = maxLength;\n    }\n    return this.computed.maxLength;\n  }\n\n  get roundness() {\n    /*Slide 24 https://static.horiba.com/fileadmin/Horiba/Products/Scientific/Particle_Characterization/Webinars/Slides/TE011.pdf */\n    return (4 * this.surface) / (Math.PI * this.feretDiameters.max) ** 2;\n  }\n\n  get sphericity() {\n    return (2 * Math.sqrt(this.surface * Math.PI)) / this.perimeter;\n  }\n\n  get convexity() {\n    return this.surface / this.convexHull.surface;\n  }\n\n  get angle() {\n    if (!this.computed.angle) {\n      let points = this.maxLengthPoints;\n      let angle =\n        (-Math.atan2(points[0][1] - points[1][1], points[0][0] - points[1][0]) *\n          180) /\n        Math.PI;\n\n      this.computed.angle = angle;\n    }\n    return this.computed.angle;\n  }\n\n  toJSON() {\n    return {\n      id: this.id,\n      minX: this.minX,\n      maxX: this.maxX,\n      minY: this.minY,\n      maxY: this.maxY,\n      meanX: this.meanX,\n      meanY: this.meanY,\n      height: this.height,\n      width: this.width,\n      surface: this.surface,\n      mbrWidth: this.mbr.width,\n      mbrHeight: this.mbr.height,\n      mbrSurface: this.mbr.surface,\n      eqpc: this.eqpc,\n      ped: this.ped,\n      feretDiameterMin: this.feretDiameters.min,\n      feretDiameterMax: this.feretDiameters.max,\n      aspectRatio: this.feretDiameters.aspectRatio,\n      sphericity: this.sphericity,\n      roundness: this.roundness,\n      convexity: this.convexity,\n      perimeter: this.perimeter,\n    };\n  }\n}\n\n// TODO we should follow the region in order to increase the speed\n\nfunction getBorders(roi) {\n  let roiMap = roi.map;\n  let data = roiMap.data;\n  let surroudingIDs = new Set(); // allows to get a unique list without indexOf\n  let surroundingBorders = new Map();\n  let visitedData = new Set();\n  let dx = [+1, 0, -1, 0];\n  let dy = [0, +1, 0, -1];\n\n  for (let x = roi.minX; x <= roi.maxX; x++) {\n    for (let y = roi.minY; y <= roi.maxY; y++) {\n      let target = x + y * roiMap.width;\n      if (data[target] === roi.id) {\n        for (let dir = 0; dir < 4; dir++) {\n          let newX = x + dx[dir];\n          let newY = y + dy[dir];\n          if (\n            newX >= 0 &&\n            newY >= 0 &&\n            newX < roiMap.width &&\n            newY < roiMap.height\n          ) {\n            let neighbour = newX + newY * roiMap.width;\n\n            if (data[neighbour] !== roi.id && !visitedData.has(neighbour)) {\n              visitedData.add(neighbour);\n              surroudingIDs.add(data[neighbour]);\n              let surroundingBorder = surroundingBorders.get(data[neighbour]);\n              if (!surroundingBorder) {\n                surroundingBorders.set(data[neighbour], 1);\n              } else {\n                surroundingBorders.set(data[neighbour], ++surroundingBorder);\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n  let ids = Array.from(surroudingIDs);\n  let borderLengths = ids.map(function (id) {\n    return surroundingBorders.get(id);\n  });\n  return {\n    ids: ids,\n    lengths: borderLengths,\n  };\n}\n\nfunction getBoxIDs(roi) {\n  let surroundingIDs = new Set(); // allows to get a unique list without indexOf\n\n  let roiMap = roi.map;\n  let data = roiMap.data;\n\n  // we check the first line and the last line\n  for (let y of [0, roi.height - 1]) {\n    for (let x = 0; x < roi.width; x++) {\n      let target = (y + roi.minY) * roiMap.width + x + roi.minX;\n      if (\n        x - roi.minX > 0 &&\n        data[target] === roi.id &&\n        data[target - 1] !== roi.id\n      ) {\n        let value = data[target - 1];\n        surroundingIDs.add(value);\n      }\n      if (\n        roiMap.width - x - roi.minX > 1 &&\n        data[target] === roi.id &&\n        data[target + 1] !== roi.id\n      ) {\n        let value = data[target + 1];\n        surroundingIDs.add(value);\n      }\n    }\n  }\n\n  // we check the first column and the last column\n  for (let x of [0, roi.width - 1]) {\n    for (let y = 0; y < roi.height; y++) {\n      let target = (y + roi.minY) * roiMap.width + x + roi.minX;\n      if (\n        y - roi.minY > 0 &&\n        data[target] === roi.id &&\n        data[target - roiMap.width] !== roi.id\n      ) {\n        let value = data[target - roiMap.width];\n        surroundingIDs.add(value);\n      }\n      if (\n        roiMap.height - y - roi.minY > 1 &&\n        data[target] === roi.id &&\n        data[target + roiMap.width] !== roi.id\n      ) {\n        let value = data[target + roiMap.width];\n        surroundingIDs.add(value);\n      }\n    }\n  }\n\n  return Array.from(surroundingIDs); // the selection takes the whole rectangle\n}\n\nfunction getBox(roi) {\n  let total = 0;\n  let roiMap = roi.map;\n  let data = roiMap.data;\n\n  let topBottom = [0];\n  if (roi.height > 1) {\n    topBottom[1] = roi.height - 1;\n  }\n  for (let y of topBottom) {\n    for (let x = 1; x < roi.width - 1; x++) {\n      let target = (y + roi.minY) * roiMap.width + x + roi.minX;\n      if (data[target] === roi.id) {\n        total++;\n      }\n    }\n  }\n\n  let leftRight = [0];\n  if (roi.width > 1) {\n    leftRight[1] = roi.width - 1;\n  }\n  for (let x of leftRight) {\n    for (let y = 0; y < roi.height; y++) {\n      let target = (y + roi.minY) * roiMap.width + x + roi.minX;\n      if (data[target] === roi.id) {\n        total++;\n      }\n    }\n  }\n  return total;\n}\n\nfunction getBorder(roi) {\n  let total = 0;\n  let roiMap = roi.map;\n  let data = roiMap.data;\n\n  for (let x = 1; x < roi.width - 1; x++) {\n    for (let y = 1; y < roi.height - 1; y++) {\n      let target = (y + roi.minY) * roiMap.width + x + roi.minX;\n      if (data[target] === roi.id) {\n        // if a point around is not roi.id it is a border\n        if (\n          data[target - 1] !== roi.id ||\n          data[target + 1] !== roi.id ||\n          data[target - roiMap.width] !== roi.id ||\n          data[target + roiMap.width] !== roi.id\n        ) {\n          total++;\n        }\n      }\n    }\n  }\n  return total + roi.box;\n}\n\nfunction getPerimeterInfo(roi) {\n  let roiMap = roi.map;\n  let data = roiMap.data;\n  let one = 0;\n  let two = 0;\n  let three = 0;\n  let four = 0;\n\n  for (let x = 0; x < roi.width; x++) {\n    for (let y = 0; y < roi.height; y++) {\n      let target = (y + roi.minY) * roiMap.width + x + roi.minX;\n      if (data[target] === roi.id) {\n        let nbAround = 0;\n        if (x === 0) {\n          nbAround++;\n        } else if (roi.externalIDs.includes(data[target - 1])) {\n          nbAround++;\n        }\n\n        if (x === roi.width - 1) {\n          nbAround++;\n        } else if (roi.externalIDs.includes(data[target + 1])) {\n          nbAround++;\n        }\n\n        if (y === 0) {\n          nbAround++;\n        } else if (roi.externalIDs.includes(data[target - roiMap.width])) {\n          nbAround++;\n        }\n\n        if (y === roi.height - 1) {\n          nbAround++;\n        } else if (roi.externalIDs.includes(data[target + roiMap.width])) {\n          nbAround++;\n        }\n        switch (nbAround) {\n          case 1:\n            one++;\n            break;\n          case 2:\n            two++;\n            break;\n          case 3:\n            three++;\n            break;\n          case 4:\n            four++;\n            break;\n          default:\n        }\n      }\n    }\n  }\n  return { one, two, three, four };\n}\n\nfunction getExternal(roi) {\n  let total = 0;\n  let roiMap = roi.map;\n  let data = roiMap.data;\n\n  for (let x = 1; x < roi.width - 1; x++) {\n    for (let y = 1; y < roi.height - 1; y++) {\n      let target = (y + roi.minY) * roiMap.width + x + roi.minX;\n      if (data[target] === roi.id) {\n        // if a point around is not roi.id it is a border\n        if (\n          roi.externalIDs.includes(data[target - 1]) ||\n          roi.externalIDs.includes(data[target + 1]) ||\n          roi.externalIDs.includes(data[target - roiMap.width]) ||\n          roi.externalIDs.includes(data[target + roiMap.width])\n        ) {\n          total++;\n        }\n      }\n    }\n  }\n  return total + roi.box;\n}\n\n/*\nWe will calculate all the ids of the map that are \"internal\"\nThis will allow to extract the 'plain' image\n */\nfunction getInternalIDs(roi) {\n  let internal = [roi.id];\n  let roiMap = roi.map;\n  let data = roiMap.data;\n\n  if (roi.height > 2) {\n    for (let x = 0; x < roi.width; x++) {\n      let target = roi.minY * roiMap.width + x + roi.minX;\n      if (internal.includes(data[target])) {\n        let id = data[target + roiMap.width];\n        if (!internal.includes(id) && !roi.boxIDs.includes(id)) {\n          internal.push(id);\n        }\n      }\n    }\n  }\n\n  let array = new Array(4);\n  for (let x = 1; x < roi.width - 1; x++) {\n    for (let y = 1; y < roi.height - 1; y++) {\n      let target = (y + roi.minY) * roiMap.width + x + roi.minX;\n      if (internal.includes(data[target])) {\n        // we check if one of the neighbour is not yet in\n\n        array[0] = data[target - 1];\n        array[1] = data[target + 1];\n        array[2] = data[target - roiMap.width];\n        array[3] = data[target + roiMap.width];\n\n        for (let i = 0; i < 4; i++) {\n          let id = array[i];\n          if (!internal.includes(id) && !roi.boxIDs.includes(id)) {\n            internal.push(id);\n          }\n        }\n      }\n    }\n  }\n\n  return internal;\n}\n"]},"metadata":{},"sourceType":"module"}