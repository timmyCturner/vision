{"ast":null,"code":"import { validateArrayOfChannels } from '../../util/channel';\nimport { checkNumberArray } from '../../util/value';\n/**\n * Add a specific integer on the specified points of the specified channels\n * @memberof Image\n * @instance\n * @param {*} value\n * @param {object} [options]\n * @return {this} Modified current image\n */\n\nexport default function add(value, options = {}) {\n  let {\n    channels\n  } = options;\n  this.checkProcessable('add', {\n    bitDepth: [8, 16]\n  });\n  channels = validateArrayOfChannels(this, {\n    channels: channels\n  });\n  value = checkNumberArray(value); // we allow 3 cases, the value may be an array (1D), an image or a single value\n\n  if (!isNaN(value)) {\n    for (let j = 0; j < channels.length; j++) {\n      let c = channels[j];\n\n      for (let i = 0; i < this.data.length; i += this.channels) {\n        this.data[i + c] = Math.min(this.maxValue, this.data[i + c] + value >> 0);\n      }\n    }\n  } else {\n    if (this.data.length !== value.length) {\n      throw new Error('add: the data size is different');\n    }\n\n    for (let j = 0; j < channels.length; j++) {\n      let c = channels[j];\n\n      for (let i = 0; i < this.data.length; i += this.channels) {\n        this.data[i + c] = Math.max(0, Math.min(this.maxValue, this.data[i + c] + value[i + c] >> 0));\n      }\n    }\n  }\n\n  return this;\n}","map":{"version":3,"sources":["C:/Users/kuent/Documents/FinishDipshit/Creative/Ocean-Weather-Visualization/node_modules/image-js/src/image/filter/add.js"],"names":["validateArrayOfChannels","checkNumberArray","add","value","options","channels","checkProcessable","bitDepth","isNaN","j","length","c","i","data","Math","min","maxValue","Error","max"],"mappings":"AAAA,SAASA,uBAAT,QAAwC,oBAAxC;AACA,SAASC,gBAAT,QAAiC,kBAAjC;AAEA;;;;;;;;;AAQA,eAAe,SAASC,GAAT,CAAaC,KAAb,EAAoBC,OAAO,GAAG,EAA9B,EAAkC;AAC/C,MAAI;AAAEC,IAAAA;AAAF,MAAeD,OAAnB;AACA,OAAKE,gBAAL,CAAsB,KAAtB,EAA6B;AAC3BC,IAAAA,QAAQ,EAAE,CAAC,CAAD,EAAI,EAAJ;AADiB,GAA7B;AAIAF,EAAAA,QAAQ,GAAGL,uBAAuB,CAAC,IAAD,EAAO;AAAEK,IAAAA,QAAQ,EAAEA;AAAZ,GAAP,CAAlC;AACAF,EAAAA,KAAK,GAAGF,gBAAgB,CAACE,KAAD,CAAxB,CAP+C,CAS/C;;AACA,MAAI,CAACK,KAAK,CAACL,KAAD,CAAV,EAAmB;AACjB,SAAK,IAAIM,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGJ,QAAQ,CAACK,MAA7B,EAAqCD,CAAC,EAAtC,EAA0C;AACxC,UAAIE,CAAC,GAAGN,QAAQ,CAACI,CAAD,CAAhB;;AACA,WAAK,IAAIG,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG,KAAKC,IAAL,CAAUH,MAA9B,EAAsCE,CAAC,IAAI,KAAKP,QAAhD,EAA0D;AACxD,aAAKQ,IAAL,CAAUD,CAAC,GAAGD,CAAd,IAAmBG,IAAI,CAACC,GAAL,CACjB,KAAKC,QADY,EAEhB,KAAKH,IAAL,CAAUD,CAAC,GAAGD,CAAd,IAAmBR,KAApB,IAA8B,CAFb,CAAnB;AAID;AACF;AACF,GAVD,MAUO;AACL,QAAI,KAAKU,IAAL,CAAUH,MAAV,KAAqBP,KAAK,CAACO,MAA/B,EAAuC;AACrC,YAAM,IAAIO,KAAJ,CAAU,iCAAV,CAAN;AACD;;AACD,SAAK,IAAIR,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGJ,QAAQ,CAACK,MAA7B,EAAqCD,CAAC,EAAtC,EAA0C;AACxC,UAAIE,CAAC,GAAGN,QAAQ,CAACI,CAAD,CAAhB;;AACA,WAAK,IAAIG,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG,KAAKC,IAAL,CAAUH,MAA9B,EAAsCE,CAAC,IAAI,KAAKP,QAAhD,EAA0D;AACxD,aAAKQ,IAAL,CAAUD,CAAC,GAAGD,CAAd,IAAmBG,IAAI,CAACI,GAAL,CACjB,CADiB,EAEjBJ,IAAI,CAACC,GAAL,CAAS,KAAKC,QAAd,EAAyB,KAAKH,IAAL,CAAUD,CAAC,GAAGD,CAAd,IAAmBR,KAAK,CAACS,CAAC,GAAGD,CAAL,CAAzB,IAAqC,CAA7D,CAFiB,CAAnB;AAID;AACF;AACF;;AAED,SAAO,IAAP;AACD","sourcesContent":["import { validateArrayOfChannels } from '../../util/channel';\nimport { checkNumberArray } from '../../util/value';\n\n/**\n * Add a specific integer on the specified points of the specified channels\n * @memberof Image\n * @instance\n * @param {*} value\n * @param {object} [options]\n * @return {this} Modified current image\n */\nexport default function add(value, options = {}) {\n  let { channels } = options;\n  this.checkProcessable('add', {\n    bitDepth: [8, 16],\n  });\n\n  channels = validateArrayOfChannels(this, { channels: channels });\n  value = checkNumberArray(value);\n\n  // we allow 3 cases, the value may be an array (1D), an image or a single value\n  if (!isNaN(value)) {\n    for (let j = 0; j < channels.length; j++) {\n      let c = channels[j];\n      for (let i = 0; i < this.data.length; i += this.channels) {\n        this.data[i + c] = Math.min(\n          this.maxValue,\n          (this.data[i + c] + value) >> 0,\n        );\n      }\n    }\n  } else {\n    if (this.data.length !== value.length) {\n      throw new Error('add: the data size is different');\n    }\n    for (let j = 0; j < channels.length; j++) {\n      let c = channels[j];\n      for (let i = 0; i < this.data.length; i += this.channels) {\n        this.data[i + c] = Math.max(\n          0,\n          Math.min(this.maxValue, (this.data[i + c] + value[i + c]) >> 0),\n        );\n      }\n    }\n  }\n\n  return this;\n}\n"]},"metadata":{},"sourceType":"module"}