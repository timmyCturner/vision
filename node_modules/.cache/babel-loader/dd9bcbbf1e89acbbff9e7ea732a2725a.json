{"ast":null,"code":"import newArray from 'new-array';\n/**\n * @memberof Image\n * @instance\n * @param {object} [options]\n * @param {boolean} [options.useAlpha=true]\n * @param {number} [options.nbSlots=512]\n * @return {number[]}\n */\n\nexport default function getColorHistogram(options = {}) {\n  let {\n    useAlpha = true,\n    nbSlots = 512\n  } = options;\n  this.checkProcessable('getColorHistogram', {\n    bitDepth: [8, 16],\n    components: [3]\n  });\n  let nbSlotsCheck = Math.log(nbSlots) / Math.log(8);\n\n  if (nbSlotsCheck !== Math.floor(nbSlotsCheck)) {\n    throw new RangeError('nbSlots must be a power of 8. Usually 8, 64, 512 or 4096');\n  }\n\n  let bitShift = this.bitDepth - nbSlotsCheck;\n  let data = this.data;\n  let result = newArray(Math.pow(8, nbSlotsCheck), 0);\n  let factor2 = Math.pow(2, nbSlotsCheck * 2);\n  let factor1 = Math.pow(2, nbSlotsCheck);\n\n  for (let i = 0; i < data.length; i += this.channels) {\n    let slot = (data[i] >> bitShift) * factor2 + (data[i + 1] >> bitShift) * factor1 + (data[i + 2] >> bitShift);\n\n    if (useAlpha && this.alpha) {\n      result[slot] += data[i + this.channels - 1] / this.maxValue;\n    } else {\n      result[slot]++;\n    }\n  }\n\n  return result;\n}","map":{"version":3,"sources":["C:/Users/kuent/Documents/FinishDipshit/Creative/Ocean-Weather-Visualization/node_modules/image-js/src/image/compute/colorHistogram.js"],"names":["newArray","getColorHistogram","options","useAlpha","nbSlots","checkProcessable","bitDepth","components","nbSlotsCheck","Math","log","floor","RangeError","bitShift","data","result","pow","factor2","factor1","i","length","channels","slot","alpha","maxValue"],"mappings":"AAAA,OAAOA,QAAP,MAAqB,WAArB;AAEA;;;;;;;;;AAQA,eAAe,SAASC,iBAAT,CAA2BC,OAAO,GAAG,EAArC,EAAyC;AACtD,MAAI;AAAEC,IAAAA,QAAQ,GAAG,IAAb;AAAmBC,IAAAA,OAAO,GAAG;AAA7B,MAAqCF,OAAzC;AAEA,OAAKG,gBAAL,CAAsB,mBAAtB,EAA2C;AACzCC,IAAAA,QAAQ,EAAE,CAAC,CAAD,EAAI,EAAJ,CAD+B;AAEzCC,IAAAA,UAAU,EAAE,CAAC,CAAD;AAF6B,GAA3C;AAKA,MAAIC,YAAY,GAAGC,IAAI,CAACC,GAAL,CAASN,OAAT,IAAoBK,IAAI,CAACC,GAAL,CAAS,CAAT,CAAvC;;AACA,MAAIF,YAAY,KAAKC,IAAI,CAACE,KAAL,CAAWH,YAAX,CAArB,EAA+C;AAC7C,UAAM,IAAII,UAAJ,CACJ,0DADI,CAAN;AAGD;;AAED,MAAIC,QAAQ,GAAG,KAAKP,QAAL,GAAgBE,YAA/B;AAEA,MAAIM,IAAI,GAAG,KAAKA,IAAhB;AACA,MAAIC,MAAM,GAAGf,QAAQ,CAACS,IAAI,CAACO,GAAL,CAAS,CAAT,EAAYR,YAAZ,CAAD,EAA4B,CAA5B,CAArB;AACA,MAAIS,OAAO,GAAGR,IAAI,CAACO,GAAL,CAAS,CAAT,EAAYR,YAAY,GAAG,CAA3B,CAAd;AACA,MAAIU,OAAO,GAAGT,IAAI,CAACO,GAAL,CAAS,CAAT,EAAYR,YAAZ,CAAd;;AAEA,OAAK,IAAIW,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGL,IAAI,CAACM,MAAzB,EAAiCD,CAAC,IAAI,KAAKE,QAA3C,EAAqD;AACnD,QAAIC,IAAI,GACN,CAACR,IAAI,CAACK,CAAD,CAAJ,IAAWN,QAAZ,IAAwBI,OAAxB,GACA,CAACH,IAAI,CAACK,CAAC,GAAG,CAAL,CAAJ,IAAeN,QAAhB,IAA4BK,OAD5B,IAECJ,IAAI,CAACK,CAAC,GAAG,CAAL,CAAJ,IAAeN,QAFhB,CADF;;AAIA,QAAIV,QAAQ,IAAI,KAAKoB,KAArB,EAA4B;AAC1BR,MAAAA,MAAM,CAACO,IAAD,CAAN,IAAgBR,IAAI,CAACK,CAAC,GAAG,KAAKE,QAAT,GAAoB,CAArB,CAAJ,GAA8B,KAAKG,QAAnD;AACD,KAFD,MAEO;AACLT,MAAAA,MAAM,CAACO,IAAD,CAAN;AACD;AACF;;AAED,SAAOP,MAAP;AACD","sourcesContent":["import newArray from 'new-array';\n\n/**\n * @memberof Image\n * @instance\n * @param {object} [options]\n * @param {boolean} [options.useAlpha=true]\n * @param {number} [options.nbSlots=512]\n * @return {number[]}\n */\nexport default function getColorHistogram(options = {}) {\n  let { useAlpha = true, nbSlots = 512 } = options;\n\n  this.checkProcessable('getColorHistogram', {\n    bitDepth: [8, 16],\n    components: [3],\n  });\n\n  let nbSlotsCheck = Math.log(nbSlots) / Math.log(8);\n  if (nbSlotsCheck !== Math.floor(nbSlotsCheck)) {\n    throw new RangeError(\n      'nbSlots must be a power of 8. Usually 8, 64, 512 or 4096',\n    );\n  }\n\n  let bitShift = this.bitDepth - nbSlotsCheck;\n\n  let data = this.data;\n  let result = newArray(Math.pow(8, nbSlotsCheck), 0);\n  let factor2 = Math.pow(2, nbSlotsCheck * 2);\n  let factor1 = Math.pow(2, nbSlotsCheck);\n\n  for (let i = 0; i < data.length; i += this.channels) {\n    let slot =\n      (data[i] >> bitShift) * factor2 +\n      (data[i + 1] >> bitShift) * factor1 +\n      (data[i + 2] >> bitShift);\n    if (useAlpha && this.alpha) {\n      result[slot] += data[i + this.channels - 1] / this.maxValue;\n    } else {\n      result[slot]++;\n    }\n  }\n\n  return result;\n}\n"]},"metadata":{},"sourceType":"module"}