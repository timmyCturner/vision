{"ast":null,"code":"'use strict';\n\nconst IOBuffer = require('iobuffer');\n\nconst constants = require('./constants');\n\nconst tableLeft = [];\n\nfor (var i = 0; i <= 8; i++) {\n  tableLeft.push(0b11111111 << i);\n}\n\nmodule.exports = function (imageData) {\n  if (imageData.bitDepth !== 1) {\n    throw new Error('Only bitDepth of 1 is supported');\n  }\n\n  if (!imageData.height || !imageData.width) {\n    throw new Error('ImageData width and height are required');\n  }\n\n  if (imageData.components !== 1) {\n    throw new Error('Only 1 component is supported');\n  }\n\n  if (imageData.channels !== 1) {\n    throw new Error('Only 1 channel is supported');\n  }\n\n  var io = new IOBuffer(); // skip header\n\n  io.skip(14);\n  writeBitmapV5Header(io, imageData);\n  writeColorTable(io, imageData);\n  const imageOffset = io.offset;\n  writePixelArray(io, imageData); // write header at the end\n\n  io.rewind();\n  writeBitmapFileHeader(io, imageOffset);\n  return io.getBuffer();\n};\n\nfunction writePixelArray(io, imgData) {\n  const rowSize = Math.floor((imgData.bitDepth * imgData.width + 31) / 32) * 4;\n  const dataRowSize = Math.ceil(imgData.bitDepth * imgData.width / 8);\n  const skipSize = rowSize - dataRowSize;\n  const bitOverflow = imgData.bitDepth * imgData.width % 8;\n  const bitSkip = bitOverflow === 0 ? 0 : 8 - bitOverflow;\n  const totalBytes = rowSize * imgData.height;\n  var byteA, byteB;\n  const ioData = new IOBuffer(imgData.data);\n  let offset = 0; // Current off set in the ioData\n\n  let relOffset = 0,\n      iOffset = 8;\n  io.mark();\n  byteB = ioData.readUint8();\n\n  for (var i = imgData.height - 1; i >= 0; i--) {\n    const lastRow = i === 0;\n    io.reset();\n    io.skip(i * rowSize);\n\n    for (var j = 0; j < dataRowSize; j++) {\n      const lastCol = j === dataRowSize - 1;\n\n      if (relOffset <= bitSkip && lastCol) {\n        // no need to read new data\n        io.writeByte(byteB << relOffset);\n\n        if ((bitSkip === 0 || bitSkip === relOffset) && !lastRow) {\n          byteA = byteB;\n          byteB = ioData.readByte();\n        }\n      } else if (relOffset === 0) {\n        byteA = byteB;\n        byteB = ioData.readUint8();\n        io.writeByte(byteA);\n      } else {\n        byteA = byteB;\n        byteB = ioData.readUint8();\n        io.writeByte(byteA << relOffset & tableLeft[relOffset] | byteB >> iOffset);\n      }\n\n      if (lastCol) {\n        offset += bitOverflow || 8;\n        io.skip(skipSize);\n        relOffset = offset % 8;\n        iOffset = 8 - relOffset;\n      } else {\n        offset += 8;\n      }\n    }\n  }\n\n  if (rowSize > dataRowSize) {\n    // make sure last written byte is correct\n    io.reset();\n    io.skip(totalBytes - 1);\n    io.writeUint8(0);\n  }\n}\n\nfunction writeColorTable(io, imgData) {\n  // Color table is optional for bitDepth >= 8\n  if (imgData.bitDepth > 8) return; // We only handle 1-bit images\n\n  io.writeUint32(0x00000000) // black\n  .writeUint32(0x00ffffff); //white\n}\n\nfunction writeBitmapFileHeader(io, imageOffset) {\n  // 14 bytes bitmap file header\n  io.writeChars('BM'); // Size of BMP file in bytes\n\n  io.writeInt32(io._lastWrittenByte);\n  io.writeUint16(0);\n  io.writeUint16(0);\n  io.writeUint32(imageOffset);\n}\n\nfunction writeBitmapV5Header(io, imgData) {\n  // Size of the header\n  io.writeUint32(124) // Header size\n  .writeInt32(imgData.width) // bV5Width\n  .writeInt32(imgData.height) // bV5Height\n  .writeUint16(1) // bv5Planes - must be set to 1\n  .writeUint16(imgData.bitDepth) // bV5BitCount\n  .writeUint32(constants.BITMAPV5HEADER.Compression.BI_RGB) // bV5Compression - No compression\n  .writeUint32(imgData.width * imgData.height * imgData.bitDepth) // bv5SizeImage - buffer size (optional if uncompressed)\n  .writeInt32(0) // bV5XPelsPerMeter - resolution\n  .writeInt32(0) // bV5YPelsPerMeter - resolution\n  .writeUint32(Math.pow(2, imgData.bitDepth)).writeUint32(Math.pow(2, imgData.bitDepth)).writeUint32(0xff000000) // bV5RedMask\n  .writeUint32(0x00ff0000) // bV5GreenMask\n  .writeUint32(0x0000ff00) // bV5BlueMask\n  .writeUint32(0x000000ff) // bV5AlphaMask\n  .writeUint32(constants.BITMAPV5HEADER.LogicalColorSpace.LCS_sRGB).skip(36) // bV5Endpoints\n  .skip(12) // bV5GammaRed, Green, Blue\n  .writeUint32(constants.BITMAPV5HEADER.GamutMappingIntent.LCS_GM_IMAGES).skip(12); // ProfileData, ProfileSize, Reserved\n}","map":{"version":3,"sources":["C:/Users/kuent/Documents/FinishDipshit/Creative/Ocean-Weather-Visualization/node_modules/fast-bmp/src/encode.js"],"names":["IOBuffer","require","constants","tableLeft","i","push","module","exports","imageData","bitDepth","Error","height","width","components","channels","io","skip","writeBitmapV5Header","writeColorTable","imageOffset","offset","writePixelArray","rewind","writeBitmapFileHeader","getBuffer","imgData","rowSize","Math","floor","dataRowSize","ceil","skipSize","bitOverflow","bitSkip","totalBytes","byteA","byteB","ioData","data","relOffset","iOffset","mark","readUint8","lastRow","reset","j","lastCol","writeByte","readByte","writeUint8","writeUint32","writeChars","writeInt32","_lastWrittenByte","writeUint16","BITMAPV5HEADER","Compression","BI_RGB","pow","LogicalColorSpace","LCS_sRGB","GamutMappingIntent","LCS_GM_IMAGES"],"mappings":"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","sourcesContent":["'use strict';\n\nconst IOBuffer = require('iobuffer');\nconst constants = require('./constants');\nconst tableLeft = [];\nfor (var i = 0; i <= 8; i++) {\n    tableLeft.push(0b11111111 << i);\n}\nmodule.exports = function (imageData) {\n    if (imageData.bitDepth !== 1) {\n        throw new Error('Only bitDepth of 1 is supported');\n    }\n    if (!imageData.height || !imageData.width) {\n        throw new Error('ImageData width and height are required');\n    }\n\n    if (imageData.components !== 1) {\n        throw new Error('Only 1 component is supported');\n    }\n\n    if (imageData.channels !== 1) {\n        throw new Error('Only 1 channel is supported');\n    }\n\n    var io = new IOBuffer();\n    // skip header\n    io.skip(14);\n    writeBitmapV5Header(io, imageData);\n    writeColorTable(io, imageData);\n    const imageOffset = io.offset;\n    writePixelArray(io, imageData);\n\n    // write header at the end\n    io.rewind();\n    writeBitmapFileHeader(io, imageOffset);\n    return io.getBuffer();\n};\n\nfunction writePixelArray(io, imgData) {\n    const rowSize = Math.floor((imgData.bitDepth * imgData.width + 31) / 32) * 4;\n    const dataRowSize = Math.ceil(imgData.bitDepth * imgData.width / 8);\n    const skipSize = rowSize - dataRowSize;\n    const bitOverflow = (imgData.bitDepth * imgData.width) % 8;\n    const bitSkip = bitOverflow === 0 ? 0 : 8 - bitOverflow;\n    const totalBytes = rowSize * imgData.height;\n\n    var byteA, byteB;\n    const ioData = new IOBuffer(imgData.data);\n    let offset = 0; // Current off set in the ioData\n    let relOffset = 0, iOffset = 8;\n    io.mark();\n    byteB = ioData.readUint8();\n    for (var i = imgData.height - 1; i >= 0; i--) {\n        const lastRow = (i === 0);\n        io.reset();\n        io.skip(i * rowSize);\n        for (var j = 0; j < dataRowSize; j++) {\n            const lastCol = (j === dataRowSize - 1);\n            if (relOffset <= bitSkip && lastCol) {\n                // no need to read new data\n                io.writeByte((byteB << relOffset));\n                if ((bitSkip === 0 || bitSkip === relOffset) && !lastRow) {\n                    byteA = byteB;\n                    byteB = ioData.readByte();\n                }\n            } else if (relOffset === 0) {\n                byteA = byteB;\n                byteB = ioData.readUint8();\n                io.writeByte(byteA);\n            } else {\n                byteA = byteB;\n                byteB = ioData.readUint8();\n                io.writeByte(((byteA << relOffset) & tableLeft[relOffset]) | (byteB >> iOffset));\n            }\n            if (lastCol) {\n                offset += (bitOverflow || 8);\n                io.skip(skipSize);\n                relOffset = offset % 8;\n                iOffset = 8 - relOffset;\n            } else {\n                offset += 8;\n            }\n        }\n    }\n    if (rowSize > dataRowSize) {\n        // make sure last written byte is correct\n        io.reset();\n        io.skip(totalBytes - 1);\n        io.writeUint8(0);\n    }\n\n}\n\nfunction writeColorTable(io, imgData) {\n    // Color table is optional for bitDepth >= 8\n    if (imgData.bitDepth > 8) return;\n    // We only handle 1-bit images\n    io\n        .writeUint32(0x00000000) // black\n        .writeUint32(0x00ffffff); //white\n}\n\nfunction writeBitmapFileHeader(io, imageOffset) {\n    // 14 bytes bitmap file header\n    io.writeChars('BM');\n    // Size of BMP file in bytes\n    io.writeInt32(io._lastWrittenByte);\n    io.writeUint16(0);\n    io.writeUint16(0);\n    io.writeUint32(imageOffset);\n}\n\nfunction writeBitmapV5Header(io, imgData) {\n    // Size of the header\n    io\n        .writeUint32(124)   // Header size\n        .writeInt32(imgData.width) // bV5Width\n        .writeInt32(imgData.height) // bV5Height\n        .writeUint16(1)               // bv5Planes - must be set to 1\n        .writeUint16(imgData.bitDepth) // bV5BitCount\n        .writeUint32(constants.BITMAPV5HEADER.Compression.BI_RGB)  // bV5Compression - No compression\n        .writeUint32(imgData.width * imgData.height * imgData.bitDepth) // bv5SizeImage - buffer size (optional if uncompressed)\n        .writeInt32(0)  // bV5XPelsPerMeter - resolution\n        .writeInt32(0)  // bV5YPelsPerMeter - resolution\n        .writeUint32(Math.pow(2, imgData.bitDepth))\n        .writeUint32(Math.pow(2, imgData.bitDepth))\n        .writeUint32(0xff000000) // bV5RedMask\n        .writeUint32(0x00ff0000) // bV5GreenMask\n        .writeUint32(0x0000ff00) // bV5BlueMask\n        .writeUint32(0x000000ff) // bV5AlphaMask\n        .writeUint32(constants.BITMAPV5HEADER.LogicalColorSpace.LCS_sRGB)\n        .skip(36)                // bV5Endpoints\n        .skip(12)                // bV5GammaRed, Green, Blue\n        .writeUint32(constants.BITMAPV5HEADER.GamutMappingIntent.LCS_GM_IMAGES)\n        .skip(12);               // ProfileData, ProfileSize, Reserved\n}\n"]},"metadata":{},"sourceType":"script"}