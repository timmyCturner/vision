{"ast":null,"code":"import Matrix, { SVD, pseudoInverse } from 'ml-matrix';\nexport default class MultivariateLinearRegression {\n  constructor(x, y, options = {}) {\n    const {\n      intercept = true,\n      statistics = true\n    } = options;\n    this.statistics = statistics;\n\n    if (x === true) {\n      this.weights = y.weights;\n      this.inputs = y.inputs;\n      this.outputs = y.outputs;\n      this.intercept = y.intercept;\n    } else {\n      x = new Matrix(x);\n      y = new Matrix(y);\n\n      if (intercept) {\n        x.addColumn(new Array(x.rows).fill(1));\n      }\n\n      let xt = x.transpose();\n      const xx = xt.mmul(x);\n      const xy = xt.mmul(y);\n      const invxx = new SVD(xx).inverse();\n      const beta = xy.transpose().mmul(invxx).transpose();\n      this.weights = beta.to2DArray();\n      this.inputs = x.columns;\n      this.outputs = y.columns;\n      if (intercept) this.inputs--;\n      this.intercept = intercept;\n\n      if (statistics) {\n        /*\n         * Let's add some basic statistics about the beta's to be able to interpret them.\n         * source: http://dept.stat.lsa.umich.edu/~kshedden/Courses/Stat401/Notes/401-multreg.pdf\n         * validated against Excel Regression AddIn\n         * test: \"datamining statistics test\"\n         */\n        const fittedValues = x.mmul(beta);\n        const residuals = y.clone().addM(fittedValues.neg());\n        const variance = residuals.to2DArray().map(ri => Math.pow(ri[0], 2)).reduce((a, b) => a + b) / (y.rows - x.columns);\n        this.stdError = Math.sqrt(variance);\n        this.stdErrorMatrix = pseudoInverse(xx).mul(variance);\n        this.stdErrors = this.stdErrorMatrix.diagonal().map(d => Math.sqrt(d));\n        this.tStats = this.weights.map((d, i) => this.stdErrors[i] === 0 ? 0 : d[0] / this.stdErrors[i]);\n      }\n    }\n  }\n\n  predict(x) {\n    if (Array.isArray(x)) {\n      if (typeof x[0] === 'number') {\n        return this._predict(x);\n      } else if (Array.isArray(x[0])) {\n        const y = new Array(x.length);\n\n        for (let i = 0; i < x.length; i++) {\n          y[i] = this._predict(x[i]);\n        }\n\n        return y;\n      }\n    } else if (Matrix.isMatrix(x)) {\n      const y = new Matrix(x.rows, this.outputs);\n\n      for (let i = 0; i < x.rows; i++) {\n        y.setRow(i, this._predict(x.getRow(i)));\n      }\n\n      return y;\n    }\n\n    throw new TypeError('x must be a matrix or array of numbers');\n  }\n\n  _predict(x) {\n    const result = new Array(this.outputs);\n\n    if (this.intercept) {\n      for (let i = 0; i < this.outputs; i++) {\n        result[i] = this.weights[this.inputs][i];\n      }\n    } else {\n      result.fill(0);\n    }\n\n    for (let i = 0; i < this.inputs; i++) {\n      for (let j = 0; j < this.outputs; j++) {\n        result[j] += this.weights[i][j] * x[i];\n      }\n    }\n\n    return result;\n  }\n\n  score() {\n    throw new Error('score method is not implemented yet');\n  }\n\n  toJSON() {\n    return {\n      name: 'multivariateLinearRegression',\n      weights: this.weights,\n      inputs: this.inputs,\n      outputs: this.outputs,\n      intercept: this.intercept,\n      summary: this.statistics ? {\n        regressionStatistics: {\n          standardError: this.stdError,\n          observations: this.outputs\n        },\n        variables: this.weights.map((d, i) => {\n          return {\n            label: i === this.weights.length - 1 ? 'Intercept' : `X Variable ${i + 1}`,\n            coefficients: d,\n            standardError: this.stdErrors[i],\n            tStat: this.tStats[i]\n          };\n        })\n      } : undefined\n    };\n  }\n\n  static load(model) {\n    if (model.name !== 'multivariateLinearRegression') {\n      throw new Error('not a MLR model');\n    }\n\n    return new MultivariateLinearRegression(true, model);\n  }\n\n}","map":{"version":3,"sources":["C:/Users/kuent/Documents/FinishDipshit/Creative/Ocean-Weather-Visualization/node_modules/ml-regression-multivariate-linear/src/index.js"],"names":["Matrix","SVD","pseudoInverse","MultivariateLinearRegression","constructor","x","y","options","intercept","statistics","weights","inputs","outputs","addColumn","Array","rows","fill","xt","transpose","xx","mmul","xy","invxx","inverse","beta","to2DArray","columns","fittedValues","residuals","clone","addM","neg","variance","map","ri","Math","pow","reduce","a","b","stdError","sqrt","stdErrorMatrix","mul","stdErrors","diagonal","d","tStats","i","predict","isArray","_predict","length","isMatrix","setRow","getRow","TypeError","result","j","score","Error","toJSON","name","summary","regressionStatistics","standardError","observations","variables","label","coefficients","tStat","undefined","load","model"],"mappings":"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","sourcesContent":["import Matrix, { SVD, pseudoInverse } from 'ml-matrix';\n\nexport default class MultivariateLinearRegression {\n  constructor(x, y, options = {}) {\n    const { intercept = true, statistics = true } = options;\n    this.statistics = statistics;\n    if (x === true) {\n      this.weights = y.weights;\n      this.inputs = y.inputs;\n      this.outputs = y.outputs;\n      this.intercept = y.intercept;\n    } else {\n      x = new Matrix(x);\n      y = new Matrix(y);\n      if (intercept) {\n        x.addColumn(new Array(x.rows).fill(1));\n      }\n      let xt = x.transpose();\n      const xx = xt.mmul(x);\n      const xy = xt.mmul(y);\n      const invxx = new SVD(xx).inverse();\n      const beta = xy\n        .transpose()\n        .mmul(invxx)\n        .transpose();\n      this.weights = beta.to2DArray();\n      this.inputs = x.columns;\n      this.outputs = y.columns;\n      if (intercept) this.inputs--;\n      this.intercept = intercept;\n      if (statistics) {\n        /*\n         * Let's add some basic statistics about the beta's to be able to interpret them.\n         * source: http://dept.stat.lsa.umich.edu/~kshedden/Courses/Stat401/Notes/401-multreg.pdf\n         * validated against Excel Regression AddIn\n         * test: \"datamining statistics test\"\n         */\n        const fittedValues = x.mmul(beta);\n        const residuals = y.clone().addM(fittedValues.neg());\n        const variance =\n          residuals\n            .to2DArray()\n            .map((ri) => Math.pow(ri[0], 2))\n            .reduce((a, b) => a + b) /\n          (y.rows - x.columns);\n        this.stdError = Math.sqrt(variance);\n        this.stdErrorMatrix = pseudoInverse(xx).mul(variance);\n        this.stdErrors = this.stdErrorMatrix\n          .diagonal()\n          .map((d) => Math.sqrt(d));\n        this.tStats = this.weights.map((d, i) =>\n          this.stdErrors[i] === 0 ? 0 : d[0] / this.stdErrors[i],\n        );\n      }\n    }\n  }\n\n  predict(x) {\n    if (Array.isArray(x)) {\n      if (typeof x[0] === 'number') {\n        return this._predict(x);\n      } else if (Array.isArray(x[0])) {\n        const y = new Array(x.length);\n        for (let i = 0; i < x.length; i++) {\n          y[i] = this._predict(x[i]);\n        }\n        return y;\n      }\n    } else if (Matrix.isMatrix(x)) {\n      const y = new Matrix(x.rows, this.outputs);\n      for (let i = 0; i < x.rows; i++) {\n        y.setRow(i, this._predict(x.getRow(i)));\n      }\n      return y;\n    }\n    throw new TypeError('x must be a matrix or array of numbers');\n  }\n\n  _predict(x) {\n    const result = new Array(this.outputs);\n    if (this.intercept) {\n      for (let i = 0; i < this.outputs; i++) {\n        result[i] = this.weights[this.inputs][i];\n      }\n    } else {\n      result.fill(0);\n    }\n    for (let i = 0; i < this.inputs; i++) {\n      for (let j = 0; j < this.outputs; j++) {\n        result[j] += this.weights[i][j] * x[i];\n      }\n    }\n    return result;\n  }\n\n  score() {\n    throw new Error('score method is not implemented yet');\n  }\n\n  toJSON() {\n    return {\n      name: 'multivariateLinearRegression',\n      weights: this.weights,\n      inputs: this.inputs,\n      outputs: this.outputs,\n      intercept: this.intercept,\n      summary: this.statistics\n        ? {\n            regressionStatistics: {\n              standardError: this.stdError,\n              observations: this.outputs,\n            },\n            variables: this.weights.map((d, i) => {\n              return {\n                label:\n                  i === this.weights.length - 1\n                    ? 'Intercept'\n                    : `X Variable ${i + 1}`,\n                coefficients: d,\n                standardError: this.stdErrors[i],\n                tStat: this.tStats[i],\n              };\n            }),\n          }\n        : undefined,\n    };\n  }\n\n  static load(model) {\n    if (model.name !== 'multivariateLinearRegression') {\n      throw new Error('not a MLR model');\n    }\n    return new MultivariateLinearRegression(true, model);\n  }\n}\n"]},"metadata":{},"sourceType":"module"}