{"ast":null,"code":"import Image from '../Image';\n/**\n * Crops the image\n * @memberof Image\n * @instance\n * @param {object} [options]\n * @param {number} [options.x=0] - x coordinate to place the zero of the new image\n * @param {number} [options.y=0] - y coordinate to place the zero of the new image\n * @param {number} [options.width=this.width-x] - width of the new image\n * @param {number} [options.height=this.height-y] - height of the new image\n * @return {Image} The new cropped image\n * @example\n * var cropped = image.crop({\n *   x:0,\n *   y:0\n * });\n */\n\nexport default function crop(options = {}) {\n  let {\n    x = 0,\n    y = 0,\n    width = this.width - x,\n    height = this.height - y\n  } = options;\n  this.checkProcessable('max', {\n    bitDepth: [8, 16]\n  });\n  x = Math.round(x);\n  y = Math.round(y);\n  width = Math.round(width);\n  height = Math.round(height);\n\n  if (x > this.width - 1 || y > this.height - 1) {\n    throw new RangeError(`crop: origin (x:${x}, y:${y}) out of range (${this.width - 1}; ${this.height - 1})`);\n  }\n\n  if (width <= 0 || height <= 0) {\n    throw new RangeError(`crop: width and height (width:${width}; height:${height}) must be positive numbers`);\n  }\n\n  if (x < 0 || y < 0) {\n    throw new RangeError(`crop: x and y (x:${x}, y:${y}) must be positive numbers`);\n  }\n\n  if (width > this.width - x || height > this.height - y) {\n    throw new RangeError(`crop: (x: ${x}, y:${y}, width:${width}, height:${height}) size is out of range`);\n  }\n\n  let newImage = Image.createFrom(this, {\n    width,\n    height,\n    position: [x, y]\n  });\n  let xWidth = width * this.channels;\n  let y1 = y + height;\n  let ptr = 0; // pointer for new array\n\n  let jLeft = x * this.channels;\n\n  for (let i = y; i < y1; i++) {\n    let j = i * this.width * this.channels + jLeft;\n    let jL = j + xWidth;\n\n    for (; j < jL; j++) {\n      newImage.data[ptr++] = this.data[j];\n    }\n  }\n\n  return newImage;\n}","map":{"version":3,"sources":["C:/Users/kuent/Documents/FinishDipshit/Creative/Ocean-Weather-Visualization/node_modules/image-js/src/image/transform/crop.js"],"names":["Image","crop","options","x","y","width","height","checkProcessable","bitDepth","Math","round","RangeError","newImage","createFrom","position","xWidth","channels","y1","ptr","jLeft","i","j","jL","data"],"mappings":"AAAA,OAAOA,KAAP,MAAkB,UAAlB;AAEA;;;;;;;;;;;;;;;;;AAgBA,eAAe,SAASC,IAAT,CAAcC,OAAO,GAAG,EAAxB,EAA4B;AACzC,MAAI;AACFC,IAAAA,CAAC,GAAG,CADF;AAEFC,IAAAA,CAAC,GAAG,CAFF;AAGFC,IAAAA,KAAK,GAAG,KAAKA,KAAL,GAAaF,CAHnB;AAIFG,IAAAA,MAAM,GAAG,KAAKA,MAAL,GAAcF;AAJrB,MAKAF,OALJ;AAOA,OAAKK,gBAAL,CAAsB,KAAtB,EAA6B;AAC3BC,IAAAA,QAAQ,EAAE,CAAC,CAAD,EAAI,EAAJ;AADiB,GAA7B;AAIAL,EAAAA,CAAC,GAAGM,IAAI,CAACC,KAAL,CAAWP,CAAX,CAAJ;AACAC,EAAAA,CAAC,GAAGK,IAAI,CAACC,KAAL,CAAWN,CAAX,CAAJ;AACAC,EAAAA,KAAK,GAAGI,IAAI,CAACC,KAAL,CAAWL,KAAX,CAAR;AACAC,EAAAA,MAAM,GAAGG,IAAI,CAACC,KAAL,CAAWJ,MAAX,CAAT;;AAEA,MAAIH,CAAC,GAAG,KAAKE,KAAL,GAAa,CAAjB,IAAsBD,CAAC,GAAG,KAAKE,MAAL,GAAc,CAA5C,EAA+C;AAC7C,UAAM,IAAIK,UAAJ,CACH,mBAAkBR,CAAE,OAAMC,CAAE,mBAAkB,KAAKC,KAAL,GAAa,CAAE,KAC5D,KAAKC,MAAL,GAAc,CACf,GAHG,CAAN;AAKD;;AACD,MAAID,KAAK,IAAI,CAAT,IAAcC,MAAM,IAAI,CAA5B,EAA+B;AAC7B,UAAM,IAAIK,UAAJ,CACH,iCAAgCN,KAAM,YAAWC,MAAO,4BADrD,CAAN;AAGD;;AACD,MAAIH,CAAC,GAAG,CAAJ,IAASC,CAAC,GAAG,CAAjB,EAAoB;AAClB,UAAM,IAAIO,UAAJ,CACH,oBAAmBR,CAAE,OAAMC,CAAE,4BAD1B,CAAN;AAGD;;AACD,MAAIC,KAAK,GAAG,KAAKA,KAAL,GAAaF,CAArB,IAA0BG,MAAM,GAAG,KAAKA,MAAL,GAAcF,CAArD,EAAwD;AACtD,UAAM,IAAIO,UAAJ,CACH,aAAYR,CAAE,OAAMC,CAAE,WAAUC,KAAM,YAAWC,MAAO,wBADrD,CAAN;AAGD;;AAED,MAAIM,QAAQ,GAAGZ,KAAK,CAACa,UAAN,CAAiB,IAAjB,EAAuB;AAAER,IAAAA,KAAF;AAASC,IAAAA,MAAT;AAAiBQ,IAAAA,QAAQ,EAAE,CAACX,CAAD,EAAIC,CAAJ;AAA3B,GAAvB,CAAf;AAEA,MAAIW,MAAM,GAAGV,KAAK,GAAG,KAAKW,QAA1B;AACA,MAAIC,EAAE,GAAGb,CAAC,GAAGE,MAAb;AAEA,MAAIY,GAAG,GAAG,CAAV,CA7CyC,CA6C5B;;AAEb,MAAIC,KAAK,GAAGhB,CAAC,GAAG,KAAKa,QAArB;;AAEA,OAAK,IAAII,CAAC,GAAGhB,CAAb,EAAgBgB,CAAC,GAAGH,EAApB,EAAwBG,CAAC,EAAzB,EAA6B;AAC3B,QAAIC,CAAC,GAAGD,CAAC,GAAG,KAAKf,KAAT,GAAiB,KAAKW,QAAtB,GAAiCG,KAAzC;AACA,QAAIG,EAAE,GAAGD,CAAC,GAAGN,MAAb;;AACA,WAAOM,CAAC,GAAGC,EAAX,EAAeD,CAAC,EAAhB,EAAoB;AAClBT,MAAAA,QAAQ,CAACW,IAAT,CAAcL,GAAG,EAAjB,IAAuB,KAAKK,IAAL,CAAUF,CAAV,CAAvB;AACD;AACF;;AAED,SAAOT,QAAP;AACD","sourcesContent":["import Image from '../Image';\n\n/**\n * Crops the image\n * @memberof Image\n * @instance\n * @param {object} [options]\n * @param {number} [options.x=0] - x coordinate to place the zero of the new image\n * @param {number} [options.y=0] - y coordinate to place the zero of the new image\n * @param {number} [options.width=this.width-x] - width of the new image\n * @param {number} [options.height=this.height-y] - height of the new image\n * @return {Image} The new cropped image\n * @example\n * var cropped = image.crop({\n *   x:0,\n *   y:0\n * });\n */\nexport default function crop(options = {}) {\n  let {\n    x = 0,\n    y = 0,\n    width = this.width - x,\n    height = this.height - y,\n  } = options;\n\n  this.checkProcessable('max', {\n    bitDepth: [8, 16],\n  });\n\n  x = Math.round(x);\n  y = Math.round(y);\n  width = Math.round(width);\n  height = Math.round(height);\n\n  if (x > this.width - 1 || y > this.height - 1) {\n    throw new RangeError(\n      `crop: origin (x:${x}, y:${y}) out of range (${this.width - 1}; ${\n        this.height - 1\n      })`,\n    );\n  }\n  if (width <= 0 || height <= 0) {\n    throw new RangeError(\n      `crop: width and height (width:${width}; height:${height}) must be positive numbers`,\n    );\n  }\n  if (x < 0 || y < 0) {\n    throw new RangeError(\n      `crop: x and y (x:${x}, y:${y}) must be positive numbers`,\n    );\n  }\n  if (width > this.width - x || height > this.height - y) {\n    throw new RangeError(\n      `crop: (x: ${x}, y:${y}, width:${width}, height:${height}) size is out of range`,\n    );\n  }\n\n  let newImage = Image.createFrom(this, { width, height, position: [x, y] });\n\n  let xWidth = width * this.channels;\n  let y1 = y + height;\n\n  let ptr = 0; // pointer for new array\n\n  let jLeft = x * this.channels;\n\n  for (let i = y; i < y1; i++) {\n    let j = i * this.width * this.channels + jLeft;\n    let jL = j + xWidth;\n    for (; j < jL; j++) {\n      newImage.data[ptr++] = this.data[j];\n    }\n  }\n\n  return newImage;\n}\n"]},"metadata":{},"sourceType":"module"}