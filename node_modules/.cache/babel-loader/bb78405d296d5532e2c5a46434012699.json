{"ast":null,"code":"import deepValue from '../../util/deepValue';\nimport Qty from 'js-quantities';\nimport Image from '../Image';\nimport RoiLayer from './RoiLayer';\nimport RoiMap from './RoiMap';\nimport fromMask from './creator/fromMask';\nimport fromMaskConnectedComponentLabelingAlgorithm from './creator/fromMaskConnectedComponentLabelingAlgorithm';\nimport fromMaxima from './creator/fromMaxima';\nimport fromPoints from './creator/fromPoints';\nimport fromWaterShed from './creator/fromWaterShed';\n/**\n * A manager of Regions of Interest. A RoiManager is related to a specific Image\n * and may contain multiple layers. Each layer is characterized by a label whose is\n * name by default 'default'\n * @class RoiManager\n * @param {Image} image\n * @param {object} [options]\n */\n\nexport default class RoiManager {\n  constructor(image, options = {}) {\n    this._image = image;\n    this._options = options;\n\n    if (!this._options.label) {\n      this._options.label = 'default';\n    }\n\n    this._layers = {};\n    this._painted = null;\n  } // docs is in the corresponding file\n\n\n  fromMaxima(options = {}) {\n    let opt = Object.assign({}, this._options, options);\n    let roiMap = fromMaxima.call(this._image, options);\n    this._layers[opt.label] = new RoiLayer(roiMap, opt);\n  } // docs is in the corresponding file\n\n\n  fromPoints(points, options = {}) {\n    let opt = Object.assign({}, this._options, options);\n    let roiMap = fromPoints.call(this._image, points, options);\n    this._layers[opt.label] = new RoiLayer(roiMap, opt);\n    return this;\n  }\n  /**\n   * @param {number[]} map\n   * @param {object} [options]\n   * @return {this}\n   */\n\n\n  putMap(map, options = {}) {\n    let roiMap = new RoiMap(this._image, map);\n    let opt = Object.assign({}, this._options, options);\n    this._layers[opt.label] = new RoiLayer(roiMap, opt);\n    return this;\n  } // docs is in the corresponding file\n\n\n  fromWaterShed(options = {}) {\n    let opt = Object.assign({}, this._options, options);\n    let roiMap = fromWaterShed.call(this._image, options);\n    this._layers[opt.label] = new RoiLayer(roiMap, opt);\n  } // docs is in the corresponding file\n\n\n  fromMask(mask, options = {}) {\n    let opt = Object.assign({}, this._options, options);\n    let roiMap = fromMask.call(this._image, mask, options);\n    this._layers[opt.label] = new RoiLayer(roiMap, opt);\n    return this;\n  }\n\n  fromMaskConnectedComponentLabelingAlgorithm(mask, options = {}) {\n    let opt = Object.assign({}, this._options, options);\n    let roiMap = fromMaskConnectedComponentLabelingAlgorithm.call(this._image, mask, options);\n    this._layers[opt.label] = new RoiLayer(roiMap, opt);\n    return this;\n  }\n  /**\n   *\n   * @param {object} [options]\n   * @return {RoiMap}\n   */\n\n\n  getMap(options = {}) {\n    let opt = Object.assign({}, this._options, options);\n\n    this._assertLayerWithLabel(opt.label);\n\n    return this._layers[opt.label].roiMap;\n  }\n  /**\n   * Return statistics about rows\n   * @param {object} [options]\n   * @return {object[]}\n   */\n\n\n  rowsInfo(options = {}) {\n    return this.getMap(options).rowsInfo();\n  }\n  /**\n   * Return statistics about columns\n   * @param {object} [options]\n   * @return {object[]}\n   */\n\n\n  colsInfo(options = {}) {\n    return this.getMap(options).rowsInfo();\n  }\n  /**\n   * Return the IDs of the Regions Of Interest (Roi) as an array of number\n   * @param {object} [options]\n   * @return {number[]}\n   */\n\n\n  getRoiIds(options = {}) {\n    let rois = this.getRois(options);\n\n    if (rois) {\n      let ids = new Array(rois.length);\n\n      for (let i = 0; i < rois.length; i++) {\n        ids[i] = rois[i].id;\n      }\n\n      return ids;\n    }\n\n    throw new Error('ROIs not found');\n  }\n  /**\n   * Allows to select ROI based on size, label and sign.\n   * @param {object} [options={}]\n   * @param {string} [options.label='default'] Label of the layer containing the ROI\n   * @param {boolean} [options.positive=true] Select the positive region of interest\n   * @param {boolean} [options.negative=true] Select he negative region of interest\n   * @param {number} [options.minSurface=0]\n   * @param {number} [options.maxSurface=Number.POSITIVE_INFINITY]\n   * @param {number} [options.minWidth=0]\n   * @param {number} [options.minHeight=Number.POSITIVE_INFINITY]\n   * @param {number} [options.maxWidth=0]\n   * @param {number} [options.maxHeight=Number.POSITIVE_INFINITY]\n   * @param {number} [options.minRatio=0] Ratio width / height\n   * @param {number} [options.maxRatio=Number.POSITIVE_INFINITY]\n   * @return {Roi[]}\n   */\n\n\n  getRois(options = {}) {\n    let {\n      label = this._options.label,\n      positive = true,\n      negative = true,\n      minSurface = 0,\n      maxSurface = Number.POSITIVE_INFINITY,\n      minWidth = 0,\n      maxWidth = Number.POSITIVE_INFINITY,\n      minHeight = 0,\n      maxHeight = Number.POSITIVE_INFINITY,\n      minRatio = 0,\n      maxRatio = Number.POSITIVE_INFINITY\n    } = options;\n\n    if (!this._layers[label]) {\n      throw new Error(`this Roi layer (${label}) does not exist`);\n    }\n\n    const allRois = this._layers[label].roi;\n    const rois = [];\n\n    for (const roi of allRois) {\n      if ((roi.id < 0 && negative || roi.id > 0 && positive) && roi.surface >= minSurface && roi.surface <= maxSurface && roi.width >= minWidth && roi.width <= maxWidth && roi.height >= minHeight && roi.height <= maxHeight && roi.ratio >= minRatio && roi.ratio <= maxRatio) {\n        rois.push(roi);\n      }\n    }\n\n    return rois;\n  }\n  /**\n   * Get an ROI by its id.\n   * @param {number} roiId\n   * @param {object} [options={}]\n   * @param {string} [options.label='default'] Label of the layer containing the ROI\n   * @return {Roi}\n   */\n\n\n  getRoi(roiId, options = {}) {\n    const {\n      label = this._options.label\n    } = options;\n\n    if (!this._layers[label]) {\n      throw new Error(`this Roi layer (${label}) does not exist`);\n    }\n\n    const roi = this._layers[label].roi.find(roi => roi.id === roiId);\n\n    if (!roi) {\n      throw new Error(`found no Roi with id ${roiId}`);\n    }\n\n    return roi;\n  }\n  /**\n   * Returns an array of masks\n   * See {@link Roi.getMask} for the options\n   * @param {object} [options]\n   * @return {Image[]} Retuns an array of masks (1 bit Image)\n   */\n\n\n  getMasks(options = {}) {\n    let rois = this.getRois(options);\n    let masks = new Array(rois.length);\n\n    for (let i = 0; i < rois.length; i++) {\n      masks[i] = rois[i].getMask(options);\n    }\n\n    return masks;\n  }\n  /**\n   * Returns an array of masks\n   * See {@link Roi.getAnalysisMasks} for the options\n   * @param {object} [options]\n   * @return {Image[]} Retuns an array of masks (1 bit Image)\n   */\n\n\n  getAnalysisMasks(options = {}) {\n    const {\n      analysisProperty\n    } = options;\n    let maskProperty = `${analysisProperty}Mask`;\n    let rois = this.getRois(options);\n    if (rois.length === 0 || !rois[0][maskProperty]) return [];\n    return rois.map(roi => roi[maskProperty]);\n  }\n  /**\n   *\n   * @param {object} [options]\n   * @return {number[]}\n   */\n\n\n  getData(options = {}) {\n    let opt = Object.assign({}, this._options, options);\n\n    this._assertLayerWithLabel(opt.label);\n\n    return this._layers[opt.label].roiMap.data;\n  }\n  /**\n   * Paint the ROI on a copy of the image and return this image.\n   * For painting options {@link Image.paintMasks}\n   * For ROI selection options, see {@link RoiManager.getMasks}\n   * @param {object} [options] - all the options to select ROIs\n   * @param {string} [options.labelProperty] - Paint a mask property on the image.\n   *                                  May be any property of the ROI like\n   *                                  for example id, surface, width, height, meanX, meanY.\n   * @param {number} [options.pixelSize] Size of a pixel in SI\n   * @param {string} [options.unit=\"pixel\"] Unit in which to display the values\n   * @return {Image} - The painted RGBA 8 bits image\n   */\n\n\n  paint(options = {}) {\n    let {\n      labelProperty,\n      analysisProperty\n    } = options;\n\n    if (!this._painted) {\n      this._painted = this._image.rgba8();\n    }\n\n    let masks = this.getMasks(options);\n\n    if (labelProperty) {\n      const rois = this.getRois(options);\n      options.labels = rois.map(roi => deepValue(roi, labelProperty));\n      const max = Math.max(...options.labels);\n      let isSurface = false;\n      let isDistance = false;\n\n      if (labelProperty.includes('surface')) {\n        isSurface = true;\n      } else if (labelProperty.match(/(perimeter|min|max|external|width|height|length)/)) {\n        isDistance = true;\n      }\n\n      if (isFinite(max)) {\n        let unitLabel = '';\n\n        if (options.unit !== 'pixel' && options.pixelSize && (isDistance || isSurface)) {\n          unitLabel = isSurface ? `${options.unit}^2` : options.unit;\n          let siLabel = isSurface ? 'm^2' : 'm';\n          let factor = isSurface ? options.pixelSize ** 2 : options.pixelSize;\n          const convert = Qty.swiftConverter(siLabel, unitLabel);\n          options.labels = options.labels.map(value => {\n            return convert(factor * value);\n          });\n        }\n\n        if (max > 50) {\n          options.labels = options.labels.map(number => Math.round(number) + unitLabel);\n        } else if (max > 10) {\n          options.labels = options.labels.map(number => number.toFixed(1) + unitLabel);\n        } else {\n          options.labels = options.labels.map(number => number.toFixed(2) + unitLabel);\n        }\n      }\n\n      options.labelsPosition = rois.map(roi => [roi.meanX, roi.meanY]);\n    }\n\n    this._painted.paintMasks(masks, options);\n\n    if (analysisProperty) {\n      let analysisMasks = this.getAnalysisMasks(options);\n\n      this._painted.paintMasks(analysisMasks, {\n        color: options.analysisColor,\n        alpha: options.analysisAlpha\n      });\n    }\n\n    return this._painted;\n  } // return a mask corresponding to all the selected masks\n\n\n  getMask(options = {}) {\n    let mask = new Image(this._image.width, this._image.height, {\n      kind: 'BINARY'\n    });\n    let masks = this.getMasks(options);\n\n    for (let i = 0; i < masks.length; i++) {\n      let roi = masks[i]; // we need to find the parent image to calculate the relative position\n\n      for (let x = 0; x < roi.width; x++) {\n        for (let y = 0; y < roi.height; y++) {\n          if (roi.getBitXY(x, y)) {\n            mask.setBitXY(x + roi.position[0], y + roi.position[1]);\n          }\n        }\n      }\n    }\n\n    return mask;\n  }\n  /**\n   * Reset the changes to the current painted iamge to the image that was\n   * used during the creation of the RoiManager except if a new image is\n   * specified as parameter;\n   * @param {object} [options]\n   * @param {Image} [options.image] A new iamge that you would like to sue for painting over\n   */\n\n\n  resetPainted(options = {}) {\n    const {\n      image\n    } = options;\n\n    if (image) {\n      this._painted = this.image.rgba8();\n    } else {\n      this._painted = this._image.rgba8();\n    }\n  }\n  /**\n   * In place modification of the roiMap that joins regions of interest\n   * @param {object} [options]\n   * @param {string|function(object,number,number)} [options.algorithm='commonBorderLength'] algorithm used to decide which ROIs are merged.\n   *      Current implemented algorithms are 'commonBorderLength' that use the parameters\n   *      'minCommonBorderLength' and 'maxCommonBorderLength' as well as 'commonBorderRatio' that uses\n   *      the parameters 'minCommonBorderRatio' and 'maxCommonBorderRatio'.\n   * @param {number} [options.minCommonBorderLength=5] minimal common number of pixels for merging\n   * @param {number} [options.maxCommonBorderLength=100] maximal common number of pixels for merging\n   * @param {number} [options.minCommonBorderRatio=0.3] minimal common border ratio for merging\n   * @param {number} [options.maxCommonBorderRatio=1] maximal common border ratio for merging\n   * @return {this}\n   */\n\n\n  mergeRoi(options = {}) {\n    const roiMap = this.getMap(options);\n    roiMap.mergeRoi(options);\n    this.putMap(roiMap.data, options);\n    return this;\n  }\n  /**\n   * Merge multiple rois into one.\n   * All rois in the provided array will be merged into the first one.\n   * @param {Array<number>} roiIds - A list of Roi ids to merge\n   * @param {object} [options]\n   */\n\n\n  mergeRois(roiIds, options = {}) {\n    if (!Array.isArray(roiIds) || roiIds.some(id => !Number.isInteger(id))) {\n      throw new Error('Roi ids must be an array of integers');\n    }\n\n    if (roiIds.length < 2) {\n      throw new Error('Roi ids must have at least two elements');\n    }\n\n    if (new Set(roiIds).size !== roiIds.length) {\n      throw new Error('Roi ids must be all different');\n    } // Throws if one of the ids is wrong\n\n\n    roiIds.forEach(roiId => this.getRoi(roiId));\n    const roiMap = this.getMap(options);\n    roiMap.mergeRois(roiIds);\n    this.putMap(roiMap.data, options);\n    return this;\n  }\n  /**\n   * Finds all corresponding ROIs for all ROIs in the manager\n   * @param {number[]} roiMap\n   * @param {object} [options]\n   * @return {Array} array of objects returned in correspondingRoisInformation\n   */\n\n\n  findCorrespondingRoi(roiMap, options = {}) {\n    let allRois = this.getRois(options);\n    let allRelated = [];\n\n    for (let i = 0; i < allRois.length; i++) {\n      let currentRoi = allRois[i];\n      let x = currentRoi.minX;\n      let y = currentRoi.minY;\n      let allPoints = currentRoi.points;\n      let roiSign = Math.sign(currentRoi.id);\n      let currentRelated = correspondingRoisInformation(x, y, allPoints, roiMap, roiSign);\n      allRelated.push(currentRelated);\n    }\n\n    return allRelated;\n  }\n\n  _assertLayerWithLabel(label) {\n    if (!this._layers[label]) {\n      throw new Error(`no layer with label ${label}`);\n    }\n  }\n\n}\n/**\n * For a given ROI, find corresponding ROIs and properties in given ROIMap.\n * Returns an object containing the ID of ROIs, the surface shared by given and corresponding ROIs,\n * the percentage of given ROI surface covered by the corresponding ROI, the number of points with same and opposite signs,\n * the total number of points (same and opposite).\n * @param {number} x - minX value of ROI\n * @param {number} y - minY value of ROI\n * @param {Array<Array<number>>} points - points of ROI\n * @param {Array<number>} roiMap - roiMap from which we get the corresponding ROI\n * @param {number} roiSign - sign of ROI\n * @return {object} {{id: Array, surface: Array, roiSurfaceCovered: Array, same: number, opposite: number, total: number}}\n * @private\n */\n\nfunction correspondingRoisInformation(x, y, points, roiMap, roiSign) {\n  let correspondingRois = {\n    id: [],\n    surface: [],\n    roiSurfaceCovered: [],\n    same: 0,\n    opposite: 0,\n    total: 0\n  };\n\n  for (let i = 0; i < points.length; i++) {\n    let currentPoint = points[i];\n    let currentX = currentPoint[0];\n    let currentY = currentPoint[1];\n    let correspondingRoiMapIndex = currentX + x + (currentY + y) * roiMap.width;\n    let value = roiMap.data[correspondingRoiMapIndex];\n\n    if (value > 0 || value < 0) {\n      if (correspondingRois.id.includes(value)) {\n        correspondingRois.surface[correspondingRois.id.indexOf(value)] += 1;\n      } else {\n        correspondingRois.id.push(value);\n        correspondingRois.surface.push(1);\n      }\n    }\n  }\n\n  for (let i = 0; i < correspondingRois.id.length; i++) {\n    let currentSign = Math.sign(correspondingRois.id[i]);\n\n    if (currentSign === roiSign) {\n      correspondingRois.same += correspondingRois.surface[i];\n    } else {\n      correspondingRois.opposite += correspondingRois.surface[i];\n    }\n\n    correspondingRois.roiSurfaceCovered[i] = correspondingRois.surface[i] / points.length;\n  }\n\n  correspondingRois.total = correspondingRois.opposite + correspondingRois.same;\n  return correspondingRois;\n}","map":{"version":3,"sources":["C:/Users/kuent/Documents/FinishDipshit/Creative/Ocean-Weather-Visualization/node_modules/image-js/src/image/roi/manager.js"],"names":["deepValue","Qty","Image","RoiLayer","RoiMap","fromMask","fromMaskConnectedComponentLabelingAlgorithm","fromMaxima","fromPoints","fromWaterShed","RoiManager","constructor","image","options","_image","_options","label","_layers","_painted","opt","Object","assign","roiMap","call","points","putMap","map","mask","getMap","_assertLayerWithLabel","rowsInfo","colsInfo","getRoiIds","rois","getRois","ids","Array","length","i","id","Error","positive","negative","minSurface","maxSurface","Number","POSITIVE_INFINITY","minWidth","maxWidth","minHeight","maxHeight","minRatio","maxRatio","allRois","roi","surface","width","height","ratio","push","getRoi","roiId","find","getMasks","masks","getMask","getAnalysisMasks","analysisProperty","maskProperty","getData","data","paint","labelProperty","rgba8","labels","max","Math","isSurface","isDistance","includes","match","isFinite","unitLabel","unit","pixelSize","siLabel","factor","convert","swiftConverter","value","number","round","toFixed","labelsPosition","meanX","meanY","paintMasks","analysisMasks","color","analysisColor","alpha","analysisAlpha","kind","x","y","getBitXY","setBitXY","position","resetPainted","mergeRoi","mergeRois","roiIds","isArray","some","isInteger","Set","size","forEach","findCorrespondingRoi","allRelated","currentRoi","minX","minY","allPoints","roiSign","sign","currentRelated","correspondingRoisInformation","correspondingRois","roiSurfaceCovered","same","opposite","total","currentPoint","currentX","currentY","correspondingRoiMapIndex","indexOf","currentSign"],"mappings":"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","sourcesContent":["import deepValue from '../../util/deepValue';\nimport Qty from 'js-quantities';\n\nimport Image from '../Image';\n\nimport RoiLayer from './RoiLayer';\nimport RoiMap from './RoiMap';\nimport fromMask from './creator/fromMask';\nimport fromMaskConnectedComponentLabelingAlgorithm from './creator/fromMaskConnectedComponentLabelingAlgorithm';\nimport fromMaxima from './creator/fromMaxima';\nimport fromPoints from './creator/fromPoints';\nimport fromWaterShed from './creator/fromWaterShed';\n\n/**\n * A manager of Regions of Interest. A RoiManager is related to a specific Image\n * and may contain multiple layers. Each layer is characterized by a label whose is\n * name by default 'default'\n * @class RoiManager\n * @param {Image} image\n * @param {object} [options]\n */\nexport default class RoiManager {\n  constructor(image, options = {}) {\n    this._image = image;\n    this._options = options;\n    if (!this._options.label) {\n      this._options.label = 'default';\n    }\n    this._layers = {};\n    this._painted = null;\n  }\n\n  // docs is in the corresponding file\n  fromMaxima(options = {}) {\n    let opt = Object.assign({}, this._options, options);\n    let roiMap = fromMaxima.call(this._image, options);\n    this._layers[opt.label] = new RoiLayer(roiMap, opt);\n  }\n\n  // docs is in the corresponding file\n  fromPoints(points, options = {}) {\n    let opt = Object.assign({}, this._options, options);\n    let roiMap = fromPoints.call(this._image, points, options);\n    this._layers[opt.label] = new RoiLayer(roiMap, opt);\n    return this;\n  }\n\n  /**\n   * @param {number[]} map\n   * @param {object} [options]\n   * @return {this}\n   */\n  putMap(map, options = {}) {\n    let roiMap = new RoiMap(this._image, map);\n    let opt = Object.assign({}, this._options, options);\n    this._layers[opt.label] = new RoiLayer(roiMap, opt);\n    return this;\n  }\n\n  // docs is in the corresponding file\n  fromWaterShed(options = {}) {\n    let opt = Object.assign({}, this._options, options);\n    let roiMap = fromWaterShed.call(this._image, options);\n    this._layers[opt.label] = new RoiLayer(roiMap, opt);\n  }\n\n  // docs is in the corresponding file\n  fromMask(mask, options = {}) {\n    let opt = Object.assign({}, this._options, options);\n    let roiMap = fromMask.call(this._image, mask, options);\n    this._layers[opt.label] = new RoiLayer(roiMap, opt);\n    return this;\n  }\n\n  fromMaskConnectedComponentLabelingAlgorithm(mask, options = {}) {\n    let opt = Object.assign({}, this._options, options);\n    let roiMap = fromMaskConnectedComponentLabelingAlgorithm.call(\n      this._image,\n      mask,\n      options,\n    );\n    this._layers[opt.label] = new RoiLayer(roiMap, opt);\n    return this;\n  }\n\n  /**\n   *\n   * @param {object} [options]\n   * @return {RoiMap}\n   */\n  getMap(options = {}) {\n    let opt = Object.assign({}, this._options, options);\n    this._assertLayerWithLabel(opt.label);\n    return this._layers[opt.label].roiMap;\n  }\n\n  /**\n   * Return statistics about rows\n   * @param {object} [options]\n   * @return {object[]}\n   */\n  rowsInfo(options = {}) {\n    return this.getMap(options).rowsInfo();\n  }\n\n  /**\n   * Return statistics about columns\n   * @param {object} [options]\n   * @return {object[]}\n   */\n  colsInfo(options = {}) {\n    return this.getMap(options).rowsInfo();\n  }\n\n  /**\n   * Return the IDs of the Regions Of Interest (Roi) as an array of number\n   * @param {object} [options]\n   * @return {number[]}\n   */\n  getRoiIds(options = {}) {\n    let rois = this.getRois(options);\n    if (rois) {\n      let ids = new Array(rois.length);\n      for (let i = 0; i < rois.length; i++) {\n        ids[i] = rois[i].id;\n      }\n      return ids;\n    }\n    throw new Error('ROIs not found');\n  }\n\n  /**\n   * Allows to select ROI based on size, label and sign.\n   * @param {object} [options={}]\n   * @param {string} [options.label='default'] Label of the layer containing the ROI\n   * @param {boolean} [options.positive=true] Select the positive region of interest\n   * @param {boolean} [options.negative=true] Select he negative region of interest\n   * @param {number} [options.minSurface=0]\n   * @param {number} [options.maxSurface=Number.POSITIVE_INFINITY]\n   * @param {number} [options.minWidth=0]\n   * @param {number} [options.minHeight=Number.POSITIVE_INFINITY]\n   * @param {number} [options.maxWidth=0]\n   * @param {number} [options.maxHeight=Number.POSITIVE_INFINITY]\n   * @param {number} [options.minRatio=0] Ratio width / height\n   * @param {number} [options.maxRatio=Number.POSITIVE_INFINITY]\n   * @return {Roi[]}\n   */\n  getRois(options = {}) {\n    let {\n      label = this._options.label,\n      positive = true,\n      negative = true,\n      minSurface = 0,\n      maxSurface = Number.POSITIVE_INFINITY,\n      minWidth = 0,\n      maxWidth = Number.POSITIVE_INFINITY,\n      minHeight = 0,\n      maxHeight = Number.POSITIVE_INFINITY,\n      minRatio = 0,\n      maxRatio = Number.POSITIVE_INFINITY,\n    } = options;\n\n    if (!this._layers[label]) {\n      throw new Error(`this Roi layer (${label}) does not exist`);\n    }\n\n    const allRois = this._layers[label].roi;\n\n    const rois = [];\n    for (const roi of allRois) {\n      if (\n        ((roi.id < 0 && negative) || (roi.id > 0 && positive)) &&\n        roi.surface >= minSurface &&\n        roi.surface <= maxSurface &&\n        roi.width >= minWidth &&\n        roi.width <= maxWidth &&\n        roi.height >= minHeight &&\n        roi.height <= maxHeight &&\n        roi.ratio >= minRatio &&\n        roi.ratio <= maxRatio\n      ) {\n        rois.push(roi);\n      }\n    }\n    return rois;\n  }\n\n  /**\n   * Get an ROI by its id.\n   * @param {number} roiId\n   * @param {object} [options={}]\n   * @param {string} [options.label='default'] Label of the layer containing the ROI\n   * @return {Roi}\n   */\n  getRoi(roiId, options = {}) {\n    const { label = this._options.label } = options;\n\n    if (!this._layers[label]) {\n      throw new Error(`this Roi layer (${label}) does not exist`);\n    }\n\n    const roi = this._layers[label].roi.find((roi) => roi.id === roiId);\n    if (!roi) {\n      throw new Error(`found no Roi with id ${roiId}`);\n    }\n\n    return roi;\n  }\n\n  /**\n   * Returns an array of masks\n   * See {@link Roi.getMask} for the options\n   * @param {object} [options]\n   * @return {Image[]} Retuns an array of masks (1 bit Image)\n   */\n  getMasks(options = {}) {\n    let rois = this.getRois(options);\n\n    let masks = new Array(rois.length);\n    for (let i = 0; i < rois.length; i++) {\n      masks[i] = rois[i].getMask(options);\n    }\n    return masks;\n  }\n\n  /**\n   * Returns an array of masks\n   * See {@link Roi.getAnalysisMasks} for the options\n   * @param {object} [options]\n   * @return {Image[]} Retuns an array of masks (1 bit Image)\n   */\n  getAnalysisMasks(options = {}) {\n    const { analysisProperty } = options;\n    let maskProperty = `${analysisProperty}Mask`;\n    let rois = this.getRois(options);\n\n    if (rois.length === 0 || !rois[0][maskProperty]) return [];\n    return rois.map((roi) => roi[maskProperty]);\n  }\n\n  /**\n   *\n   * @param {object} [options]\n   * @return {number[]}\n   */\n  getData(options = {}) {\n    let opt = Object.assign({}, this._options, options);\n    this._assertLayerWithLabel(opt.label);\n    return this._layers[opt.label].roiMap.data;\n  }\n\n  /**\n   * Paint the ROI on a copy of the image and return this image.\n   * For painting options {@link Image.paintMasks}\n   * For ROI selection options, see {@link RoiManager.getMasks}\n   * @param {object} [options] - all the options to select ROIs\n   * @param {string} [options.labelProperty] - Paint a mask property on the image.\n   *                                  May be any property of the ROI like\n   *                                  for example id, surface, width, height, meanX, meanY.\n   * @param {number} [options.pixelSize] Size of a pixel in SI\n   * @param {string} [options.unit=\"pixel\"] Unit in which to display the values\n   * @return {Image} - The painted RGBA 8 bits image\n   */\n  paint(options = {}) {\n    let { labelProperty, analysisProperty } = options;\n\n    if (!this._painted) {\n      this._painted = this._image.rgba8();\n    }\n    let masks = this.getMasks(options);\n\n    if (labelProperty) {\n      const rois = this.getRois(options);\n      options.labels = rois.map((roi) => deepValue(roi, labelProperty));\n      const max = Math.max(...options.labels);\n\n      let isSurface = false;\n      let isDistance = false;\n      if (labelProperty.includes('surface')) {\n        isSurface = true;\n      } else if (\n        labelProperty.match(/(perimeter|min|max|external|width|height|length)/)\n      ) {\n        isDistance = true;\n      }\n\n      if (isFinite(max)) {\n        let unitLabel = '';\n        if (\n          options.unit !== 'pixel' &&\n          options.pixelSize &&\n          (isDistance || isSurface)\n        ) {\n          unitLabel = isSurface ? `${options.unit}^2` : options.unit;\n          let siLabel = isSurface ? 'm^2' : 'm';\n          let factor = isSurface ? options.pixelSize ** 2 : options.pixelSize;\n          const convert = Qty.swiftConverter(siLabel, unitLabel);\n          options.labels = options.labels.map((value) => {\n            return convert(factor * value);\n          });\n        }\n\n        if (max > 50) {\n          options.labels = options.labels.map(\n            (number) => Math.round(number) + unitLabel,\n          );\n        } else if (max > 10) {\n          options.labels = options.labels.map(\n            (number) => number.toFixed(1) + unitLabel,\n          );\n        } else {\n          options.labels = options.labels.map(\n            (number) => number.toFixed(2) + unitLabel,\n          );\n        }\n      }\n      options.labelsPosition = rois.map((roi) => [roi.meanX, roi.meanY]);\n    }\n\n    this._painted.paintMasks(masks, options);\n\n    if (analysisProperty) {\n      let analysisMasks = this.getAnalysisMasks(options);\n\n      this._painted.paintMasks(analysisMasks, {\n        color: options.analysisColor,\n        alpha: options.analysisAlpha,\n      });\n    }\n\n    return this._painted;\n  }\n\n  // return a mask corresponding to all the selected masks\n  getMask(options = {}) {\n    let mask = new Image(this._image.width, this._image.height, {\n      kind: 'BINARY',\n    });\n    let masks = this.getMasks(options);\n\n    for (let i = 0; i < masks.length; i++) {\n      let roi = masks[i];\n      // we need to find the parent image to calculate the relative position\n\n      for (let x = 0; x < roi.width; x++) {\n        for (let y = 0; y < roi.height; y++) {\n          if (roi.getBitXY(x, y)) {\n            mask.setBitXY(x + roi.position[0], y + roi.position[1]);\n          }\n        }\n      }\n    }\n    return mask;\n  }\n\n  /**\n   * Reset the changes to the current painted iamge to the image that was\n   * used during the creation of the RoiManager except if a new image is\n   * specified as parameter;\n   * @param {object} [options]\n   * @param {Image} [options.image] A new iamge that you would like to sue for painting over\n   */\n  resetPainted(options = {}) {\n    const { image } = options;\n    if (image) {\n      this._painted = this.image.rgba8();\n    } else {\n      this._painted = this._image.rgba8();\n    }\n  }\n\n  /**\n   * In place modification of the roiMap that joins regions of interest\n   * @param {object} [options]\n   * @param {string|function(object,number,number)} [options.algorithm='commonBorderLength'] algorithm used to decide which ROIs are merged.\n   *      Current implemented algorithms are 'commonBorderLength' that use the parameters\n   *      'minCommonBorderLength' and 'maxCommonBorderLength' as well as 'commonBorderRatio' that uses\n   *      the parameters 'minCommonBorderRatio' and 'maxCommonBorderRatio'.\n   * @param {number} [options.minCommonBorderLength=5] minimal common number of pixels for merging\n   * @param {number} [options.maxCommonBorderLength=100] maximal common number of pixels for merging\n   * @param {number} [options.minCommonBorderRatio=0.3] minimal common border ratio for merging\n   * @param {number} [options.maxCommonBorderRatio=1] maximal common border ratio for merging\n   * @return {this}\n   */\n  mergeRoi(options = {}) {\n    const roiMap = this.getMap(options);\n    roiMap.mergeRoi(options);\n    this.putMap(roiMap.data, options);\n    return this;\n  }\n\n  /**\n   * Merge multiple rois into one.\n   * All rois in the provided array will be merged into the first one.\n   * @param {Array<number>} roiIds - A list of Roi ids to merge\n   * @param {object} [options]\n   */\n  mergeRois(roiIds, options = {}) {\n    if (!Array.isArray(roiIds) || roiIds.some((id) => !Number.isInteger(id))) {\n      throw new Error('Roi ids must be an array of integers');\n    }\n    if (roiIds.length < 2) {\n      throw new Error('Roi ids must have at least two elements');\n    }\n    if (new Set(roiIds).size !== roiIds.length) {\n      throw new Error('Roi ids must be all different');\n    }\n    // Throws if one of the ids is wrong\n    roiIds.forEach((roiId) => this.getRoi(roiId));\n\n    const roiMap = this.getMap(options);\n    roiMap.mergeRois(roiIds);\n    this.putMap(roiMap.data, options);\n    return this;\n  }\n\n  /**\n   * Finds all corresponding ROIs for all ROIs in the manager\n   * @param {number[]} roiMap\n   * @param {object} [options]\n   * @return {Array} array of objects returned in correspondingRoisInformation\n   */\n  findCorrespondingRoi(roiMap, options = {}) {\n    let allRois = this.getRois(options);\n    let allRelated = [];\n    for (let i = 0; i < allRois.length; i++) {\n      let currentRoi = allRois[i];\n      let x = currentRoi.minX;\n      let y = currentRoi.minY;\n      let allPoints = currentRoi.points;\n      let roiSign = Math.sign(currentRoi.id);\n      let currentRelated = correspondingRoisInformation(\n        x,\n        y,\n        allPoints,\n        roiMap,\n        roiSign,\n      );\n      allRelated.push(currentRelated);\n    }\n    return allRelated;\n  }\n\n  _assertLayerWithLabel(label) {\n    if (!this._layers[label]) {\n      throw new Error(`no layer with label ${label}`);\n    }\n  }\n}\n\n/**\n * For a given ROI, find corresponding ROIs and properties in given ROIMap.\n * Returns an object containing the ID of ROIs, the surface shared by given and corresponding ROIs,\n * the percentage of given ROI surface covered by the corresponding ROI, the number of points with same and opposite signs,\n * the total number of points (same and opposite).\n * @param {number} x - minX value of ROI\n * @param {number} y - minY value of ROI\n * @param {Array<Array<number>>} points - points of ROI\n * @param {Array<number>} roiMap - roiMap from which we get the corresponding ROI\n * @param {number} roiSign - sign of ROI\n * @return {object} {{id: Array, surface: Array, roiSurfaceCovered: Array, same: number, opposite: number, total: number}}\n * @private\n */\nfunction correspondingRoisInformation(x, y, points, roiMap, roiSign) {\n  let correspondingRois = {\n    id: [],\n    surface: [],\n    roiSurfaceCovered: [],\n    same: 0,\n    opposite: 0,\n    total: 0,\n  };\n  for (let i = 0; i < points.length; i++) {\n    let currentPoint = points[i];\n    let currentX = currentPoint[0];\n    let currentY = currentPoint[1];\n    let correspondingRoiMapIndex = currentX + x + (currentY + y) * roiMap.width;\n    let value = roiMap.data[correspondingRoiMapIndex];\n\n    if (value > 0 || value < 0) {\n      if (correspondingRois.id.includes(value)) {\n        correspondingRois.surface[correspondingRois.id.indexOf(value)] += 1;\n      } else {\n        correspondingRois.id.push(value);\n        correspondingRois.surface.push(1);\n      }\n    }\n  }\n\n  for (let i = 0; i < correspondingRois.id.length; i++) {\n    let currentSign = Math.sign(correspondingRois.id[i]);\n    if (currentSign === roiSign) {\n      correspondingRois.same += correspondingRois.surface[i];\n    } else {\n      correspondingRois.opposite += correspondingRois.surface[i];\n    }\n    correspondingRois.roiSurfaceCovered[i] =\n      correspondingRois.surface[i] / points.length;\n  }\n  correspondingRois.total = correspondingRois.opposite + correspondingRois.same;\n\n  return correspondingRois;\n}\n"]},"metadata":{},"sourceType":"module"}