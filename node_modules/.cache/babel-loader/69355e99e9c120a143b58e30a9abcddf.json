{"ast":null,"code":"/**\n * Finds common parent between two different masks\n * @memberof Image\n * @instance\n * @param {Image} mask - a mask (1 bit image)\n * @return {Image} - the lowest common parent of both masks\n */\nexport default function getClosestCommonParent(mask) {\n  let depthMask1 = getDepth(this);\n  let depthMask2 = getDepth(mask);\n  let furthestParent;\n\n  if (depthMask1 >= depthMask2) {\n    furthestParent = getFurthestParent(this, depthMask1);\n  } else {\n    furthestParent = getFurthestParent(mask, depthMask2);\n  }\n\n  if (depthMask1 === 0 || depthMask2 === 0) {\n    // comparing with at least one original image -> no common parent\n    return furthestParent;\n  }\n\n  let m1 = this;\n  let m2 = mask;\n\n  while (depthMask1 !== depthMask2) {\n    if (depthMask1 > depthMask2) {\n      m1 = m1.parent;\n\n      if (m1 === null) {\n        return furthestParent;\n      }\n\n      depthMask1 = depthMask1 - 1;\n    } else {\n      m2 = m2.parent;\n\n      if (m2 === null) {\n        return furthestParent;\n      }\n\n      depthMask2 = depthMask2 - 1;\n    }\n  }\n\n  while (m1 !== m2 && m1 !== null && m2 !== null) {\n    m1 = m1.parent;\n    m2 = m2.parent;\n\n    if (m1 === null || m2 === null) {\n      return furthestParent;\n    }\n  } // TODO\n  // no common parent, use parent at top of hierarchy of m1\n  // we assume it works for now\n\n\n  if (m1 !== m2) {\n    return furthestParent;\n  }\n\n  return m1;\n}\n/**\n * Find the depth of the mask with respect to its arborescence.\n * Helper function to find the common parent between two masks.\n * @param {Image} mask - a mask (1 bit Image)\n * @return {number} - depth of mask\n * @private\n */\n\nfunction getDepth(mask) {\n  let d = 0;\n  let m = mask; // a null parent means it's the original image\n\n  while (m.parent != null) {\n    m = m.parent;\n    d++;\n  }\n\n  return d;\n}\n\nfunction getFurthestParent(mask, depth) {\n  let m = mask;\n\n  while (depth > 0) {\n    m = m.parent;\n    depth = depth - 1;\n  }\n\n  return m;\n}","map":{"version":3,"sources":["C:/Users/kuent/Documents/FinishDipshit/Creative/Ocean-Weather-Visualization/node_modules/image-js/src/image/utility/getClosestCommonParent.js"],"names":["getClosestCommonParent","mask","depthMask1","getDepth","depthMask2","furthestParent","getFurthestParent","m1","m2","parent","d","m","depth"],"mappings":"AAAA;;;;;;;AAOA,eAAe,SAASA,sBAAT,CAAgCC,IAAhC,EAAsC;AACnD,MAAIC,UAAU,GAAGC,QAAQ,CAAC,IAAD,CAAzB;AACA,MAAIC,UAAU,GAAGD,QAAQ,CAACF,IAAD,CAAzB;AAEA,MAAII,cAAJ;;AACA,MAAIH,UAAU,IAAIE,UAAlB,EAA8B;AAC5BC,IAAAA,cAAc,GAAGC,iBAAiB,CAAC,IAAD,EAAOJ,UAAP,CAAlC;AACD,GAFD,MAEO;AACLG,IAAAA,cAAc,GAAGC,iBAAiB,CAACL,IAAD,EAAOG,UAAP,CAAlC;AACD;;AAED,MAAIF,UAAU,KAAK,CAAf,IAAoBE,UAAU,KAAK,CAAvC,EAA0C;AACxC;AACA,WAAOC,cAAP;AACD;;AACD,MAAIE,EAAE,GAAG,IAAT;AACA,MAAIC,EAAE,GAAGP,IAAT;;AAEA,SAAOC,UAAU,KAAKE,UAAtB,EAAkC;AAChC,QAAIF,UAAU,GAAGE,UAAjB,EAA6B;AAC3BG,MAAAA,EAAE,GAAGA,EAAE,CAACE,MAAR;;AACA,UAAIF,EAAE,KAAK,IAAX,EAAiB;AACf,eAAOF,cAAP;AACD;;AACDH,MAAAA,UAAU,GAAGA,UAAU,GAAG,CAA1B;AACD,KAND,MAMO;AACLM,MAAAA,EAAE,GAAGA,EAAE,CAACC,MAAR;;AACA,UAAID,EAAE,KAAK,IAAX,EAAiB;AACf,eAAOH,cAAP;AACD;;AACDD,MAAAA,UAAU,GAAGA,UAAU,GAAG,CAA1B;AACD;AACF;;AAED,SAAOG,EAAE,KAAKC,EAAP,IAAaD,EAAE,KAAK,IAApB,IAA4BC,EAAE,KAAK,IAA1C,EAAgD;AAC9CD,IAAAA,EAAE,GAAGA,EAAE,CAACE,MAAR;AACAD,IAAAA,EAAE,GAAGA,EAAE,CAACC,MAAR;;AACA,QAAIF,EAAE,KAAK,IAAP,IAAeC,EAAE,KAAK,IAA1B,EAAgC;AAC9B,aAAOH,cAAP;AACD;AACF,GAxCkD,CA0CnD;AACA;AACA;;;AACA,MAAIE,EAAE,KAAKC,EAAX,EAAe;AACb,WAAOH,cAAP;AACD;;AAED,SAAOE,EAAP;AACD;AAED;;;;;;;;AAOA,SAASJ,QAAT,CAAkBF,IAAlB,EAAwB;AACtB,MAAIS,CAAC,GAAG,CAAR;AACA,MAAIC,CAAC,GAAGV,IAAR,CAFsB,CAGtB;;AACA,SAAOU,CAAC,CAACF,MAAF,IAAY,IAAnB,EAAyB;AACvBE,IAAAA,CAAC,GAAGA,CAAC,CAACF,MAAN;AACAC,IAAAA,CAAC;AACF;;AACD,SAAOA,CAAP;AACD;;AAED,SAASJ,iBAAT,CAA2BL,IAA3B,EAAiCW,KAAjC,EAAwC;AACtC,MAAID,CAAC,GAAGV,IAAR;;AACA,SAAOW,KAAK,GAAG,CAAf,EAAkB;AAChBD,IAAAA,CAAC,GAAGA,CAAC,CAACF,MAAN;AACAG,IAAAA,KAAK,GAAGA,KAAK,GAAG,CAAhB;AACD;;AACD,SAAOD,CAAP;AACD","sourcesContent":["/**\n * Finds common parent between two different masks\n * @memberof Image\n * @instance\n * @param {Image} mask - a mask (1 bit image)\n * @return {Image} - the lowest common parent of both masks\n */\nexport default function getClosestCommonParent(mask) {\n  let depthMask1 = getDepth(this);\n  let depthMask2 = getDepth(mask);\n\n  let furthestParent;\n  if (depthMask1 >= depthMask2) {\n    furthestParent = getFurthestParent(this, depthMask1);\n  } else {\n    furthestParent = getFurthestParent(mask, depthMask2);\n  }\n\n  if (depthMask1 === 0 || depthMask2 === 0) {\n    // comparing with at least one original image -> no common parent\n    return furthestParent;\n  }\n  let m1 = this;\n  let m2 = mask;\n\n  while (depthMask1 !== depthMask2) {\n    if (depthMask1 > depthMask2) {\n      m1 = m1.parent;\n      if (m1 === null) {\n        return furthestParent;\n      }\n      depthMask1 = depthMask1 - 1;\n    } else {\n      m2 = m2.parent;\n      if (m2 === null) {\n        return furthestParent;\n      }\n      depthMask2 = depthMask2 - 1;\n    }\n  }\n\n  while (m1 !== m2 && m1 !== null && m2 !== null) {\n    m1 = m1.parent;\n    m2 = m2.parent;\n    if (m1 === null || m2 === null) {\n      return furthestParent;\n    }\n  }\n\n  // TODO\n  // no common parent, use parent at top of hierarchy of m1\n  // we assume it works for now\n  if (m1 !== m2) {\n    return furthestParent;\n  }\n\n  return m1;\n}\n\n/**\n * Find the depth of the mask with respect to its arborescence.\n * Helper function to find the common parent between two masks.\n * @param {Image} mask - a mask (1 bit Image)\n * @return {number} - depth of mask\n * @private\n */\nfunction getDepth(mask) {\n  let d = 0;\n  let m = mask;\n  // a null parent means it's the original image\n  while (m.parent != null) {\n    m = m.parent;\n    d++;\n  }\n  return d;\n}\n\nfunction getFurthestParent(mask, depth) {\n  let m = mask;\n  while (depth > 0) {\n    m = m.parent;\n    depth = depth - 1;\n  }\n  return m;\n}\n"]},"metadata":{},"sourceType":"module"}