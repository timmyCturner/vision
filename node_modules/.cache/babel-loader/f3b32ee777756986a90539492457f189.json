{"ast":null,"code":"/**\n * Crops the image based on the alpha channel\n * This removes lines and columns where the alpha channel is lower than a threshold value.\n * @memberof Image\n * @instance\n * @param {object} [options]\n * @param {number} [options.threshold=this.maxValue]\n * @return {Image}\n */\nexport default function cropAlpha(options = {}) {\n  this.checkProcessable('cropAlpha', {\n    alpha: 1\n  });\n  const {\n    threshold = this.maxValue\n  } = options;\n  let left = findLeft(this, threshold, this.components);\n\n  if (left === -1) {\n    throw new Error('Could not find new dimensions. Threshold may be too high.');\n  }\n\n  let top = findTop(this, threshold, this.components, left);\n  let bottom = findBottom(this, threshold, this.components, left);\n  let right = findRight(this, threshold, this.components, left, top, bottom);\n  return this.crop({\n    x: left,\n    y: top,\n    width: right - left + 1,\n    height: bottom - top + 1\n  });\n}\n\nfunction findLeft(image, threshold, channel) {\n  for (let x = 0; x < image.width; x++) {\n    for (let y = 0; y < image.height; y++) {\n      if (image.getValueXY(x, y, channel) >= threshold) {\n        return x;\n      }\n    }\n  }\n\n  return -1;\n}\n\nfunction findTop(image, threshold, channel, left) {\n  for (let y = 0; y < image.height; y++) {\n    for (let x = left; x < image.width; x++) {\n      if (image.getValueXY(x, y, channel) >= threshold) {\n        return y;\n      }\n    }\n  }\n\n  return -1;\n}\n\nfunction findBottom(image, threshold, channel, left) {\n  for (let y = image.height - 1; y >= 0; y--) {\n    for (let x = left; x < image.width; x++) {\n      if (image.getValueXY(x, y, channel) >= threshold) {\n        return y;\n      }\n    }\n  }\n\n  return -1;\n}\n\nfunction findRight(image, threshold, channel, left, top, bottom) {\n  for (let x = image.width - 1; x >= left; x--) {\n    for (let y = top; y <= bottom; y++) {\n      if (image.getValueXY(x, y, channel) >= threshold) {\n        return x;\n      }\n    }\n  }\n\n  return -1;\n}","map":{"version":3,"sources":["C:/Users/kuent/Documents/FinishDipshit/Creative/Ocean-Weather-Visualization/node_modules/image-js/src/image/transform/cropAlpha.js"],"names":["cropAlpha","options","checkProcessable","alpha","threshold","maxValue","left","findLeft","components","Error","top","findTop","bottom","findBottom","right","findRight","crop","x","y","width","height","image","channel","getValueXY"],"mappings":"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","sourcesContent":["/**\n * Crops the image based on the alpha channel\n * This removes lines and columns where the alpha channel is lower than a threshold value.\n * @memberof Image\n * @instance\n * @param {object} [options]\n * @param {number} [options.threshold=this.maxValue]\n * @return {Image}\n */\nexport default function cropAlpha(options = {}) {\n  this.checkProcessable('cropAlpha', {\n    alpha: 1,\n  });\n\n  const { threshold = this.maxValue } = options;\n\n  let left = findLeft(this, threshold, this.components);\n\n  if (left === -1) {\n    throw new Error(\n      'Could not find new dimensions. Threshold may be too high.',\n    );\n  }\n\n  let top = findTop(this, threshold, this.components, left);\n  let bottom = findBottom(this, threshold, this.components, left);\n  let right = findRight(this, threshold, this.components, left, top, bottom);\n\n  return this.crop({\n    x: left,\n    y: top,\n    width: right - left + 1,\n    height: bottom - top + 1,\n  });\n}\n\nfunction findLeft(image, threshold, channel) {\n  for (let x = 0; x < image.width; x++) {\n    for (let y = 0; y < image.height; y++) {\n      if (image.getValueXY(x, y, channel) >= threshold) {\n        return x;\n      }\n    }\n  }\n  return -1;\n}\n\nfunction findTop(image, threshold, channel, left) {\n  for (let y = 0; y < image.height; y++) {\n    for (let x = left; x < image.width; x++) {\n      if (image.getValueXY(x, y, channel) >= threshold) {\n        return y;\n      }\n    }\n  }\n  return -1;\n}\n\nfunction findBottom(image, threshold, channel, left) {\n  for (let y = image.height - 1; y >= 0; y--) {\n    for (let x = left; x < image.width; x++) {\n      if (image.getValueXY(x, y, channel) >= threshold) {\n        return y;\n      }\n    }\n  }\n  return -1;\n}\n\nfunction findRight(image, threshold, channel, left, top, bottom) {\n  for (let x = image.width - 1; x >= left; x--) {\n    for (let y = top; y <= bottom; y++) {\n      if (image.getValueXY(x, y, channel) >= threshold) {\n        return x;\n      }\n    }\n  }\n  return -1;\n}\n"]},"metadata":{},"sourceType":"module"}