{"ast":null,"code":"import { validateArrayOfChannels } from '../../util/channel';\nimport Image from '../Image';\n/**\n * Calculate a new image that is the subtraction between the current image and the otherImage.\n * @memberof Image\n * @instance\n * @param {Image} otherImage\n * @param {object} [options={}]\n * @param {number} [options.bitDepth=this.bitDepth]\n * @param {number[]|string[]} [options.channels] : to which channel to apply the filter. By default all but alpha.\n * @param {number[]|string[]} [options.absolute=false] :.take the absolute value of the difference (default minimum=0)\n * @return {Image}\n */\n\nexport default function subtractImage(otherImage, options = {}) {\n  let {\n    bitDepth = this.bitDepth,\n    channels,\n    absolute = false\n  } = options;\n  this.checkProcessable('subtractImage', {\n    bitDepth: [8, 16]\n  });\n\n  if (this.width !== otherImage.width || this.height !== otherImage.height) {\n    throw new Error('subtractImage: both images must have the same size');\n  }\n\n  if (this.alpha !== otherImage.alpha || this.bitDepth !== otherImage.bitDepth) {\n    throw new Error('subtractImage: both images must have the same alpha and bitDepth');\n  }\n\n  if (this.channels !== otherImage.channels) {\n    throw new Error('subtractImage: both images must have the same number of channels');\n  }\n\n  let newImage = Image.createFrom(this, {\n    bitDepth: bitDepth\n  });\n  channels = validateArrayOfChannels(this, {\n    channels: channels\n  });\n\n  for (let j = 0; j < channels.length; j++) {\n    let c = channels[j];\n\n    for (let i = c; i < this.data.length; i += this.channels) {\n      let value = this.data[i] - otherImage.data[i];\n\n      if (absolute) {\n        newImage.data[i] = Math.abs(value);\n      } else {\n        newImage.data[i] = Math.max(value, 0);\n      }\n    }\n  }\n\n  return newImage;\n}","map":{"version":3,"sources":["C:/Users/kuent/Documents/FinishDipshit/Creative/Ocean-Weather-Visualization/node_modules/image-js/src/image/filter/subtractImage.js"],"names":["validateArrayOfChannels","Image","subtractImage","otherImage","options","bitDepth","channels","absolute","checkProcessable","width","height","Error","alpha","newImage","createFrom","j","length","c","i","data","value","Math","abs","max"],"mappings":"AAAA,SAASA,uBAAT,QAAwC,oBAAxC;AACA,OAAOC,KAAP,MAAkB,UAAlB;AAEA;;;;;;;;;;;;AAWA,eAAe,SAASC,aAAT,CAAuBC,UAAvB,EAAmCC,OAAO,GAAG,EAA7C,EAAiD;AAC9D,MAAI;AAAEC,IAAAA,QAAQ,GAAG,KAAKA,QAAlB;AAA4BC,IAAAA,QAA5B;AAAsCC,IAAAA,QAAQ,GAAG;AAAjD,MAA2DH,OAA/D;AACA,OAAKI,gBAAL,CAAsB,eAAtB,EAAuC;AACrCH,IAAAA,QAAQ,EAAE,CAAC,CAAD,EAAI,EAAJ;AAD2B,GAAvC;;AAGA,MAAI,KAAKI,KAAL,KAAeN,UAAU,CAACM,KAA1B,IAAmC,KAAKC,MAAL,KAAgBP,UAAU,CAACO,MAAlE,EAA0E;AACxE,UAAM,IAAIC,KAAJ,CAAU,oDAAV,CAAN;AACD;;AACD,MACE,KAAKC,KAAL,KAAeT,UAAU,CAACS,KAA1B,IACA,KAAKP,QAAL,KAAkBF,UAAU,CAACE,QAF/B,EAGE;AACA,UAAM,IAAIM,KAAJ,CACJ,kEADI,CAAN;AAGD;;AACD,MAAI,KAAKL,QAAL,KAAkBH,UAAU,CAACG,QAAjC,EAA2C;AACzC,UAAM,IAAIK,KAAJ,CACJ,kEADI,CAAN;AAGD;;AAED,MAAIE,QAAQ,GAAGZ,KAAK,CAACa,UAAN,CAAiB,IAAjB,EAAuB;AAAET,IAAAA,QAAQ,EAAEA;AAAZ,GAAvB,CAAf;AAEAC,EAAAA,QAAQ,GAAGN,uBAAuB,CAAC,IAAD,EAAO;AAAEM,IAAAA,QAAQ,EAAEA;AAAZ,GAAP,CAAlC;;AAEA,OAAK,IAAIS,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGT,QAAQ,CAACU,MAA7B,EAAqCD,CAAC,EAAtC,EAA0C;AACxC,QAAIE,CAAC,GAAGX,QAAQ,CAACS,CAAD,CAAhB;;AACA,SAAK,IAAIG,CAAC,GAAGD,CAAb,EAAgBC,CAAC,GAAG,KAAKC,IAAL,CAAUH,MAA9B,EAAsCE,CAAC,IAAI,KAAKZ,QAAhD,EAA0D;AACxD,UAAIc,KAAK,GAAG,KAAKD,IAAL,CAAUD,CAAV,IAAef,UAAU,CAACgB,IAAX,CAAgBD,CAAhB,CAA3B;;AACA,UAAIX,QAAJ,EAAc;AACZM,QAAAA,QAAQ,CAACM,IAAT,CAAcD,CAAd,IAAmBG,IAAI,CAACC,GAAL,CAASF,KAAT,CAAnB;AACD,OAFD,MAEO;AACLP,QAAAA,QAAQ,CAACM,IAAT,CAAcD,CAAd,IAAmBG,IAAI,CAACE,GAAL,CAASH,KAAT,EAAgB,CAAhB,CAAnB;AACD;AACF;AACF;;AAED,SAAOP,QAAP;AACD","sourcesContent":["import { validateArrayOfChannels } from '../../util/channel';\nimport Image from '../Image';\n\n/**\n * Calculate a new image that is the subtraction between the current image and the otherImage.\n * @memberof Image\n * @instance\n * @param {Image} otherImage\n * @param {object} [options={}]\n * @param {number} [options.bitDepth=this.bitDepth]\n * @param {number[]|string[]} [options.channels] : to which channel to apply the filter. By default all but alpha.\n * @param {number[]|string[]} [options.absolute=false] :.take the absolute value of the difference (default minimum=0)\n * @return {Image}\n */\nexport default function subtractImage(otherImage, options = {}) {\n  let { bitDepth = this.bitDepth, channels, absolute = false } = options;\n  this.checkProcessable('subtractImage', {\n    bitDepth: [8, 16],\n  });\n  if (this.width !== otherImage.width || this.height !== otherImage.height) {\n    throw new Error('subtractImage: both images must have the same size');\n  }\n  if (\n    this.alpha !== otherImage.alpha ||\n    this.bitDepth !== otherImage.bitDepth\n  ) {\n    throw new Error(\n      'subtractImage: both images must have the same alpha and bitDepth',\n    );\n  }\n  if (this.channels !== otherImage.channels) {\n    throw new Error(\n      'subtractImage: both images must have the same number of channels',\n    );\n  }\n\n  let newImage = Image.createFrom(this, { bitDepth: bitDepth });\n\n  channels = validateArrayOfChannels(this, { channels: channels });\n\n  for (let j = 0; j < channels.length; j++) {\n    let c = channels[j];\n    for (let i = c; i < this.data.length; i += this.channels) {\n      let value = this.data[i] - otherImage.data[i];\n      if (absolute) {\n        newImage.data[i] = Math.abs(value);\n      } else {\n        newImage.data[i] = Math.max(value, 0);\n      }\n    }\n  }\n\n  return newImage;\n}\n"]},"metadata":{},"sourceType":"module"}