{"ast":null,"code":"/*\n * see http://rsb.info.nih.gov/ij/developer/source/ij/process/AutoThresholder.java.html\n * The method is present in: Implements Kapur-Sahoo-Wong (Maximum Entropy) thresholding method:\n * Kapur, JN; Sahoo, PK & Wong, ACK (1985), \"A New Method for Gray-Level Picture Thresholding Using the Entropy of the Histogram\",\n * Graphical Models and Image Processing 29(3): 273-285\n * @param histogram - the histogram of the image\n *        total - the number of pixels in the image\n * @returns {number} - the threshold\n */\nexport default function maxEntropy(histogram, total) {\n  let normHisto = new Array(histogram.length); // normalized histogram\n\n  for (let ih = 0; ih < histogram.length; ih++) {\n    normHisto[ih] = histogram[ih] / total;\n  }\n\n  let P1 = new Array(histogram.length); // cumulative normalized histogram\n\n  let P2 = new Array(histogram.length);\n  P1[0] = normHisto[0];\n  P2[0] = 1.0 - P1[0];\n\n  for (let ih = 1; ih < histogram.length; ih++) {\n    P1[ih] = P1[ih - 1] + normHisto[ih];\n    P2[ih] = 1.0 - P1[ih];\n  }\n  /* Determine the first non-zero bin */\n\n\n  let firstBin = 0;\n\n  for (let ih = 0; ih < histogram.length; ih++) {\n    if (Math.abs(P1[ih]) >= Number.EPSILON) {\n      firstBin = ih;\n      break;\n    }\n  }\n  /* Determine the last non-zero bin */\n\n\n  let lastBin = histogram.length - 1;\n\n  for (let ih = histogram.length - 1; ih >= firstBin; ih--) {\n    if (Math.abs(P2[ih]) >= Number.EPSILON) {\n      lastBin = ih;\n      break;\n    }\n  } // Calculate the total entropy each gray-level\n  // and find the threshold that maximizes it\n\n\n  let threshold = -1;\n  let totEnt; // total entropy\n\n  let maxEnt = Number.MIN_VALUE; // max entropy\n\n  let entBack; // entropy of the background pixels at a given threshold\n\n  let entObj; // entropy of the object pixels at a given threshold\n\n  for (let it = firstBin; it <= lastBin; it++) {\n    /* Entropy of the background pixels */\n    entBack = 0.0;\n\n    for (let ih = 0; ih <= it; ih++) {\n      if (histogram[ih] !== 0) {\n        entBack -= normHisto[ih] / P1[it] * Math.log(normHisto[ih] / P1[it]);\n      }\n    }\n    /* Entropy of the object pixels */\n\n\n    entObj = 0.0;\n\n    for (let ih = it + 1; ih < histogram.length; ih++) {\n      if (histogram[ih] !== 0) {\n        entObj -= normHisto[ih] / P2[it] * Math.log(normHisto[ih] / P2[it]);\n      }\n    }\n    /* Total entropy */\n\n\n    totEnt = entBack + entObj;\n\n    if (maxEnt < totEnt) {\n      maxEnt = totEnt;\n      threshold = it;\n    }\n  }\n\n  return threshold;\n}","map":{"version":3,"sources":["C:/Users/kuent/Documents/FinishDipshit/Creative/Ocean-Weather-Visualization/node_modules/image-js/src/image/transform/mask/maxEntropy.js"],"names":["maxEntropy","histogram","total","normHisto","Array","length","ih","P1","P2","firstBin","Math","abs","Number","EPSILON","lastBin","threshold","totEnt","maxEnt","MIN_VALUE","entBack","entObj","it","log"],"mappings":"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","sourcesContent":["/*\n * see http://rsb.info.nih.gov/ij/developer/source/ij/process/AutoThresholder.java.html\n * The method is present in: Implements Kapur-Sahoo-Wong (Maximum Entropy) thresholding method:\n * Kapur, JN; Sahoo, PK & Wong, ACK (1985), \"A New Method for Gray-Level Picture Thresholding Using the Entropy of the Histogram\",\n * Graphical Models and Image Processing 29(3): 273-285\n * @param histogram - the histogram of the image\n *        total - the number of pixels in the image\n * @returns {number} - the threshold\n */\n\nexport default function maxEntropy(histogram, total) {\n  let normHisto = new Array(histogram.length); // normalized histogram\n  for (let ih = 0; ih < histogram.length; ih++) {\n    normHisto[ih] = histogram[ih] / total;\n  }\n\n  let P1 = new Array(histogram.length); // cumulative normalized histogram\n  let P2 = new Array(histogram.length);\n  P1[0] = normHisto[0];\n  P2[0] = 1.0 - P1[0];\n\n  for (let ih = 1; ih < histogram.length; ih++) {\n    P1[ih] = P1[ih - 1] + normHisto[ih];\n    P2[ih] = 1.0 - P1[ih];\n  }\n\n  /* Determine the first non-zero bin */\n  let firstBin = 0;\n  for (let ih = 0; ih < histogram.length; ih++) {\n    if (Math.abs(P1[ih]) >= Number.EPSILON) {\n      firstBin = ih;\n      break;\n    }\n  }\n\n  /* Determine the last non-zero bin */\n  let lastBin = histogram.length - 1;\n  for (let ih = histogram.length - 1; ih >= firstBin; ih--) {\n    if (Math.abs(P2[ih]) >= Number.EPSILON) {\n      lastBin = ih;\n      break;\n    }\n  }\n\n  // Calculate the total entropy each gray-level\n  // and find the threshold that maximizes it\n  let threshold = -1;\n  let totEnt; // total entropy\n  let maxEnt = Number.MIN_VALUE; // max entropy\n  let entBack; // entropy of the background pixels at a given threshold\n  let entObj; // entropy of the object pixels at a given threshold\n\n  for (let it = firstBin; it <= lastBin; it++) {\n    /* Entropy of the background pixels */\n    entBack = 0.0;\n    for (let ih = 0; ih <= it; ih++) {\n      if (histogram[ih] !== 0) {\n        entBack -= (normHisto[ih] / P1[it]) * Math.log(normHisto[ih] / P1[it]);\n      }\n    }\n\n    /* Entropy of the object pixels */\n    entObj = 0.0;\n    for (let ih = it + 1; ih < histogram.length; ih++) {\n      if (histogram[ih] !== 0) {\n        entObj -= (normHisto[ih] / P2[it]) * Math.log(normHisto[ih] / P2[it]);\n      }\n    }\n\n    /* Total entropy */\n    totEnt = entBack + entObj;\n\n    if (maxEnt < totEnt) {\n      maxEnt = totEnt;\n      threshold = it;\n    }\n  }\n  return threshold;\n}\n"]},"metadata":{},"sourceType":"module"}