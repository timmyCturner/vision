{"ast":null,"code":"'use strict';\n\nconst utf8 = require('utf8');\n\nconst defaultByteLength = 1024 * 8;\nconst charArray = [];\n/**\n * IOBuffer\n * @constructor\n * @param {undefined|number|ArrayBuffer|TypedArray|IOBuffer|Buffer} data - The data to construct the IOBuffer with.\n *\n * If it's a number, it will initialize the buffer with the number as the buffer's length<br>\n * If it's undefined, it will initialize the buffer with a default length of 8 Kb<br>\n * If its an ArrayBuffer, a TypedArray, an IOBuffer instance,\n * or a Node.js Buffer, it will create a view over the underlying ArrayBuffer.\n * @param {object} [options]\n * @param {number} [options.offset=0] - Ignore the first n bytes of the ArrayBuffer\n * @property {ArrayBuffer} buffer - Reference to the internal ArrayBuffer object\n * @property {number} length - Byte length of the internal ArrayBuffer\n * @property {number} offset - The current offset of the buffer's pointer\n * @property {number} byteLength - Byte length of the internal ArrayBuffer\n * @property {number} byteOffset - Byte offset of the internal ArrayBuffer\n */\n\nclass IOBuffer {\n  constructor(data, options) {\n    options = options || {};\n    var dataIsGiven = false;\n\n    if (data === undefined) {\n      data = defaultByteLength;\n    }\n\n    if (typeof data === 'number') {\n      data = new ArrayBuffer(data);\n    } else {\n      dataIsGiven = true;\n      this._lastWrittenByte = data.byteLength;\n    }\n\n    const offset = options.offset ? options.offset >>> 0 : 0;\n    let byteLength = data.byteLength - offset;\n    let dvOffset = offset;\n\n    if (data.buffer) {\n      if (data.byteLength !== data.buffer.byteLength) {\n        dvOffset = data.byteOffset + offset;\n      }\n\n      data = data.buffer;\n    }\n\n    if (dataIsGiven) {\n      this._lastWrittenByte = byteLength;\n    } else {\n      this._lastWrittenByte = 0;\n    }\n\n    this.buffer = data;\n    this.length = byteLength;\n    this.byteLength = byteLength;\n    this.byteOffset = dvOffset;\n    this.offset = 0;\n    this.littleEndian = true;\n    this._data = new DataView(this.buffer, dvOffset, byteLength);\n    this._mark = 0;\n    this._marks = [];\n  }\n  /**\n   * Checks if the memory allocated to the buffer is sufficient to store more bytes after the offset\n   * @param {number} [byteLength=1] The needed memory in bytes\n   * @return {boolean} Returns true if there is sufficient space and false otherwise\n   */\n\n\n  available(byteLength) {\n    if (byteLength === undefined) byteLength = 1;\n    return this.offset + byteLength <= this.length;\n  }\n  /**\n   * Check if little-endian mode is used for reading and writing multi-byte values\n   * @return {boolean} Returns true if little-endian mode is used, false otherwise\n   */\n\n\n  isLittleEndian() {\n    return this.littleEndian;\n  }\n  /**\n   * Set little-endian mode for reading and writing multi-byte values\n   * @return {IOBuffer}\n   */\n\n\n  setLittleEndian() {\n    this.littleEndian = true;\n    return this;\n  }\n  /**\n   * Check if big-endian mode is used for reading and writing multi-byte values\n   * @return {boolean} Returns true if big-endian mode is used, false otherwise\n   */\n\n\n  isBigEndian() {\n    return !this.littleEndian;\n  }\n  /**\n   * Switches to big-endian mode for reading and writing multi-byte values\n   * @return {IOBuffer}\n   */\n\n\n  setBigEndian() {\n    this.littleEndian = false;\n    return this;\n  }\n  /**\n   * Move the pointer n bytes forward\n   * @param {number} n\n   * @return {IOBuffer}\n   */\n\n\n  skip(n) {\n    if (n === undefined) n = 1;\n    this.offset += n;\n    return this;\n  }\n  /**\n   * Move the pointer to the given offset\n   * @param {number} offset\n   * @return {IOBuffer}\n   */\n\n\n  seek(offset) {\n    this.offset = offset;\n    return this;\n  }\n  /**\n   * Store the current pointer offset.\n   * @see {@link IOBuffer#reset}\n   * @return {IOBuffer}\n   */\n\n\n  mark() {\n    this._mark = this.offset;\n    return this;\n  }\n  /**\n   * Move the pointer back to the last pointer offset set by mark\n   * @see {@link IOBuffer#mark}\n   * @return {IOBuffer}\n   */\n\n\n  reset() {\n    this.offset = this._mark;\n    return this;\n  }\n  /**\n   * Push the current pointer offset to the mark stack\n   * @see {@link IOBuffer#popMark}\n   * @return {IOBuffer}\n   */\n\n\n  pushMark() {\n    this._marks.push(this.offset);\n\n    return this;\n  }\n  /**\n   * Pop the last pointer offset from the mark stack, and set the current pointer offset to the popped value\n   * @see {@link IOBuffer#pushMark}\n   * @return {IOBuffer}\n   */\n\n\n  popMark() {\n    const offset = this._marks.pop();\n\n    if (offset === undefined) throw new Error('Mark stack empty');\n    this.seek(offset);\n    return this;\n  }\n  /**\n   * Move the pointer offset back to 0\n   * @return {IOBuffer}\n   */\n\n\n  rewind() {\n    this.offset = 0;\n    return this;\n  }\n  /**\n   * Make sure the buffer has sufficient memory to write a given byteLength at the current pointer offset\n   * If the buffer's memory is insufficient, this method will create a new buffer (a copy) with a length\n   * that is twice (byteLength + current offset)\n   * @param {number} [byteLength = 1]\n   * @return {IOBuffer}\n   */\n\n\n  ensureAvailable(byteLength) {\n    if (byteLength === undefined) byteLength = 1;\n\n    if (!this.available(byteLength)) {\n      const lengthNeeded = this.offset + byteLength;\n      const newLength = lengthNeeded * 2;\n      const newArray = new Uint8Array(newLength);\n      newArray.set(new Uint8Array(this.buffer));\n      this.buffer = newArray.buffer;\n      this.length = this.byteLength = newLength;\n      this._data = new DataView(this.buffer);\n    }\n\n    return this;\n  }\n  /**\n   * Read a byte and return false if the byte's value is 0, or true otherwise\n   * Moves pointer forward\n   * @return {boolean}\n   */\n\n\n  readBoolean() {\n    return this.readUint8() !== 0;\n  }\n  /**\n   * Read a signed 8-bit integer and move pointer forward\n   * @return {number}\n   */\n\n\n  readInt8() {\n    return this._data.getInt8(this.offset++);\n  }\n  /**\n   * Read an unsigned 8-bit integer and move pointer forward\n   * @return {number}\n   */\n\n\n  readUint8() {\n    return this._data.getUint8(this.offset++);\n  }\n  /**\n   * Alias for {@link IOBuffer#readUint8}\n   * @return {number}\n   */\n\n\n  readByte() {\n    return this.readUint8();\n  }\n  /**\n   * Read n bytes and move pointer forward.\n   * @param {number} n\n   * @return {Uint8Array}\n   */\n\n\n  readBytes(n) {\n    if (n === undefined) n = 1;\n    var bytes = new Uint8Array(n);\n\n    for (var i = 0; i < n; i++) {\n      bytes[i] = this.readByte();\n    }\n\n    return bytes;\n  }\n  /**\n   * Read a 16-bit signed integer and move pointer forward\n   * @return {number}\n   */\n\n\n  readInt16() {\n    var value = this._data.getInt16(this.offset, this.littleEndian);\n\n    this.offset += 2;\n    return value;\n  }\n  /**\n   * Read a 16-bit unsigned integer and move pointer forward\n   * @return {number}\n   */\n\n\n  readUint16() {\n    var value = this._data.getUint16(this.offset, this.littleEndian);\n\n    this.offset += 2;\n    return value;\n  }\n  /**\n   * Read a 32-bit signed integer and move pointer forward\n   * @return {number}\n   */\n\n\n  readInt32() {\n    var value = this._data.getInt32(this.offset, this.littleEndian);\n\n    this.offset += 4;\n    return value;\n  }\n  /**\n   * Read a 32-bit unsigned integer and move pointer forward\n   * @return {number}\n   */\n\n\n  readUint32() {\n    var value = this._data.getUint32(this.offset, this.littleEndian);\n\n    this.offset += 4;\n    return value;\n  }\n  /**\n   * Read a 32-bit floating number and move pointer forward\n   * @return {number}\n   */\n\n\n  readFloat32() {\n    var value = this._data.getFloat32(this.offset, this.littleEndian);\n\n    this.offset += 4;\n    return value;\n  }\n  /**\n   * Read a 64-bit floating number and move pointer forward\n   * @return {number}\n   */\n\n\n  readFloat64() {\n    var value = this._data.getFloat64(this.offset, this.littleEndian);\n\n    this.offset += 8;\n    return value;\n  }\n  /**\n   * Read 1-byte ascii character and move pointer forward\n   * @return {string}\n   */\n\n\n  readChar() {\n    return String.fromCharCode(this.readInt8());\n  }\n  /**\n   * Read n 1-byte ascii characters and move pointer forward\n   * @param {number} n\n   * @return {string}\n   */\n\n\n  readChars(n) {\n    if (n === undefined) n = 1;\n    charArray.length = n;\n\n    for (var i = 0; i < n; i++) {\n      charArray[i] = this.readChar();\n    }\n\n    return charArray.join('');\n  }\n  /**\n   * Read the next n bytes, return a UTF-8 decoded string and move pointer forward\n   * @param {number} n\n   * @return {string}\n   */\n\n\n  readUtf8(n) {\n    if (n === undefined) n = 1;\n    const bString = this.readChars(n);\n    return utf8.decode(bString);\n  }\n  /**\n   * Write 0xff if the passed value is truthy, 0x00 otherwise\n   * @param {any} value\n   * @return {IOBuffer}\n   */\n\n\n  writeBoolean(value) {\n    this.writeUint8(value ? 0xff : 0x00);\n    return this;\n  }\n  /**\n   * Write value as an 8-bit signed integer\n   * @param {number} value\n   * @return {IOBuffer}\n   */\n\n\n  writeInt8(value) {\n    this.ensureAvailable(1);\n\n    this._data.setInt8(this.offset++, value);\n\n    this._updateLastWrittenByte();\n\n    return this;\n  }\n  /**\n   * Write value as a 8-bit unsigned integer\n   * @param {number} value\n   * @return {IOBuffer}\n   */\n\n\n  writeUint8(value) {\n    this.ensureAvailable(1);\n\n    this._data.setUint8(this.offset++, value);\n\n    this._updateLastWrittenByte();\n\n    return this;\n  }\n  /**\n   * An alias for {@link IOBuffer#writeUint8}\n   * @param {number} value\n   * @return {IOBuffer}\n   */\n\n\n  writeByte(value) {\n    return this.writeUint8(value);\n  }\n  /**\n   * Write bytes\n   * @param {Array|Uint8Array} bytes\n   * @return {IOBuffer}\n   */\n\n\n  writeBytes(bytes) {\n    this.ensureAvailable(bytes.length);\n\n    for (var i = 0; i < bytes.length; i++) {\n      this._data.setUint8(this.offset++, bytes[i]);\n    }\n\n    this._updateLastWrittenByte();\n\n    return this;\n  }\n  /**\n   * Write value as an 16-bit signed integer\n   * @param {number} value\n   * @return {IOBuffer}\n   */\n\n\n  writeInt16(value) {\n    this.ensureAvailable(2);\n\n    this._data.setInt16(this.offset, value, this.littleEndian);\n\n    this.offset += 2;\n\n    this._updateLastWrittenByte();\n\n    return this;\n  }\n  /**\n   * Write value as a 16-bit unsigned integer\n   * @param {number} value\n   * @return {IOBuffer}\n   */\n\n\n  writeUint16(value) {\n    this.ensureAvailable(2);\n\n    this._data.setUint16(this.offset, value, this.littleEndian);\n\n    this.offset += 2;\n\n    this._updateLastWrittenByte();\n\n    return this;\n  }\n  /**\n   * Write a 32-bit signed integer at the current pointer offset\n   * @param {number} value\n   * @return {IOBuffer}\n   */\n\n\n  writeInt32(value) {\n    this.ensureAvailable(4);\n\n    this._data.setInt32(this.offset, value, this.littleEndian);\n\n    this.offset += 4;\n\n    this._updateLastWrittenByte();\n\n    return this;\n  }\n  /**\n   * Write a 32-bit unsigned integer at the current pointer offset\n   * @param {number} value - The value to set\n   * @return {IOBuffer}\n   */\n\n\n  writeUint32(value) {\n    this.ensureAvailable(4);\n\n    this._data.setUint32(this.offset, value, this.littleEndian);\n\n    this.offset += 4;\n\n    this._updateLastWrittenByte();\n\n    return this;\n  }\n  /**\n   * Write a 32-bit floating number at the current pointer offset\n   * @param {number} value - The value to set\n   * @return {IOBuffer}\n   */\n\n\n  writeFloat32(value) {\n    this.ensureAvailable(4);\n\n    this._data.setFloat32(this.offset, value, this.littleEndian);\n\n    this.offset += 4;\n\n    this._updateLastWrittenByte();\n\n    return this;\n  }\n  /**\n   * Write a 64-bit floating number at the current pointer offset\n   * @param {number} value\n   * @return {IOBuffer}\n   */\n\n\n  writeFloat64(value) {\n    this.ensureAvailable(8);\n\n    this._data.setFloat64(this.offset, value, this.littleEndian);\n\n    this.offset += 8;\n\n    this._updateLastWrittenByte();\n\n    return this;\n  }\n  /**\n   * Write the charCode of the passed string's first character to the current pointer offset\n   * @param {string} str - The character to set\n   * @return {IOBuffer}\n   */\n\n\n  writeChar(str) {\n    return this.writeUint8(str.charCodeAt(0));\n  }\n  /**\n   * Write the charCodes of the passed string's characters to the current pointer offset\n   * @param {string} str\n   * @return {IOBuffer}\n   */\n\n\n  writeChars(str) {\n    for (var i = 0; i < str.length; i++) {\n      this.writeUint8(str.charCodeAt(i));\n    }\n\n    return this;\n  }\n  /**\n   * UTF-8 encode and write the passed string to the current pointer offset\n   * @param {string} str\n   * @return {IOBuffer}\n   */\n\n\n  writeUtf8(str) {\n    const bString = utf8.encode(str);\n    return this.writeChars(bString);\n  }\n  /**\n   * Export a Uint8Array view of the internal buffer.\n   * The view starts at the byte offset and its length\n   * is calculated to stop at the last written byte or the original length.\n   * @return {Uint8Array}\n   */\n\n\n  toArray() {\n    return new Uint8Array(this.buffer, this.byteOffset, this._lastWrittenByte);\n  }\n  /**\n   * Same as {@link IOBuffer#toArray} but returns a Buffer if possible. Otherwise returns a Uint8Array.\n   * @return {Buffer|Uint8Array}\n   */\n\n\n  getBuffer() {\n    if (typeof Buffer !== 'undefined') {\n      return Buffer.from(this.toArray());\n    } else {\n      return this.toArray();\n    }\n  }\n  /**\n   * Update the last written byte offset\n   * @private\n   */\n\n\n  _updateLastWrittenByte() {\n    if (this.offset > this._lastWrittenByte) {\n      this._lastWrittenByte = this.offset;\n    }\n  }\n\n}\n\nmodule.exports = IOBuffer;","map":{"version":3,"sources":["C:/Users/kuent/Documents/FinishDipshit/Creative/Ocean-Weather-Visualization/node_modules/iobuffer/IOBuffer.js"],"names":["utf8","require","defaultByteLength","charArray","IOBuffer","constructor","data","options","dataIsGiven","undefined","ArrayBuffer","_lastWrittenByte","byteLength","offset","dvOffset","buffer","byteOffset","length","littleEndian","_data","DataView","_mark","_marks","available","isLittleEndian","setLittleEndian","isBigEndian","setBigEndian","skip","n","seek","mark","reset","pushMark","push","popMark","pop","Error","rewind","ensureAvailable","lengthNeeded","newLength","newArray","Uint8Array","set","readBoolean","readUint8","readInt8","getInt8","getUint8","readByte","readBytes","bytes","i","readInt16","value","getInt16","readUint16","getUint16","readInt32","getInt32","readUint32","getUint32","readFloat32","getFloat32","readFloat64","getFloat64","readChar","String","fromCharCode","readChars","join","readUtf8","bString","decode","writeBoolean","writeUint8","writeInt8","setInt8","_updateLastWrittenByte","setUint8","writeByte","writeBytes","writeInt16","setInt16","writeUint16","setUint16","writeInt32","setInt32","writeUint32","setUint32","writeFloat32","setFloat32","writeFloat64","setFloat64","writeChar","str","charCodeAt","writeChars","writeUtf8","encode","toArray","getBuffer","Buffer","from","module","exports"],"mappings":"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","sourcesContent":["'use strict';\n\nconst utf8 = require('utf8');\n\nconst defaultByteLength = 1024 * 8;\nconst charArray = [];\n\n/**\n * IOBuffer\n * @constructor\n * @param {undefined|number|ArrayBuffer|TypedArray|IOBuffer|Buffer} data - The data to construct the IOBuffer with.\n *\n * If it's a number, it will initialize the buffer with the number as the buffer's length<br>\n * If it's undefined, it will initialize the buffer with a default length of 8 Kb<br>\n * If its an ArrayBuffer, a TypedArray, an IOBuffer instance,\n * or a Node.js Buffer, it will create a view over the underlying ArrayBuffer.\n * @param {object} [options]\n * @param {number} [options.offset=0] - Ignore the first n bytes of the ArrayBuffer\n * @property {ArrayBuffer} buffer - Reference to the internal ArrayBuffer object\n * @property {number} length - Byte length of the internal ArrayBuffer\n * @property {number} offset - The current offset of the buffer's pointer\n * @property {number} byteLength - Byte length of the internal ArrayBuffer\n * @property {number} byteOffset - Byte offset of the internal ArrayBuffer\n */\nclass IOBuffer {\n    constructor(data, options) {\n        options = options || {};\n        var dataIsGiven = false;\n        if (data === undefined) {\n            data = defaultByteLength;\n        }\n        if (typeof data === 'number') {\n            data = new ArrayBuffer(data);\n        } else {\n            dataIsGiven = true;\n            this._lastWrittenByte = data.byteLength;\n        }\n\n        const offset = options.offset ? options.offset >>> 0 : 0;\n        let byteLength = data.byteLength - offset;\n        let dvOffset = offset;\n        if (data.buffer) {\n            if (data.byteLength !== data.buffer.byteLength) {\n                dvOffset = data.byteOffset + offset;\n            }\n            data = data.buffer;\n        }\n        if (dataIsGiven) {\n            this._lastWrittenByte = byteLength;\n        } else {\n            this._lastWrittenByte = 0;\n        }\n        this.buffer = data;\n        this.length = byteLength;\n        this.byteLength = byteLength;\n        this.byteOffset = dvOffset;\n        this.offset = 0;\n        this.littleEndian = true;\n        this._data = new DataView(this.buffer, dvOffset, byteLength);\n        this._mark = 0;\n        this._marks = [];\n    }\n\n    /**\n     * Checks if the memory allocated to the buffer is sufficient to store more bytes after the offset\n     * @param {number} [byteLength=1] The needed memory in bytes\n     * @return {boolean} Returns true if there is sufficient space and false otherwise\n     */\n    available(byteLength) {\n        if (byteLength === undefined) byteLength = 1;\n        return (this.offset + byteLength) <= this.length;\n    }\n\n    /**\n     * Check if little-endian mode is used for reading and writing multi-byte values\n     * @return {boolean} Returns true if little-endian mode is used, false otherwise\n     */\n    isLittleEndian() {\n        return this.littleEndian;\n    }\n\n    /**\n     * Set little-endian mode for reading and writing multi-byte values\n     * @return {IOBuffer}\n     */\n    setLittleEndian() {\n        this.littleEndian = true;\n        return this;\n    }\n\n    /**\n     * Check if big-endian mode is used for reading and writing multi-byte values\n     * @return {boolean} Returns true if big-endian mode is used, false otherwise\n     */\n    isBigEndian() {\n        return !this.littleEndian;\n    }\n\n    /**\n     * Switches to big-endian mode for reading and writing multi-byte values\n     * @return {IOBuffer}\n     */\n    setBigEndian() {\n        this.littleEndian = false;\n        return this;\n    }\n\n    /**\n     * Move the pointer n bytes forward\n     * @param {number} n\n     * @return {IOBuffer}\n     */\n    skip(n) {\n        if (n === undefined) n = 1;\n        this.offset += n;\n        return this;\n    }\n\n    /**\n     * Move the pointer to the given offset\n     * @param {number} offset\n     * @return {IOBuffer}\n     */\n    seek(offset) {\n        this.offset = offset;\n        return this;\n    }\n\n    /**\n     * Store the current pointer offset.\n     * @see {@link IOBuffer#reset}\n     * @return {IOBuffer}\n     */\n    mark() {\n        this._mark = this.offset;\n        return this;\n    }\n\n    /**\n     * Move the pointer back to the last pointer offset set by mark\n     * @see {@link IOBuffer#mark}\n     * @return {IOBuffer}\n     */\n    reset() {\n        this.offset = this._mark;\n        return this;\n    }\n\n    /**\n     * Push the current pointer offset to the mark stack\n     * @see {@link IOBuffer#popMark}\n     * @return {IOBuffer}\n     */\n    pushMark() {\n        this._marks.push(this.offset);\n        return this;\n    }\n\n    /**\n     * Pop the last pointer offset from the mark stack, and set the current pointer offset to the popped value\n     * @see {@link IOBuffer#pushMark}\n     * @return {IOBuffer}\n     */\n    popMark() {\n        const offset = this._marks.pop();\n        if (offset === undefined) throw new Error('Mark stack empty');\n        this.seek(offset);\n        return this;\n    }\n\n    /**\n     * Move the pointer offset back to 0\n     * @return {IOBuffer}\n     */\n    rewind() {\n        this.offset = 0;\n        return this;\n    }\n\n    /**\n     * Make sure the buffer has sufficient memory to write a given byteLength at the current pointer offset\n     * If the buffer's memory is insufficient, this method will create a new buffer (a copy) with a length\n     * that is twice (byteLength + current offset)\n     * @param {number} [byteLength = 1]\n     * @return {IOBuffer}\n     */\n    ensureAvailable(byteLength) {\n        if (byteLength === undefined) byteLength = 1;\n        if (!this.available(byteLength)) {\n            const lengthNeeded = this.offset + byteLength;\n            const newLength = lengthNeeded * 2;\n            const newArray = new Uint8Array(newLength);\n            newArray.set(new Uint8Array(this.buffer));\n            this.buffer = newArray.buffer;\n            this.length = this.byteLength = newLength;\n            this._data = new DataView(this.buffer);\n        }\n        return this;\n    }\n\n    /**\n     * Read a byte and return false if the byte's value is 0, or true otherwise\n     * Moves pointer forward\n     * @return {boolean}\n     */\n    readBoolean() {\n        return this.readUint8() !== 0;\n    }\n\n    /**\n     * Read a signed 8-bit integer and move pointer forward\n     * @return {number}\n     */\n    readInt8() {\n        return this._data.getInt8(this.offset++);\n    }\n\n    /**\n     * Read an unsigned 8-bit integer and move pointer forward\n     * @return {number}\n     */\n    readUint8() {\n        return this._data.getUint8(this.offset++);\n    }\n\n    /**\n     * Alias for {@link IOBuffer#readUint8}\n     * @return {number}\n     */\n    readByte() {\n        return this.readUint8();\n    }\n\n    /**\n     * Read n bytes and move pointer forward.\n     * @param {number} n\n     * @return {Uint8Array}\n     */\n    readBytes(n) {\n        if (n === undefined) n = 1;\n        var bytes = new Uint8Array(n);\n        for (var i = 0; i < n; i++) {\n            bytes[i] = this.readByte();\n        }\n        return bytes;\n    }\n\n    /**\n     * Read a 16-bit signed integer and move pointer forward\n     * @return {number}\n     */\n    readInt16() {\n        var value = this._data.getInt16(this.offset, this.littleEndian);\n        this.offset += 2;\n        return value;\n    }\n\n    /**\n     * Read a 16-bit unsigned integer and move pointer forward\n     * @return {number}\n     */\n    readUint16() {\n        var value = this._data.getUint16(this.offset, this.littleEndian);\n        this.offset += 2;\n        return value;\n    }\n\n    /**\n     * Read a 32-bit signed integer and move pointer forward\n     * @return {number}\n     */\n    readInt32() {\n        var value = this._data.getInt32(this.offset, this.littleEndian);\n        this.offset += 4;\n        return value;\n    }\n\n    /**\n     * Read a 32-bit unsigned integer and move pointer forward\n     * @return {number}\n     */\n    readUint32() {\n        var value = this._data.getUint32(this.offset, this.littleEndian);\n        this.offset += 4;\n        return value;\n    }\n\n    /**\n     * Read a 32-bit floating number and move pointer forward\n     * @return {number}\n     */\n    readFloat32() {\n        var value = this._data.getFloat32(this.offset, this.littleEndian);\n        this.offset += 4;\n        return value;\n    }\n\n    /**\n     * Read a 64-bit floating number and move pointer forward\n     * @return {number}\n     */\n    readFloat64() {\n        var value = this._data.getFloat64(this.offset, this.littleEndian);\n        this.offset += 8;\n        return value;\n    }\n\n    /**\n     * Read 1-byte ascii character and move pointer forward\n     * @return {string}\n     */\n    readChar() {\n        return String.fromCharCode(this.readInt8());\n    }\n\n    /**\n     * Read n 1-byte ascii characters and move pointer forward\n     * @param {number} n\n     * @return {string}\n     */\n    readChars(n) {\n        if (n === undefined) n = 1;\n        charArray.length = n;\n        for (var i = 0; i < n; i++) {\n            charArray[i] = this.readChar();\n        }\n        return charArray.join('');\n    }\n\n    /**\n     * Read the next n bytes, return a UTF-8 decoded string and move pointer forward\n     * @param {number} n\n     * @return {string}\n     */\n    readUtf8(n) {\n        if (n === undefined) n = 1;\n        const bString = this.readChars(n);\n        return utf8.decode(bString);\n    }\n\n    /**\n     * Write 0xff if the passed value is truthy, 0x00 otherwise\n     * @param {any} value\n     * @return {IOBuffer}\n     */\n    writeBoolean(value) {\n        this.writeUint8(value ? 0xff : 0x00);\n        return this;\n    }\n\n    /**\n     * Write value as an 8-bit signed integer\n     * @param {number} value\n     * @return {IOBuffer}\n     */\n    writeInt8(value) {\n        this.ensureAvailable(1);\n        this._data.setInt8(this.offset++, value);\n        this._updateLastWrittenByte();\n        return this;\n    }\n\n    /**\n     * Write value as a 8-bit unsigned integer\n     * @param {number} value\n     * @return {IOBuffer}\n     */\n    writeUint8(value) {\n        this.ensureAvailable(1);\n        this._data.setUint8(this.offset++, value);\n        this._updateLastWrittenByte();\n        return this;\n    }\n\n    /**\n     * An alias for {@link IOBuffer#writeUint8}\n     * @param {number} value\n     * @return {IOBuffer}\n     */\n    writeByte(value) {\n        return this.writeUint8(value);\n    }\n\n    /**\n     * Write bytes\n     * @param {Array|Uint8Array} bytes\n     * @return {IOBuffer}\n     */\n    writeBytes(bytes) {\n        this.ensureAvailable(bytes.length);\n        for (var i = 0; i < bytes.length; i++) {\n            this._data.setUint8(this.offset++, bytes[i]);\n        }\n        this._updateLastWrittenByte();\n        return this;\n    }\n\n    /**\n     * Write value as an 16-bit signed integer\n     * @param {number} value\n     * @return {IOBuffer}\n     */\n    writeInt16(value) {\n        this.ensureAvailable(2);\n        this._data.setInt16(this.offset, value, this.littleEndian);\n        this.offset += 2;\n        this._updateLastWrittenByte();\n        return this;\n    }\n\n    /**\n     * Write value as a 16-bit unsigned integer\n     * @param {number} value\n     * @return {IOBuffer}\n     */\n    writeUint16(value) {\n        this.ensureAvailable(2);\n        this._data.setUint16(this.offset, value, this.littleEndian);\n        this.offset += 2;\n        this._updateLastWrittenByte();\n        return this;\n    }\n\n    /**\n     * Write a 32-bit signed integer at the current pointer offset\n     * @param {number} value\n     * @return {IOBuffer}\n     */\n    writeInt32(value) {\n        this.ensureAvailable(4);\n        this._data.setInt32(this.offset, value, this.littleEndian);\n        this.offset += 4;\n        this._updateLastWrittenByte();\n        return this;\n    }\n\n    /**\n     * Write a 32-bit unsigned integer at the current pointer offset\n     * @param {number} value - The value to set\n     * @return {IOBuffer}\n     */\n    writeUint32(value) {\n        this.ensureAvailable(4);\n        this._data.setUint32(this.offset, value, this.littleEndian);\n        this.offset += 4;\n        this._updateLastWrittenByte();\n        return this;\n    }\n\n    /**\n     * Write a 32-bit floating number at the current pointer offset\n     * @param {number} value - The value to set\n     * @return {IOBuffer}\n     */\n    writeFloat32(value) {\n        this.ensureAvailable(4);\n        this._data.setFloat32(this.offset, value, this.littleEndian);\n        this.offset += 4;\n        this._updateLastWrittenByte();\n        return this;\n    }\n\n    /**\n     * Write a 64-bit floating number at the current pointer offset\n     * @param {number} value\n     * @return {IOBuffer}\n     */\n    writeFloat64(value) {\n        this.ensureAvailable(8);\n        this._data.setFloat64(this.offset, value, this.littleEndian);\n        this.offset += 8;\n        this._updateLastWrittenByte();\n        return this;\n    }\n\n    /**\n     * Write the charCode of the passed string's first character to the current pointer offset\n     * @param {string} str - The character to set\n     * @return {IOBuffer}\n     */\n    writeChar(str) {\n        return this.writeUint8(str.charCodeAt(0));\n    }\n\n    /**\n     * Write the charCodes of the passed string's characters to the current pointer offset\n     * @param {string} str\n     * @return {IOBuffer}\n     */\n    writeChars(str) {\n        for (var i = 0; i < str.length; i++) {\n            this.writeUint8(str.charCodeAt(i));\n        }\n        return this;\n    }\n\n    /**\n     * UTF-8 encode and write the passed string to the current pointer offset\n     * @param {string} str\n     * @return {IOBuffer}\n     */\n    writeUtf8(str) {\n        const bString = utf8.encode(str);\n        return this.writeChars(bString);\n    }\n\n    /**\n     * Export a Uint8Array view of the internal buffer.\n     * The view starts at the byte offset and its length\n     * is calculated to stop at the last written byte or the original length.\n     * @return {Uint8Array}\n     */\n    toArray() {\n        return new Uint8Array(this.buffer, this.byteOffset, this._lastWrittenByte);\n    }\n\n    /**\n     * Same as {@link IOBuffer#toArray} but returns a Buffer if possible. Otherwise returns a Uint8Array.\n     * @return {Buffer|Uint8Array}\n     */\n    getBuffer() {\n        if (typeof Buffer !== 'undefined') {\n            return Buffer.from(this.toArray());\n        } else {\n            return this.toArray();\n        }\n    }\n\n    /**\n     * Update the last written byte offset\n     * @private\n     */\n    _updateLastWrittenByte() {\n        if (this.offset > this._lastWrittenByte) {\n            this._lastWrittenByte = this.offset;\n        }\n    }\n}\n\nmodule.exports = IOBuffer;\n"]},"metadata":{},"sourceType":"script"}