{"ast":null,"code":"/**\n * Allows to generate an array of points for a binary image (bit depth = 1)\n * The points consider the beginning and the end of each pixel\n * @memberof Image\n * @instance\n * @return {Array<Array<number>>} - an array of [x,y] corresponding to the set pixels in the binary image\n */\nexport default function extendedPoints() {\n  this.checkProcessable('extendedPoints', {\n    bitDepth: [1]\n  });\n  const pixels = [];\n\n  for (let y = 0; y < this.height; y++) {\n    for (let x = 0; x < this.width; x++) {\n      if (this.getBitXY(x, y) === 1) {\n        pixels.push([x, y]);\n\n        if (this.getBitXY(x + 1, y) !== 1) {\n          pixels.push([x + 1, y]);\n          pixels.push([x + 1, y + 1]);\n\n          if (this.getBitXY(x, y + 1) !== 1) {\n            pixels.push([x, y + 1]);\n          }\n        } else {\n          if (this.getBitXY(x, y + 1) !== 1) {\n            pixels.push([x, y + 1]);\n            pixels.push([x + 1, y + 1]);\n          }\n        }\n      }\n    }\n  }\n\n  return pixels;\n}","map":{"version":3,"sources":["C:/Users/kuent/Documents/FinishDipshit/Creative/Ocean-Weather-Visualization/node_modules/image-js/src/image/compute/extendedPoints.js"],"names":["extendedPoints","checkProcessable","bitDepth","pixels","y","height","x","width","getBitXY","push"],"mappings":"AAAA;;;;;;;AAOA,eAAe,SAASA,cAAT,GAA0B;AACvC,OAAKC,gBAAL,CAAsB,gBAAtB,EAAwC;AACtCC,IAAAA,QAAQ,EAAE,CAAC,CAAD;AAD4B,GAAxC;AAIA,QAAMC,MAAM,GAAG,EAAf;;AACA,OAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG,KAAKC,MAAzB,EAAiCD,CAAC,EAAlC,EAAsC;AACpC,SAAK,IAAIE,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG,KAAKC,KAAzB,EAAgCD,CAAC,EAAjC,EAAqC;AACnC,UAAI,KAAKE,QAAL,CAAcF,CAAd,EAAiBF,CAAjB,MAAwB,CAA5B,EAA+B;AAC7BD,QAAAA,MAAM,CAACM,IAAP,CAAY,CAACH,CAAD,EAAIF,CAAJ,CAAZ;;AACA,YAAI,KAAKI,QAAL,CAAcF,CAAC,GAAG,CAAlB,EAAqBF,CAArB,MAA4B,CAAhC,EAAmC;AACjCD,UAAAA,MAAM,CAACM,IAAP,CAAY,CAACH,CAAC,GAAG,CAAL,EAAQF,CAAR,CAAZ;AACAD,UAAAA,MAAM,CAACM,IAAP,CAAY,CAACH,CAAC,GAAG,CAAL,EAAQF,CAAC,GAAG,CAAZ,CAAZ;;AACA,cAAI,KAAKI,QAAL,CAAcF,CAAd,EAAiBF,CAAC,GAAG,CAArB,MAA4B,CAAhC,EAAmC;AACjCD,YAAAA,MAAM,CAACM,IAAP,CAAY,CAACH,CAAD,EAAIF,CAAC,GAAG,CAAR,CAAZ;AACD;AACF,SAND,MAMO;AACL,cAAI,KAAKI,QAAL,CAAcF,CAAd,EAAiBF,CAAC,GAAG,CAArB,MAA4B,CAAhC,EAAmC;AACjCD,YAAAA,MAAM,CAACM,IAAP,CAAY,CAACH,CAAD,EAAIF,CAAC,GAAG,CAAR,CAAZ;AACAD,YAAAA,MAAM,CAACM,IAAP,CAAY,CAACH,CAAC,GAAG,CAAL,EAAQF,CAAC,GAAG,CAAZ,CAAZ;AACD;AACF;AACF;AACF;AACF;;AACD,SAAOD,MAAP;AACD","sourcesContent":["/**\n * Allows to generate an array of points for a binary image (bit depth = 1)\n * The points consider the beginning and the end of each pixel\n * @memberof Image\n * @instance\n * @return {Array<Array<number>>} - an array of [x,y] corresponding to the set pixels in the binary image\n */\nexport default function extendedPoints() {\n  this.checkProcessable('extendedPoints', {\n    bitDepth: [1],\n  });\n\n  const pixels = [];\n  for (let y = 0; y < this.height; y++) {\n    for (let x = 0; x < this.width; x++) {\n      if (this.getBitXY(x, y) === 1) {\n        pixels.push([x, y]);\n        if (this.getBitXY(x + 1, y) !== 1) {\n          pixels.push([x + 1, y]);\n          pixels.push([x + 1, y + 1]);\n          if (this.getBitXY(x, y + 1) !== 1) {\n            pixels.push([x, y + 1]);\n          }\n        } else {\n          if (this.getBitXY(x, y + 1) !== 1) {\n            pixels.push([x, y + 1]);\n            pixels.push([x + 1, y + 1]);\n          }\n        }\n      }\n    }\n  }\n  return pixels;\n}\n"]},"metadata":{},"sourceType":"module"}