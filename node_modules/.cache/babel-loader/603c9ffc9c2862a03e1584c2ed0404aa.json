{"ast":null,"code":"/*\n * see http://rsb.info.nih.gov/ij/developer/source/ij/process/AutoThresholder.java.html\n * The method is present in: An iterative implementation of Kittler and Illingworth's Minimum Error\n * thresholding:Kittler, J & Illingworth, J (1986), \"Minimum error thresholding\", Pattern Recognition 19: 41-47\n * @param histogram - the histogram of the image\n * @param total - the number of pixels in the image\n * @returns {number} - the threshold\n */\nexport default function minError(histogram, total) {\n  let threshold;\n  let Tprev = -2;\n  let mu, nu, p, q, sigma2, tau2, w0, w1, w2, sqterm, temp;\n  /* Calculate the mean gray-level */\n\n  let mean = 0.0;\n\n  for (let ih = 0; ih < histogram.length; ih++) {\n    mean += ih * histogram[ih];\n  }\n\n  mean /= total;\n  threshold = mean;\n\n  while (threshold !== Tprev) {\n    // Calculate some statistics.\n    let sumA1 = sumA(histogram, threshold);\n    let sumA2 = sumA(histogram, histogram.length - 1);\n    let sumB1 = sumB(histogram, threshold);\n    let sumB2 = sumB(histogram, histogram.length - 1);\n    let sumC1 = sumC(histogram, threshold);\n    let sumC2 = sumC(histogram, histogram.length - 1);\n    mu = sumB1 / sumA1;\n    nu = (sumB2 - sumB1) / (sumA2 - sumA1);\n    p = sumA1 / sumA2;\n    q = (sumA2 - sumA1) / sumA2;\n    sigma2 = sumC1 / sumA1 - mu * mu;\n    tau2 = (sumC2 - sumC1) / (sumA2 - sumA1) - nu * nu; // The terms of the quadratic equation to be solved.\n\n    w0 = 1.0 / sigma2 - 1.0 / tau2;\n    w1 = mu / sigma2 - nu / tau2;\n    w2 = mu * mu / sigma2 - nu * nu / tau2 + Math.log10(sigma2 * (q * q) / (tau2 * (p * p))); // If the next threshold would be imaginary, return with the current one.\n\n    sqterm = w1 * w1 - w0 * w2;\n\n    if (sqterm < 0) {\n      return threshold;\n    } // The updated threshold is the integer part of the solution of the quadratic equation.\n\n\n    Tprev = threshold;\n    temp = (w1 + Math.sqrt(sqterm)) / w0;\n\n    if (isNaN(temp)) {\n      threshold = Tprev;\n    } else {\n      threshold = Math.floor(temp);\n    }\n  }\n\n  return threshold;\n} // aux func\n\nfunction sumA(y, j) {\n  let x = 0;\n\n  for (let i = 0; i <= j; i++) {\n    x += y[i];\n  }\n\n  return x;\n}\n\nfunction sumB(y, j) {\n  let x = 0;\n\n  for (let i = 0; i <= j; i++) {\n    x += i * y[i];\n  }\n\n  return x;\n}\n\nfunction sumC(y, j) {\n  let x = 0;\n\n  for (let i = 0; i <= j; i++) {\n    x += i * i * y[i];\n  }\n\n  return x;\n}","map":{"version":3,"sources":["C:/Users/kuent/Documents/FinishDipshit/Creative/Ocean-Weather-Visualization/node_modules/image-js/src/image/transform/mask/minError.js"],"names":["minError","histogram","total","threshold","Tprev","mu","nu","p","q","sigma2","tau2","w0","w1","w2","sqterm","temp","mean","ih","length","sumA1","sumA","sumA2","sumB1","sumB","sumB2","sumC1","sumC","sumC2","Math","log10","sqrt","isNaN","floor","y","j","x","i"],"mappings":"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","sourcesContent":["/*\n * see http://rsb.info.nih.gov/ij/developer/source/ij/process/AutoThresholder.java.html\n * The method is present in: An iterative implementation of Kittler and Illingworth's Minimum Error\n * thresholding:Kittler, J & Illingworth, J (1986), \"Minimum error thresholding\", Pattern Recognition 19: 41-47\n * @param histogram - the histogram of the image\n * @param total - the number of pixels in the image\n * @returns {number} - the threshold\n */\n\nexport default function minError(histogram, total) {\n  let threshold;\n  let Tprev = -2;\n  let mu, nu, p, q, sigma2, tau2, w0, w1, w2, sqterm, temp;\n\n  /* Calculate the mean gray-level */\n  let mean = 0.0;\n  for (let ih = 0; ih < histogram.length; ih++) {\n    mean += ih * histogram[ih];\n  }\n\n  mean /= total;\n\n  threshold = mean;\n\n  while (threshold !== Tprev) {\n    // Calculate some statistics.\n    let sumA1 = sumA(histogram, threshold);\n    let sumA2 = sumA(histogram, histogram.length - 1);\n    let sumB1 = sumB(histogram, threshold);\n    let sumB2 = sumB(histogram, histogram.length - 1);\n    let sumC1 = sumC(histogram, threshold);\n    let sumC2 = sumC(histogram, histogram.length - 1);\n\n    mu = sumB1 / sumA1;\n    nu = (sumB2 - sumB1) / (sumA2 - sumA1);\n    p = sumA1 / sumA2;\n    q = (sumA2 - sumA1) / sumA2;\n    sigma2 = sumC1 / sumA1 - mu * mu;\n    tau2 = (sumC2 - sumC1) / (sumA2 - sumA1) - nu * nu;\n\n    // The terms of the quadratic equation to be solved.\n    w0 = 1.0 / sigma2 - 1.0 / tau2;\n    w1 = mu / sigma2 - nu / tau2;\n    w2 =\n      (mu * mu) / sigma2 -\n      (nu * nu) / tau2 +\n      Math.log10((sigma2 * (q * q)) / (tau2 * (p * p)));\n\n    // If the next threshold would be imaginary, return with the current one.\n    sqterm = w1 * w1 - w0 * w2;\n    if (sqterm < 0) {\n      return threshold;\n    }\n\n    // The updated threshold is the integer part of the solution of the quadratic equation.\n    Tprev = threshold;\n    temp = (w1 + Math.sqrt(sqterm)) / w0;\n\n    if (isNaN(temp)) {\n      threshold = Tprev;\n    } else {\n      threshold = Math.floor(temp);\n    }\n  }\n  return threshold;\n}\n\n// aux func\n\nfunction sumA(y, j) {\n  let x = 0;\n  for (let i = 0; i <= j; i++) {\n    x += y[i];\n  }\n  return x;\n}\n\nfunction sumB(y, j) {\n  let x = 0;\n  for (let i = 0; i <= j; i++) {\n    x += i * y[i];\n  }\n  return x;\n}\n\nfunction sumC(y, j) {\n  let x = 0;\n  for (let i = 0; i <= j; i++) {\n    x += i * i * y[i];\n  }\n  return x;\n}\n"]},"metadata":{},"sourceType":"module"}