{"ast":null,"code":"import Image from '../Image';\n/**\n * Extracts a part of an original image based on a mask. By default the mask may contain\n * a relative position and this part of the original image will be extracted.\n * @memberof Image\n * @instance\n * @param {Image} mask - Image containing a binary mask\n * @param {object} [options]\n * @param {number[]} [options.position] - Array of 2 elements to force the x,y coordinates\n * @return {Image} A new image\n */\n\nexport default function extract(mask, options = {}) {\n  let {\n    position\n  } = options;\n  this.checkProcessable('extract', {\n    bitDepth: [1, 8, 16]\n  }); // we need to find the relative position to the parent\n\n  if (!position) {\n    position = mask.getRelativePosition(this);\n\n    if (!position) {\n      throw new Error('extract : can not extract an image because the relative position can not be ' + 'determined, try to specify manually the position as an array of 2 elements [x,y].');\n    }\n  }\n\n  if (this.bitDepth > 1) {\n    let extract = Image.createFrom(this, {\n      width: mask.width,\n      height: mask.height,\n      alpha: 1,\n      // we force the alpha, otherwise difficult to extract a mask ...\n      position: position,\n      parent: this\n    });\n\n    for (let x = 0; x < mask.width; x++) {\n      for (let y = 0; y < mask.height; y++) {\n        // we copy the point\n        for (let channel = 0; channel < this.channels; channel++) {\n          let value = this.getValueXY(x + position[0], y + position[1], channel);\n          extract.setValueXY(x, y, channel, value);\n        } // we make it transparent in case it is not in the mask\n\n\n        if (!mask.getBitXY(x, y)) {\n          extract.setValueXY(x, y, this.components, 0);\n        }\n      }\n    }\n\n    return extract;\n  } else {\n    let extract = Image.createFrom(this, {\n      width: mask.width,\n      height: mask.height,\n      position: position,\n      parent: this\n    });\n\n    for (let y = 0; y < mask.height; y++) {\n      for (let x = 0; x < mask.width; x++) {\n        if (mask.getBitXY(x, y)) {\n          if (this.getBitXY(x + position[0], y + position[1])) {\n            extract.setBitXY(x, y);\n          }\n        }\n      }\n    }\n\n    return extract;\n  }\n}","map":{"version":3,"sources":["C:/Users/kuent/Documents/FinishDipshit/Creative/Ocean-Weather-Visualization/node_modules/image-js/src/image/operator/extract.js"],"names":["Image","extract","mask","options","position","checkProcessable","bitDepth","getRelativePosition","Error","createFrom","width","height","alpha","parent","x","y","channel","channels","value","getValueXY","setValueXY","getBitXY","components","setBitXY"],"mappings":"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","sourcesContent":["import Image from '../Image';\n\n/**\n * Extracts a part of an original image based on a mask. By default the mask may contain\n * a relative position and this part of the original image will be extracted.\n * @memberof Image\n * @instance\n * @param {Image} mask - Image containing a binary mask\n * @param {object} [options]\n * @param {number[]} [options.position] - Array of 2 elements to force the x,y coordinates\n * @return {Image} A new image\n */\nexport default function extract(mask, options = {}) {\n  let { position } = options;\n  this.checkProcessable('extract', {\n    bitDepth: [1, 8, 16],\n  });\n\n  // we need to find the relative position to the parent\n  if (!position) {\n    position = mask.getRelativePosition(this);\n    if (!position) {\n      throw new Error(\n        'extract : can not extract an image because the relative position can not be ' +\n          'determined, try to specify manually the position as an array of 2 elements [x,y].',\n      );\n    }\n  }\n\n  if (this.bitDepth > 1) {\n    let extract = Image.createFrom(this, {\n      width: mask.width,\n      height: mask.height,\n      alpha: 1, // we force the alpha, otherwise difficult to extract a mask ...\n      position: position,\n      parent: this,\n    });\n\n    for (let x = 0; x < mask.width; x++) {\n      for (let y = 0; y < mask.height; y++) {\n        // we copy the point\n        for (let channel = 0; channel < this.channels; channel++) {\n          let value = this.getValueXY(\n            x + position[0],\n            y + position[1],\n            channel,\n          );\n          extract.setValueXY(x, y, channel, value);\n        }\n        // we make it transparent in case it is not in the mask\n        if (!mask.getBitXY(x, y)) {\n          extract.setValueXY(x, y, this.components, 0);\n        }\n      }\n    }\n\n    return extract;\n  } else {\n    let extract = Image.createFrom(this, {\n      width: mask.width,\n      height: mask.height,\n      position: position,\n      parent: this,\n    });\n    for (let y = 0; y < mask.height; y++) {\n      for (let x = 0; x < mask.width; x++) {\n        if (mask.getBitXY(x, y)) {\n          if (this.getBitXY(x + position[0], y + position[1])) {\n            extract.setBitXY(x, y);\n          }\n        }\n      }\n    }\n\n    return extract;\n  }\n}\n"]},"metadata":{},"sourceType":"module"}