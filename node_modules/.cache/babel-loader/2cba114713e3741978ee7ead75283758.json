{"ast":null,"code":"// see https://github.com/fiji/Auto_Threshold/blob/master/src/main/java/fiji/threshold/Auto_Threshold.java\n// Kapur J.N., Sahoo P.K., and Wong A.K.C. (1985) \"A New Method for\n// Gray-Level Picture Thresholding Using the Entropy of the Histogram\"\n// Graphical Models and Image Processing, 29(3): 273-285\n// M. Emre Celebi\n// 06.15.2007\n// Ported to ImageJ plugin by G.Landini from E Celebi's fourier_0.8 routines\nimport { ascending as sortAsc } from 'num-sort';\nexport default function renyiEntropy(histogram, total) {\n  let optThreshold; // Optimal threshold\n\n  let firstBin; // First non-zero bin\n\n  let lastBin; // last non-zero bin\n\n  let normHisto = new Array(histogram.length); // normalized histogram\n\n  let P1 = new Array(histogram.length); // acumulative normalized histogram\n\n  let P2 = new Array(histogram.length); // acumulative normalized histogram\n  // Entropy Variables\n\n  let threshold1 = 0;\n  let threshold2 = 0;\n  let threshold3 = 0;\n  let maxEnt1 = 0.0;\n  let maxEnt2 = 0.0;\n  let maxEnt3 = 0.0;\n  let alpha2 = 0.5;\n  let term2 = 1.0 / (1.0 - alpha2);\n  let alpha3 = 2.0;\n  let term3 = 1.0 / (1.0 - alpha3);\n\n  for (let ih = 0; ih < histogram.length; ih++) {\n    normHisto[ih] = histogram[ih] / total;\n  }\n\n  P1[0] = normHisto[0];\n  P2[0] = 1.0 - P1[0];\n\n  for (let ih = 1; ih < histogram.length; ih++) {\n    P1[ih] = P1[ih - 1] + normHisto[ih];\n    P2[ih] = 1.0 - P1[ih];\n  }\n  /* Determine the first non-zero bin */\n\n\n  firstBin = 0;\n\n  for (let ih = 0; ih < histogram.length; ih++) {\n    if (Math.abs(P1[ih]) >= Number.EPSILON) {\n      firstBin = ih;\n      break;\n    }\n  }\n  /* Determine the last non-zero bin */\n\n\n  lastBin = histogram.length - 1;\n\n  for (let ih = histogram.length - 1; ih >= firstBin; ih--) {\n    if (Math.abs(P2[ih]) >= Number.EPSILON) {\n      lastBin = ih;\n      break;\n    }\n  }\n  /* Maximum Entropy Thresholding - BEGIN */\n\n  /* ALPHA = 1.0 */\n\n  /* Calculate the total entropy each gray-level\n     and find the threshold that maximizes it\n     */\n\n\n  for (let it = firstBin; it <= lastBin; it++) {\n    /* Entropy of the background pixels */\n    let entBack1 = 0.0;\n    let entBack2 = 0.0;\n    let entBack3 = 0.0;\n\n    for (let ih = 0; ih <= it; ih++) {\n      if (histogram[ih] !== 0) {\n        entBack1 -= normHisto[ih] / P1[it] * Math.log(normHisto[ih] / P1[it]);\n      }\n\n      entBack2 += Math.sqrt(normHisto[ih] / P1[it]);\n      entBack3 += normHisto[ih] * normHisto[ih] / (P1[it] * P1[it]);\n    }\n    /* Entropy of the object pixels */\n\n\n    let entObj1 = 0.0;\n    let entObj2 = 0.0;\n    let entObj3 = 0.0;\n\n    for (let ih = it + 1; ih < histogram.length; ih++) {\n      if (histogram[ih] !== 0) {\n        entObj1 -= normHisto[ih] / P2[it] * Math.log(normHisto[ih] / P2[it]);\n      }\n\n      entObj2 += Math.sqrt(normHisto[ih] / P2[it]);\n      entObj3 += normHisto[ih] * normHisto[ih] / (P2[it] * P2[it]);\n    }\n    /* Total entropy */\n\n\n    let totEnt1 = entBack1 + entObj1;\n    let totEnt2 = term2 * (entBack2 * entObj2 > 0.0 ? Math.log(entBack2 * entObj2) : 0.0);\n    let totEnt3 = term3 * (entBack3 * entObj3 > 0.0 ? Math.log(entBack3 * entObj3) : 0.0);\n\n    if (totEnt1 > maxEnt1) {\n      maxEnt1 = totEnt1;\n      threshold1 = it;\n    }\n\n    if (totEnt2 > maxEnt2) {\n      maxEnt2 = totEnt2;\n      threshold2 = it;\n    }\n\n    if (totEnt3 > maxEnt3) {\n      maxEnt3 = totEnt3;\n      threshold3 = it;\n    }\n  }\n  /* End Maximum Entropy Thresholding */\n\n\n  let tStars = [threshold1, threshold2, threshold3];\n  tStars.sort(sortAsc);\n  let betas;\n  /* Adjust beta values */\n\n  if (Math.abs(tStars[0] - tStars[1]) <= 5) {\n    if (Math.abs(tStars[1] - tStars[2]) <= 5) {\n      betas = [1, 2, 1];\n    } else {\n      betas = [0, 1, 3];\n    }\n  } else {\n    if (Math.abs(tStars[1] - tStars[2]) <= 5) {\n      betas = [3, 1, 0];\n    } else {\n      betas = [1, 2, 1];\n    }\n  }\n  /* Determine the optimal threshold value */\n\n\n  let omega = P1[tStars[2]] - P1[tStars[0]];\n  optThreshold = Math.round(tStars[0] * (P1[tStars[0]] + 0.25 * omega * betas[0]) + 0.25 * tStars[1] * omega * betas[1] + tStars[2] * (P2[tStars[2]] + 0.25 * omega * betas[2]));\n  return optThreshold;\n}","map":{"version":3,"sources":["C:/Users/kuent/Documents/FinishDipshit/Creative/Ocean-Weather-Visualization/node_modules/image-js/src/image/transform/mask/renyiEntropy.js"],"names":["ascending","sortAsc","renyiEntropy","histogram","total","optThreshold","firstBin","lastBin","normHisto","Array","length","P1","P2","threshold1","threshold2","threshold3","maxEnt1","maxEnt2","maxEnt3","alpha2","term2","alpha3","term3","ih","Math","abs","Number","EPSILON","it","entBack1","entBack2","entBack3","log","sqrt","entObj1","entObj2","entObj3","totEnt1","totEnt2","totEnt3","tStars","sort","betas","omega","round"],"mappings":"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","sourcesContent":["// see https://github.com/fiji/Auto_Threshold/blob/master/src/main/java/fiji/threshold/Auto_Threshold.java\n// Kapur J.N., Sahoo P.K., and Wong A.K.C. (1985) \"A New Method for\n// Gray-Level Picture Thresholding Using the Entropy of the Histogram\"\n// Graphical Models and Image Processing, 29(3): 273-285\n// M. Emre Celebi\n// 06.15.2007\n// Ported to ImageJ plugin by G.Landini from E Celebi's fourier_0.8 routines\nimport { ascending as sortAsc } from 'num-sort';\n\nexport default function renyiEntropy(histogram, total) {\n  let optThreshold; // Optimal threshold\n  let firstBin; // First non-zero bin\n  let lastBin; // last non-zero bin\n\n  let normHisto = new Array(histogram.length); // normalized histogram\n  let P1 = new Array(histogram.length); // acumulative normalized histogram\n  let P2 = new Array(histogram.length); // acumulative normalized histogram\n\n  // Entropy Variables\n  let threshold1 = 0;\n  let threshold2 = 0;\n  let threshold3 = 0;\n  let maxEnt1 = 0.0;\n  let maxEnt2 = 0.0;\n  let maxEnt3 = 0.0;\n  let alpha2 = 0.5;\n  let term2 = 1.0 / (1.0 - alpha2);\n  let alpha3 = 2.0;\n  let term3 = 1.0 / (1.0 - alpha3);\n\n  for (let ih = 0; ih < histogram.length; ih++) {\n    normHisto[ih] = histogram[ih] / total;\n  }\n\n  P1[0] = normHisto[0];\n  P2[0] = 1.0 - P1[0];\n  for (let ih = 1; ih < histogram.length; ih++) {\n    P1[ih] = P1[ih - 1] + normHisto[ih];\n    P2[ih] = 1.0 - P1[ih];\n  }\n\n  /* Determine the first non-zero bin */\n  firstBin = 0;\n  for (let ih = 0; ih < histogram.length; ih++) {\n    if (Math.abs(P1[ih]) >= Number.EPSILON) {\n      firstBin = ih;\n      break;\n    }\n  }\n\n  /* Determine the last non-zero bin */\n  lastBin = histogram.length - 1;\n  for (let ih = histogram.length - 1; ih >= firstBin; ih--) {\n    if (Math.abs(P2[ih]) >= Number.EPSILON) {\n      lastBin = ih;\n      break;\n    }\n  }\n\n  /* Maximum Entropy Thresholding - BEGIN */\n  /* ALPHA = 1.0 */\n  /* Calculate the total entropy each gray-level\n     and find the threshold that maximizes it\n     */\n  for (let it = firstBin; it <= lastBin; it++) {\n    /* Entropy of the background pixels */\n    let entBack1 = 0.0;\n    let entBack2 = 0.0;\n    let entBack3 = 0.0;\n    for (let ih = 0; ih <= it; ih++) {\n      if (histogram[ih] !== 0) {\n        entBack1 -= (normHisto[ih] / P1[it]) * Math.log(normHisto[ih] / P1[it]);\n      }\n      entBack2 += Math.sqrt(normHisto[ih] / P1[it]);\n      entBack3 += (normHisto[ih] * normHisto[ih]) / (P1[it] * P1[it]);\n    }\n\n    /* Entropy of the object pixels */\n    let entObj1 = 0.0;\n    let entObj2 = 0.0;\n    let entObj3 = 0.0;\n    for (let ih = it + 1; ih < histogram.length; ih++) {\n      if (histogram[ih] !== 0) {\n        entObj1 -= (normHisto[ih] / P2[it]) * Math.log(normHisto[ih] / P2[it]);\n      }\n      entObj2 += Math.sqrt(normHisto[ih] / P2[it]);\n      entObj3 += (normHisto[ih] * normHisto[ih]) / (P2[it] * P2[it]);\n    }\n\n    /* Total entropy */\n    let totEnt1 = entBack1 + entObj1;\n    let totEnt2 =\n      term2 * (entBack2 * entObj2 > 0.0 ? Math.log(entBack2 * entObj2) : 0.0);\n    let totEnt3 =\n      term3 * (entBack3 * entObj3 > 0.0 ? Math.log(entBack3 * entObj3) : 0.0);\n\n    if (totEnt1 > maxEnt1) {\n      maxEnt1 = totEnt1;\n      threshold1 = it;\n    }\n\n    if (totEnt2 > maxEnt2) {\n      maxEnt2 = totEnt2;\n      threshold2 = it;\n    }\n\n    if (totEnt3 > maxEnt3) {\n      maxEnt3 = totEnt3;\n      threshold3 = it;\n    }\n  }\n  /* End Maximum Entropy Thresholding */\n\n  let tStars = [threshold1, threshold2, threshold3];\n  tStars.sort(sortAsc);\n\n  let betas;\n\n  /* Adjust beta values */\n  if (Math.abs(tStars[0] - tStars[1]) <= 5) {\n    if (Math.abs(tStars[1] - tStars[2]) <= 5) {\n      betas = [1, 2, 1];\n    } else {\n      betas = [0, 1, 3];\n    }\n  } else {\n    if (Math.abs(tStars[1] - tStars[2]) <= 5) {\n      betas = [3, 1, 0];\n    } else {\n      betas = [1, 2, 1];\n    }\n  }\n\n  /* Determine the optimal threshold value */\n  let omega = P1[tStars[2]] - P1[tStars[0]];\n  optThreshold = Math.round(\n    tStars[0] * (P1[tStars[0]] + 0.25 * omega * betas[0]) +\n      0.25 * tStars[1] * omega * betas[1] +\n      tStars[2] * (P2[tStars[2]] + 0.25 * omega * betas[2]),\n  );\n\n  return optThreshold;\n}\n"]},"metadata":{},"sourceType":"module"}