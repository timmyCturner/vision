{"ast":null,"code":"/**\n * The roiMap is an array of the size of the original image data that contains\n * positive and negative numbers. When the number is common, it corresponds\n * to one region of interest (ROI)\n *\n * @class RoiMap\n * @private\n */\nimport commonBorderLength from './util/commonBorderLength';\nimport mergeRoi from './util/mergeRoi';\nexport default class RoiMap {\n  constructor(parent, data) {\n    this.parent = parent;\n    this.width = parent.width;\n    this.height = parent.height;\n    this.data = data;\n    this.negative = 0;\n    this.positive = 0;\n  }\n\n  get total() {\n    return this.negative + this.positive;\n  }\n\n  get minMax() {\n    let min = Number.MAX_SAFE_INTEGER;\n    let max = Number.MIN_SAFE_INTEGER;\n\n    for (let i = 0; i < this.data.length; i++) {\n      if (this.data[i] < min) min = this.data[i];\n      if (this.data[i] > max) max = this.data[i];\n    }\n\n    return {\n      min,\n      max\n    };\n  }\n\n  get commonBorderLength() {\n    return commonBorderLength(this);\n  }\n\n  mergeRoi(options = {}) {\n    return mergeRoi.call(this, options);\n  }\n\n  mergeRois(rois) {\n    const first = rois[0];\n    const others = rois.slice(1);\n\n    for (let i = 0; i < this.data.length; i++) {\n      if (others.includes(this.data[i])) {\n        this.data[i] = first;\n      }\n    }\n  }\n\n  rowsInfo() {\n    let rowsInfo = new Array(this.height);\n    let currentRow = 0;\n\n    for (let i = 0; i < this.data.length; i += this.width) {\n      let info = {\n        row: currentRow,\n        positivePixel: 0,\n        negativePixel: 0,\n        zeroPixel: 0,\n        positiveRoi: 0,\n        negativeRoi: 0,\n        medianChange: 0\n      };\n      rowsInfo[currentRow++] = info;\n      let positives = {};\n      let negatives = {};\n      let changes = [];\n      let previous = this.data[i];\n      let current = 0;\n\n      for (let j = i; j < i + this.width; j++) {\n        let value = this.data[j];\n\n        if (previous !== value) {\n          previous = value;\n          changes.push(current);\n          current = 0;\n        }\n\n        current++;\n\n        if (value > 0) {\n          info.positivePixel++;\n\n          if (!positives[value]) {\n            positives[value] = true;\n          }\n        } else if (value < 0) {\n          info.negativePixel++;\n\n          if (!negatives[value]) {\n            negatives[value] = true;\n          }\n        } else {\n          info.zeroPixel++;\n        }\n      }\n\n      changes.push(current); // TODO use median package\n\n      info.medianChange = changes.sort((a, b) => a - b)[Math.floor(changes.length / 2)];\n      info.positiveRoiIDs = Object.keys(positives);\n      info.negativeRoiIDs = Object.keys(negatives);\n      info.positiveRoi = info.positiveRoiIDs.length;\n      info.negativeRoi = info.negativeRoiIDs.length;\n    }\n\n    return rowsInfo;\n  }\n\n  colsInfo() {\n    let colsInfo = new Array(this.width);\n    let currentCol = 0;\n\n    for (let i = 0; i < this.width; i++) {\n      let info = {\n        col: currentCol,\n        positivePixel: 0,\n        negativePixel: 0,\n        zeroPixel: 0,\n        positiveRoi: 0,\n        negativeRoi: 0,\n        medianChange: 0\n      };\n      colsInfo[currentCol++] = info;\n      let positives = {};\n      let negatives = {};\n      let changes = [];\n      let previous = this.data[i];\n      let current = 0;\n\n      for (let j = i; j < i + this.data.length; j += this.width) {\n        let value = this.data[j];\n\n        if (previous !== value) {\n          previous = value;\n          changes.push(current);\n          current = 0;\n        }\n\n        current++;\n\n        if (value > 0) {\n          info.positivePixel++;\n\n          if (!positives[value]) {\n            positives[value] = true;\n          }\n        } else if (value < 0) {\n          info.negativePixel++;\n\n          if (!negatives[value]) {\n            negatives[value] = true;\n          }\n        } else {\n          info.zeroPixel++;\n        }\n      }\n\n      changes.push(current); // TODO use median package\n\n      info.medianChange = changes.sort((a, b) => a - b)[Math.floor(changes.length / 2)];\n      info.positiveRoiIDs = Object.keys(positives);\n      info.negativeRoiIDs = Object.keys(negatives);\n      info.positiveRoi = info.positiveRoiIDs.length;\n      info.negativeRoi = info.negativeRoiIDs.length;\n    }\n\n    return colsInfo;\n  }\n\n}","map":{"version":3,"sources":["C:/Users/kuent/Documents/FinishDipshit/Creative/Ocean-Weather-Visualization/node_modules/image-js/src/image/roi/RoiMap.js"],"names":["commonBorderLength","mergeRoi","RoiMap","constructor","parent","data","width","height","negative","positive","total","minMax","min","Number","MAX_SAFE_INTEGER","max","MIN_SAFE_INTEGER","i","length","options","call","mergeRois","rois","first","others","slice","includes","rowsInfo","Array","currentRow","info","row","positivePixel","negativePixel","zeroPixel","positiveRoi","negativeRoi","medianChange","positives","negatives","changes","previous","current","j","value","push","sort","a","b","Math","floor","positiveRoiIDs","Object","keys","negativeRoiIDs","colsInfo","currentCol","col"],"mappings":"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","sourcesContent":["/**\n * The roiMap is an array of the size of the original image data that contains\n * positive and negative numbers. When the number is common, it corresponds\n * to one region of interest (ROI)\n *\n * @class RoiMap\n * @private\n */\nimport commonBorderLength from './util/commonBorderLength';\nimport mergeRoi from './util/mergeRoi';\n\nexport default class RoiMap {\n  constructor(parent, data) {\n    this.parent = parent;\n    this.width = parent.width;\n    this.height = parent.height;\n    this.data = data;\n    this.negative = 0;\n    this.positive = 0;\n  }\n\n  get total() {\n    return this.negative + this.positive;\n  }\n\n  get minMax() {\n    let min = Number.MAX_SAFE_INTEGER;\n    let max = Number.MIN_SAFE_INTEGER;\n    for (let i = 0; i < this.data.length; i++) {\n      if (this.data[i] < min) min = this.data[i];\n      if (this.data[i] > max) max = this.data[i];\n    }\n    return { min, max };\n  }\n\n  get commonBorderLength() {\n    return commonBorderLength(this);\n  }\n\n  mergeRoi(options = {}) {\n    return mergeRoi.call(this, options);\n  }\n\n  mergeRois(rois) {\n    const first = rois[0];\n    const others = rois.slice(1);\n    for (let i = 0; i < this.data.length; i++) {\n      if (others.includes(this.data[i])) {\n        this.data[i] = first;\n      }\n    }\n  }\n\n  rowsInfo() {\n    let rowsInfo = new Array(this.height);\n    let currentRow = 0;\n    for (let i = 0; i < this.data.length; i += this.width) {\n      let info = {\n        row: currentRow,\n        positivePixel: 0,\n        negativePixel: 0,\n        zeroPixel: 0,\n        positiveRoi: 0,\n        negativeRoi: 0,\n        medianChange: 0,\n      };\n      rowsInfo[currentRow++] = info;\n      let positives = {};\n      let negatives = {};\n      let changes = [];\n      let previous = this.data[i];\n      let current = 0;\n      for (let j = i; j < i + this.width; j++) {\n        let value = this.data[j];\n        if (previous !== value) {\n          previous = value;\n          changes.push(current);\n          current = 0;\n        }\n        current++;\n        if (value > 0) {\n          info.positivePixel++;\n          if (!positives[value]) {\n            positives[value] = true;\n          }\n        } else if (value < 0) {\n          info.negativePixel++;\n          if (!negatives[value]) {\n            negatives[value] = true;\n          }\n        } else {\n          info.zeroPixel++;\n        }\n      }\n      changes.push(current);\n      // TODO use median package\n      info.medianChange = changes.sort((a, b) => a - b)[\n        Math.floor(changes.length / 2)\n      ];\n      info.positiveRoiIDs = Object.keys(positives);\n      info.negativeRoiIDs = Object.keys(negatives);\n      info.positiveRoi = info.positiveRoiIDs.length;\n      info.negativeRoi = info.negativeRoiIDs.length;\n    }\n    return rowsInfo;\n  }\n\n  colsInfo() {\n    let colsInfo = new Array(this.width);\n    let currentCol = 0;\n    for (let i = 0; i < this.width; i++) {\n      let info = {\n        col: currentCol,\n        positivePixel: 0,\n        negativePixel: 0,\n        zeroPixel: 0,\n        positiveRoi: 0,\n        negativeRoi: 0,\n        medianChange: 0,\n      };\n      colsInfo[currentCol++] = info;\n      let positives = {};\n      let negatives = {};\n      let changes = [];\n      let previous = this.data[i];\n      let current = 0;\n      for (let j = i; j < i + this.data.length; j += this.width) {\n        let value = this.data[j];\n        if (previous !== value) {\n          previous = value;\n          changes.push(current);\n          current = 0;\n        }\n        current++;\n        if (value > 0) {\n          info.positivePixel++;\n          if (!positives[value]) {\n            positives[value] = true;\n          }\n        } else if (value < 0) {\n          info.negativePixel++;\n          if (!negatives[value]) {\n            negatives[value] = true;\n          }\n        } else {\n          info.zeroPixel++;\n        }\n      }\n      changes.push(current);\n      // TODO use median package\n      info.medianChange = changes.sort((a, b) => a - b)[\n        Math.floor(changes.length / 2)\n      ];\n      info.positiveRoiIDs = Object.keys(positives);\n      info.negativeRoiIDs = Object.keys(negatives);\n      info.positiveRoi = info.positiveRoiIDs.length;\n      info.negativeRoi = info.negativeRoiIDs.length;\n    }\n    return colsInfo;\n  }\n}\n"]},"metadata":{},"sourceType":"module"}