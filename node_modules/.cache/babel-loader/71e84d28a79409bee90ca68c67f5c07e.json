{"ast":null,"code":"'use strict';\n/**\n * @class DisjointSet\n */\n\nclass DisjointSet {\n  constructor() {\n    this.nodes = new Map();\n  }\n  /**\n   * Adds an element as a new set\n   * @param {*} value\n   * @return {DisjointSetNode} Object holding the element\n   */\n\n\n  add(value) {\n    var node = this.nodes.get(value);\n\n    if (!node) {\n      node = new DisjointSetNode(value);\n      this.nodes.set(value, node);\n    }\n\n    return node;\n  }\n  /**\n   * Merges the sets that contain x and y\n   * @param {DisjointSetNode} x\n   * @param {DisjointSetNode} y\n   */\n\n\n  union(x, y) {\n    const rootX = this.find(x);\n    const rootY = this.find(y);\n\n    if (rootX === rootY) {\n      return;\n    }\n\n    if (rootX.rank < rootY.rank) {\n      rootX.parent = rootY;\n    } else if (rootX.rank > rootY.rank) {\n      rootY.parent = rootX;\n    } else {\n      rootY.parent = rootX;\n      rootX.rank++;\n    }\n  }\n  /**\n   * Finds and returns the root node of the set that contains node\n   * @param {DisjointSetNode} node\n   * @return {DisjointSetNode}\n   */\n\n\n  find(node) {\n    var rootX = node;\n\n    while (rootX.parent !== null) {\n      rootX = rootX.parent;\n    }\n\n    var toUpdateX = node;\n\n    while (toUpdateX.parent !== null) {\n      var toUpdateParent = toUpdateX;\n      toUpdateX = toUpdateX.parent;\n      toUpdateParent.parent = rootX;\n    }\n\n    return rootX;\n  }\n  /**\n   * Returns true if x and y belong to the same set\n   * @param {DisjointSetNode} x\n   * @param {DisjointSetNode} y\n   */\n\n\n  connected(x, y) {\n    return this.find(x) === this.find(y);\n  }\n\n}\n\nmodule.exports = DisjointSet;\n\nfunction DisjointSetNode(value) {\n  this.value = value;\n  this.parent = null;\n  this.rank = 0;\n}","map":{"version":3,"sources":["C:/Users/kuent/Documents/FinishDipshit/Creative/Ocean-Weather-Visualization/node_modules/ml-disjoint-set/src/DisjointSet.js"],"names":["DisjointSet","constructor","nodes","Map","add","value","node","get","DisjointSetNode","set","union","x","y","rootX","find","rootY","rank","parent","toUpdateX","toUpdateParent","connected","module","exports"],"mappings":"AAAA;AAEA;;;;AAGA,MAAMA,WAAN,CAAkB;AACdC,EAAAA,WAAW,GAAG;AACV,SAAKC,KAAL,GAAa,IAAIC,GAAJ,EAAb;AACH;AAED;;;;;;;AAKAC,EAAAA,GAAG,CAACC,KAAD,EAAQ;AACP,QAAIC,IAAI,GAAG,KAAKJ,KAAL,CAAWK,GAAX,CAAeF,KAAf,CAAX;;AACA,QAAI,CAACC,IAAL,EAAW;AACPA,MAAAA,IAAI,GAAG,IAAIE,eAAJ,CAAoBH,KAApB,CAAP;AACA,WAAKH,KAAL,CAAWO,GAAX,CAAeJ,KAAf,EAAsBC,IAAtB;AACH;;AACD,WAAOA,IAAP;AACH;AAED;;;;;;;AAKAI,EAAAA,KAAK,CAACC,CAAD,EAAIC,CAAJ,EAAO;AACR,UAAMC,KAAK,GAAG,KAAKC,IAAL,CAAUH,CAAV,CAAd;AACA,UAAMI,KAAK,GAAG,KAAKD,IAAL,CAAUF,CAAV,CAAd;;AACA,QAAIC,KAAK,KAAKE,KAAd,EAAqB;AACjB;AACH;;AACD,QAAIF,KAAK,CAACG,IAAN,GAAaD,KAAK,CAACC,IAAvB,EAA6B;AACzBH,MAAAA,KAAK,CAACI,MAAN,GAAeF,KAAf;AACH,KAFD,MAEO,IAAIF,KAAK,CAACG,IAAN,GAAaD,KAAK,CAACC,IAAvB,EAA6B;AAChCD,MAAAA,KAAK,CAACE,MAAN,GAAeJ,KAAf;AACH,KAFM,MAEA;AACHE,MAAAA,KAAK,CAACE,MAAN,GAAeJ,KAAf;AACAA,MAAAA,KAAK,CAACG,IAAN;AACH;AACJ;AAED;;;;;;;AAKAF,EAAAA,IAAI,CAACR,IAAD,EAAO;AACP,QAAIO,KAAK,GAAGP,IAAZ;;AACA,WAAOO,KAAK,CAACI,MAAN,KAAiB,IAAxB,EAA8B;AAC1BJ,MAAAA,KAAK,GAAGA,KAAK,CAACI,MAAd;AACH;;AACD,QAAIC,SAAS,GAAGZ,IAAhB;;AACA,WAAOY,SAAS,CAACD,MAAV,KAAqB,IAA5B,EAAkC;AAC9B,UAAIE,cAAc,GAAGD,SAArB;AACAA,MAAAA,SAAS,GAAGA,SAAS,CAACD,MAAtB;AACAE,MAAAA,cAAc,CAACF,MAAf,GAAwBJ,KAAxB;AACH;;AACD,WAAOA,KAAP;AACH;AAED;;;;;;;AAKAO,EAAAA,SAAS,CAACT,CAAD,EAAIC,CAAJ,EAAO;AACZ,WAAO,KAAKE,IAAL,CAAUH,CAAV,MAAiB,KAAKG,IAAL,CAAUF,CAAV,CAAxB;AACH;;AAlEa;;AAqElBS,MAAM,CAACC,OAAP,GAAiBtB,WAAjB;;AAEA,SAASQ,eAAT,CAAyBH,KAAzB,EAAgC;AAC5B,OAAKA,KAAL,GAAaA,KAAb;AACA,OAAKY,MAAL,GAAc,IAAd;AACA,OAAKD,IAAL,GAAY,CAAZ;AACH","sourcesContent":["'use strict';\n\n/**\n * @class DisjointSet\n */\nclass DisjointSet {\n    constructor() {\n        this.nodes = new Map();\n    }\n\n    /**\n     * Adds an element as a new set\n     * @param {*} value\n     * @return {DisjointSetNode} Object holding the element\n     */\n    add(value) {\n        var node = this.nodes.get(value);\n        if (!node) {\n            node = new DisjointSetNode(value);\n            this.nodes.set(value, node);\n        }\n        return node;\n    }\n\n    /**\n     * Merges the sets that contain x and y\n     * @param {DisjointSetNode} x\n     * @param {DisjointSetNode} y\n     */\n    union(x, y) {\n        const rootX = this.find(x);\n        const rootY = this.find(y);\n        if (rootX === rootY) {\n            return;\n        }\n        if (rootX.rank < rootY.rank) {\n            rootX.parent = rootY;\n        } else if (rootX.rank > rootY.rank) {\n            rootY.parent = rootX;\n        } else {\n            rootY.parent = rootX;\n            rootX.rank++;\n        }\n    }\n\n    /**\n     * Finds and returns the root node of the set that contains node\n     * @param {DisjointSetNode} node\n     * @return {DisjointSetNode}\n     */\n    find(node) {\n        var rootX = node;\n        while (rootX.parent !== null) {\n            rootX = rootX.parent;\n        }\n        var toUpdateX = node;\n        while (toUpdateX.parent !== null) {\n            var toUpdateParent = toUpdateX;\n            toUpdateX = toUpdateX.parent;\n            toUpdateParent.parent = rootX;\n        }\n        return rootX;\n    }\n\n    /**\n     * Returns true if x and y belong to the same set\n     * @param {DisjointSetNode} x\n     * @param {DisjointSetNode} y\n     */\n    connected(x, y) {\n        return this.find(x) === this.find(y);\n    }\n}\n\nmodule.exports = DisjointSet;\n\nfunction DisjointSetNode(value) {\n    this.value = value;\n    this.parent = null;\n    this.rank = 0;\n}\n"]},"metadata":{},"sourceType":"script"}