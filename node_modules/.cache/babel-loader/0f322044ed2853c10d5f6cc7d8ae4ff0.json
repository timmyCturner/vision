{"ast":null,"code":"/**\n * Computes the convex hull of a binary image using Andrew's Monotone Chain Algorithm\n * http://www.algorithmist.com/index.php/Monotone_Chain_Convex_Hull\n * @param {Array<Array<number>>} points - An array of points (two elements arrays)\n * @param {object} [options]\n * @param {boolean} [options.sorted=false]\n * @return {Array<Array<number>>} Coordinates of the convex hull in clockwise order\n */\nexport default function monotoneChainConvexHull(points, options = {}) {\n  if (!options.sorted) {\n    points.sort(byXThenY);\n  }\n\n  const n = points.length;\n  const result = new Array(n * 2);\n  var k = 0;\n\n  for (var i = 0; i < n; i++) {\n    const point = points[i];\n\n    while (k >= 2 && cw(result[k - 2], result[k - 1], point) <= 0) {\n      k--;\n    }\n\n    result[k++] = point;\n  }\n\n  const t = k + 1;\n\n  for (i = n - 2; i >= 0; i--) {\n    const point = points[i];\n\n    while (k >= t && cw(result[k - 2], result[k - 1], point) <= 0) {\n      k--;\n    }\n\n    result[k++] = point;\n  }\n\n  return result.slice(0, k - 1);\n}\n\nfunction cw(p1, p2, p3) {\n  return (p2[1] - p1[1]) * (p3[0] - p1[0]) - (p2[0] - p1[0]) * (p3[1] - p1[1]);\n}\n\nfunction byXThenY(point1, point2) {\n  if (point1[0] === point2[0]) {\n    return point1[1] - point2[1];\n  }\n\n  return point1[0] - point2[0];\n}","map":{"version":3,"sources":["C:/Users/kuent/Documents/FinishDipshit/Creative/Ocean-Weather-Visualization/node_modules/monotone-chain-convex-hull/src/index.js"],"names":["monotoneChainConvexHull","points","options","sorted","sort","byXThenY","n","length","result","Array","k","i","point","cw","t","slice","p1","p2","p3","point1","point2"],"mappings":"AAAA;;;;;;;;AAQA,eAAe,SAASA,uBAAT,CAAiCC,MAAjC,EAAyCC,OAAO,GAAG,EAAnD,EAAuD;AAClE,MAAI,CAACA,OAAO,CAACC,MAAb,EAAqB;AACjBF,IAAAA,MAAM,CAACG,IAAP,CAAYC,QAAZ;AACH;;AAED,QAAMC,CAAC,GAAGL,MAAM,CAACM,MAAjB;AACA,QAAMC,MAAM,GAAG,IAAIC,KAAJ,CAAUH,CAAC,GAAG,CAAd,CAAf;AACA,MAAII,CAAC,GAAG,CAAR;;AAEA,OAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGL,CAApB,EAAuBK,CAAC,EAAxB,EAA4B;AACxB,UAAMC,KAAK,GAAGX,MAAM,CAACU,CAAD,CAApB;;AACA,WAAOD,CAAC,IAAI,CAAL,IAAUG,EAAE,CAACL,MAAM,CAACE,CAAC,GAAG,CAAL,CAAP,EAAgBF,MAAM,CAACE,CAAC,GAAG,CAAL,CAAtB,EAA+BE,KAA/B,CAAF,IAA2C,CAA5D,EAA+D;AAC3DF,MAAAA,CAAC;AACJ;;AACDF,IAAAA,MAAM,CAACE,CAAC,EAAF,CAAN,GAAcE,KAAd;AACH;;AAED,QAAME,CAAC,GAAGJ,CAAC,GAAG,CAAd;;AACA,OAAKC,CAAC,GAAGL,CAAC,GAAG,CAAb,EAAgBK,CAAC,IAAI,CAArB,EAAwBA,CAAC,EAAzB,EAA6B;AACzB,UAAMC,KAAK,GAAGX,MAAM,CAACU,CAAD,CAApB;;AACA,WAAOD,CAAC,IAAII,CAAL,IAAUD,EAAE,CAACL,MAAM,CAACE,CAAC,GAAG,CAAL,CAAP,EAAgBF,MAAM,CAACE,CAAC,GAAG,CAAL,CAAtB,EAA+BE,KAA/B,CAAF,IAA2C,CAA5D,EAA+D;AAC3DF,MAAAA,CAAC;AACJ;;AACDF,IAAAA,MAAM,CAACE,CAAC,EAAF,CAAN,GAAcE,KAAd;AACH;;AAED,SAAOJ,MAAM,CAACO,KAAP,CAAa,CAAb,EAAgBL,CAAC,GAAG,CAApB,CAAP;AACH;;AAED,SAASG,EAAT,CAAYG,EAAZ,EAAgBC,EAAhB,EAAoBC,EAApB,EAAwB;AACpB,SAAO,CAACD,EAAE,CAAC,CAAD,CAAF,GAAQD,EAAE,CAAC,CAAD,CAAX,KAAmBE,EAAE,CAAC,CAAD,CAAF,GAAQF,EAAE,CAAC,CAAD,CAA7B,IAAoC,CAACC,EAAE,CAAC,CAAD,CAAF,GAAQD,EAAE,CAAC,CAAD,CAAX,KAAmBE,EAAE,CAAC,CAAD,CAAF,GAAQF,EAAE,CAAC,CAAD,CAA7B,CAA3C;AACH;;AAED,SAASX,QAAT,CAAkBc,MAAlB,EAA0BC,MAA1B,EAAkC;AAC9B,MAAID,MAAM,CAAC,CAAD,CAAN,KAAcC,MAAM,CAAC,CAAD,CAAxB,EAA6B;AACzB,WAAOD,MAAM,CAAC,CAAD,CAAN,GAAYC,MAAM,CAAC,CAAD,CAAzB;AACH;;AACD,SAAOD,MAAM,CAAC,CAAD,CAAN,GAAYC,MAAM,CAAC,CAAD,CAAzB;AACH","sourcesContent":["/**\n * Computes the convex hull of a binary image using Andrew's Monotone Chain Algorithm\n * http://www.algorithmist.com/index.php/Monotone_Chain_Convex_Hull\n * @param {Array<Array<number>>} points - An array of points (two elements arrays)\n * @param {object} [options]\n * @param {boolean} [options.sorted=false]\n * @return {Array<Array<number>>} Coordinates of the convex hull in clockwise order\n */\nexport default function monotoneChainConvexHull(points, options = {}) {\n    if (!options.sorted) {\n        points.sort(byXThenY);\n    }\n\n    const n = points.length;\n    const result = new Array(n * 2);\n    var k = 0;\n\n    for (var i = 0; i < n; i++) {\n        const point = points[i];\n        while (k >= 2 && cw(result[k - 2], result[k - 1], point) <= 0) {\n            k--;\n        }\n        result[k++] = point;\n    }\n\n    const t = k + 1;\n    for (i = n - 2; i >= 0; i--) {\n        const point = points[i];\n        while (k >= t && cw(result[k - 2], result[k - 1], point) <= 0) {\n            k--;\n        }\n        result[k++] = point;\n    }\n\n    return result.slice(0, k - 1);\n}\n\nfunction cw(p1, p2, p3) {\n    return (p2[1] - p1[1]) * (p3[0] - p1[0]) - (p2[0] - p1[0]) * (p3[1] - p1[1]);\n}\n\nfunction byXThenY(point1, point2) {\n    if (point1[0] === point2[0]) {\n        return point1[1] - point2[1];\n    }\n    return point1[0] - point2[0];\n}\n"]},"metadata":{},"sourceType":"module"}