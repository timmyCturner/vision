{"ast":null,"code":"import Image from '../Image';\n/**\n * Erosion is one of two fundamental operations (with dilatation) in morphological\n * image processing from which all other morphological operations are based (from Wikipedia).\n * Replaces each value with it's local minimum among the pixels with a kernel value of 1.\n * http://docs.opencv.org/2.4/doc/tutorials/imgproc/erosion_dilatation/erosion_dilatation.html\n * https://en.wikipedia.org/wiki/Erosion_(morphology)\n * @memberof Image\n * @instance\n * @param {object} [options]\n * @param {Array<Array<number>>} [options.kernel] - The kernel can only have ones and zeros. Default: [[1, 1, 1], [1, 1, 1], [1, 1, 1]]\n * @param {number} [options.iterations=1] - The number of successive erosions\n * @return {Image}\n */\n\nexport default function erode(options = {}) {\n  let {\n    kernel = [[1, 1, 1], [1, 1, 1], [1, 1, 1]],\n    iterations = 1\n  } = options;\n  this.checkProcessable('erode', {\n    bitDepth: [1, 8, 16],\n    components: 1,\n    alpha: 0\n  });\n\n  if (kernel.columns % 2 === 0 || kernel.rows % 2 === 0) {\n    throw new TypeError('erode: The number of rows and columns of the kernel must be odd');\n  }\n\n  let onlyOnes = true;\n\n  outer: for (const row of kernel) {\n    for (const value of row) {\n      if (value !== 1) {\n        onlyOnes = false;\n        break outer;\n      }\n    }\n  }\n\n  let result = this;\n\n  for (let i = 0; i < iterations; i++) {\n    if (this.bitDepth === 1) {\n      if (onlyOnes) {\n        const newImage = result.clone();\n        result = erodeOnceBinaryOnlyOnes(result, newImage, kernel.length, kernel[0].length);\n      } else {\n        const newImage = Image.createFrom(result);\n        result = erodeOnceBinary(result, newImage, kernel);\n      }\n    } else if (onlyOnes) {\n      const newImage = Image.createFrom(result);\n      result = erodeOnceGreyOnlyOnes(result, newImage, kernel.length, kernel[0].length);\n    } else {\n      const newImage = Image.createFrom(result);\n      result = erodeOnceGrey(result, newImage, kernel);\n    }\n  }\n\n  return result;\n}\n\nfunction erodeOnceGrey(img, newImage, kernel) {\n  const kernelWidth = kernel.length;\n  const kernelHeight = kernel[0].length;\n  let radiusX = (kernelWidth - 1) / 2;\n  let radiusY = (kernelHeight - 1) / 2;\n\n  for (let y = 0; y < img.height; y++) {\n    for (let x = 0; x < img.width; x++) {\n      let min = img.maxValue;\n\n      for (let jj = 0; jj < kernelHeight; jj++) {\n        for (let ii = 0; ii < kernelWidth; ii++) {\n          if (kernel[ii][jj] !== 1) continue;\n          let i = ii - radiusX + x;\n          let j = jj - radiusY + y;\n          if (i < 0 || j < 0 || i >= img.width || j >= img.height) continue;\n          const value = img.getValueXY(i, j, 0);\n          if (value < min) min = value;\n        }\n      }\n\n      newImage.setValueXY(x, y, 0, min);\n    }\n  }\n\n  return newImage;\n}\n\nfunction erodeOnceGreyOnlyOnes(img, newImage, kernelWidth, kernelHeight) {\n  const radiusX = (kernelWidth - 1) / 2;\n  const radiusY = (kernelHeight - 1) / 2;\n  const minList = [];\n\n  for (let x = 0; x < img.width; x++) {\n    minList.push(0);\n  }\n\n  for (let y = 0; y < img.height; y++) {\n    for (let x = 0; x < img.width; x++) {\n      let min = img.maxValue;\n\n      for (let h = Math.max(0, y - radiusY); h < Math.min(img.height, y + radiusY + 1); h++) {\n        const value = img.getValueXY(x, h, 0);\n\n        if (value < min) {\n          min = value;\n        }\n      }\n\n      minList[x] = min;\n    }\n\n    for (let x = 0; x < img.width; x++) {\n      let min = img.maxValue;\n\n      for (let i = Math.max(0, x - radiusX); i < Math.min(img.width, x + radiusX + 1); i++) {\n        if (minList[i] < min) {\n          min = minList[i];\n        }\n      }\n\n      newImage.setValueXY(x, y, 0, min);\n    }\n  }\n\n  return newImage;\n}\n\nfunction erodeOnceBinary(img, newImage, kernel) {\n  const kernelWidth = kernel.length;\n  const kernelHeight = kernel[0].length;\n  let radiusX = (kernelWidth - 1) / 2;\n  let radiusY = (kernelHeight - 1) / 2;\n\n  for (let y = 0; y < img.height; y++) {\n    for (let x = 0; x < img.width; x++) {\n      let min = 1;\n\n      intLoop: for (let jj = 0; jj < kernelHeight; jj++) {\n        for (let ii = 0; ii < kernelWidth; ii++) {\n          if (kernel[ii][jj] !== 1) continue;\n          let i = ii - radiusX + x;\n          let j = jj - radiusY + y;\n          if (j < 0 || i < 0 || i >= img.width || j >= img.height) continue;\n          const value = img.getBitXY(i, j);\n\n          if (value === 0) {\n            min = 0;\n            break intLoop;\n          }\n        }\n      }\n\n      if (min === 1) {\n        newImage.setBitXY(x, y);\n      }\n    }\n  }\n\n  return newImage;\n}\n\nfunction erodeOnceBinaryOnlyOnes(img, newImage, kernelWidth, kernelHeight) {\n  const radiusX = (kernelWidth - 1) / 2;\n  const radiusY = (kernelHeight - 1) / 2;\n  const minList = [];\n\n  for (let x = 0; x < img.width; x++) {\n    minList.push(0);\n  }\n\n  for (let y = 0; y < img.height; y++) {\n    for (let x = 0; x < img.width; x++) {\n      minList[x] = 1;\n\n      for (let h = Math.max(0, y - radiusY); h < Math.min(img.height, y + radiusY + 1); h++) {\n        if (img.getBitXY(x, h) === 0) {\n          minList[x] = 0;\n          break;\n        }\n      }\n    }\n\n    for (let x = 0; x < img.width; x++) {\n      if (newImage.getBitXY(x, y) === 0) continue;\n\n      for (let i = Math.max(0, x - radiusX); i < Math.min(img.width, x + radiusX + 1); i++) {\n        if (minList[i] === 0) {\n          newImage.clearBitXY(x, y);\n          break;\n        }\n      }\n    }\n  }\n\n  return newImage;\n}","map":{"version":3,"sources":["C:/Users/kuent/Documents/FinishDipshit/Creative/Ocean-Weather-Visualization/node_modules/image-js/src/image/morphology/erode.js"],"names":["Image","erode","options","kernel","iterations","checkProcessable","bitDepth","components","alpha","columns","rows","TypeError","onlyOnes","outer","row","value","result","i","newImage","clone","erodeOnceBinaryOnlyOnes","length","createFrom","erodeOnceBinary","erodeOnceGreyOnlyOnes","erodeOnceGrey","img","kernelWidth","kernelHeight","radiusX","radiusY","y","height","x","width","min","maxValue","jj","ii","j","getValueXY","setValueXY","minList","push","h","Math","max","intLoop","getBitXY","setBitXY","clearBitXY"],"mappings":"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","sourcesContent":["import Image from '../Image';\n\n/**\n * Erosion is one of two fundamental operations (with dilatation) in morphological\n * image processing from which all other morphological operations are based (from Wikipedia).\n * Replaces each value with it's local minimum among the pixels with a kernel value of 1.\n * http://docs.opencv.org/2.4/doc/tutorials/imgproc/erosion_dilatation/erosion_dilatation.html\n * https://en.wikipedia.org/wiki/Erosion_(morphology)\n * @memberof Image\n * @instance\n * @param {object} [options]\n * @param {Array<Array<number>>} [options.kernel] - The kernel can only have ones and zeros. Default: [[1, 1, 1], [1, 1, 1], [1, 1, 1]]\n * @param {number} [options.iterations=1] - The number of successive erosions\n * @return {Image}\n */\nexport default function erode(options = {}) {\n  let {\n    kernel = [\n      [1, 1, 1],\n      [1, 1, 1],\n      [1, 1, 1],\n    ],\n    iterations = 1,\n  } = options;\n\n  this.checkProcessable('erode', {\n    bitDepth: [1, 8, 16],\n    components: 1,\n    alpha: 0,\n  });\n  if (kernel.columns % 2 === 0 || kernel.rows % 2 === 0) {\n    throw new TypeError(\n      'erode: The number of rows and columns of the kernel must be odd',\n    );\n  }\n\n  let onlyOnes = true;\n  outer: for (const row of kernel) {\n    for (const value of row) {\n      if (value !== 1) {\n        onlyOnes = false;\n        break outer;\n      }\n    }\n  }\n\n  let result = this;\n  for (let i = 0; i < iterations; i++) {\n    if (this.bitDepth === 1) {\n      if (onlyOnes) {\n        const newImage = result.clone();\n        result = erodeOnceBinaryOnlyOnes(\n          result,\n          newImage,\n          kernel.length,\n          kernel[0].length,\n        );\n      } else {\n        const newImage = Image.createFrom(result);\n        result = erodeOnceBinary(result, newImage, kernel);\n      }\n    } else if (onlyOnes) {\n      const newImage = Image.createFrom(result);\n      result = erodeOnceGreyOnlyOnes(\n        result,\n        newImage,\n        kernel.length,\n        kernel[0].length,\n      );\n    } else {\n      const newImage = Image.createFrom(result);\n      result = erodeOnceGrey(result, newImage, kernel);\n    }\n  }\n  return result;\n}\n\nfunction erodeOnceGrey(img, newImage, kernel) {\n  const kernelWidth = kernel.length;\n  const kernelHeight = kernel[0].length;\n  let radiusX = (kernelWidth - 1) / 2;\n  let radiusY = (kernelHeight - 1) / 2;\n  for (let y = 0; y < img.height; y++) {\n    for (let x = 0; x < img.width; x++) {\n      let min = img.maxValue;\n      for (let jj = 0; jj < kernelHeight; jj++) {\n        for (let ii = 0; ii < kernelWidth; ii++) {\n          if (kernel[ii][jj] !== 1) continue;\n          let i = ii - radiusX + x;\n          let j = jj - radiusY + y;\n          if (i < 0 || j < 0 || i >= img.width || j >= img.height) continue;\n          const value = img.getValueXY(i, j, 0);\n          if (value < min) min = value;\n        }\n      }\n      newImage.setValueXY(x, y, 0, min);\n    }\n  }\n  return newImage;\n}\n\nfunction erodeOnceGreyOnlyOnes(img, newImage, kernelWidth, kernelHeight) {\n  const radiusX = (kernelWidth - 1) / 2;\n  const radiusY = (kernelHeight - 1) / 2;\n\n  const minList = [];\n  for (let x = 0; x < img.width; x++) {\n    minList.push(0);\n  }\n\n  for (let y = 0; y < img.height; y++) {\n    for (let x = 0; x < img.width; x++) {\n      let min = img.maxValue;\n      for (\n        let h = Math.max(0, y - radiusY);\n        h < Math.min(img.height, y + radiusY + 1);\n        h++\n      ) {\n        const value = img.getValueXY(x, h, 0);\n        if (value < min) {\n          min = value;\n        }\n      }\n      minList[x] = min;\n    }\n\n    for (let x = 0; x < img.width; x++) {\n      let min = img.maxValue;\n      for (\n        let i = Math.max(0, x - radiusX);\n        i < Math.min(img.width, x + radiusX + 1);\n        i++\n      ) {\n        if (minList[i] < min) {\n          min = minList[i];\n        }\n      }\n      newImage.setValueXY(x, y, 0, min);\n    }\n  }\n  return newImage;\n}\n\nfunction erodeOnceBinary(img, newImage, kernel) {\n  const kernelWidth = kernel.length;\n  const kernelHeight = kernel[0].length;\n  let radiusX = (kernelWidth - 1) / 2;\n  let radiusY = (kernelHeight - 1) / 2;\n  for (let y = 0; y < img.height; y++) {\n    for (let x = 0; x < img.width; x++) {\n      let min = 1;\n      intLoop: for (let jj = 0; jj < kernelHeight; jj++) {\n        for (let ii = 0; ii < kernelWidth; ii++) {\n          if (kernel[ii][jj] !== 1) continue;\n          let i = ii - radiusX + x;\n          let j = jj - radiusY + y;\n          if (j < 0 || i < 0 || i >= img.width || j >= img.height) continue;\n          const value = img.getBitXY(i, j);\n          if (value === 0) {\n            min = 0;\n            break intLoop;\n          }\n        }\n      }\n      if (min === 1) {\n        newImage.setBitXY(x, y);\n      }\n    }\n  }\n  return newImage;\n}\n\nfunction erodeOnceBinaryOnlyOnes(img, newImage, kernelWidth, kernelHeight) {\n  const radiusX = (kernelWidth - 1) / 2;\n  const radiusY = (kernelHeight - 1) / 2;\n\n  const minList = [];\n  for (let x = 0; x < img.width; x++) {\n    minList.push(0);\n  }\n\n  for (let y = 0; y < img.height; y++) {\n    for (let x = 0; x < img.width; x++) {\n      minList[x] = 1;\n      for (\n        let h = Math.max(0, y - radiusY);\n        h < Math.min(img.height, y + radiusY + 1);\n        h++\n      ) {\n        if (img.getBitXY(x, h) === 0) {\n          minList[x] = 0;\n          break;\n        }\n      }\n    }\n\n    for (let x = 0; x < img.width; x++) {\n      if (newImage.getBitXY(x, y) === 0) continue;\n      for (\n        let i = Math.max(0, x - radiusX);\n        i < Math.min(img.width, x + radiusX + 1);\n        i++\n      ) {\n        if (minList[i] === 0) {\n          newImage.clearBitXY(x, y);\n          break;\n        }\n      }\n    }\n  }\n  return newImage;\n}\n"]},"metadata":{},"sourceType":"module"}