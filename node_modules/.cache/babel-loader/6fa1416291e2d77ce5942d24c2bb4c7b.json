{"ast":null,"code":"import newArray from 'new-array';\nimport { validateArrayOfChannels } from '../../util/channel';\n/**\n * Try to match the current pictures with another one. If normalize we normalize separately the 2 images.\n * @memberof Image\n * @instance\n * @param {Image} image - Other image\n * @param {object} [options]\n * @return {number[]|number}\n */\n\nexport default function getSimilarity(image, options = {}) {\n  let {\n    shift = [0, 0],\n    average,\n    channels,\n    defaultAlpha,\n    normalize,\n    border = [0, 0]\n  } = options;\n  this.checkProcessable('getSimilarity', {\n    bitDepth: [8, 16]\n  });\n\n  if (!Array.isArray(border)) {\n    border = [border, border];\n  }\n\n  channels = validateArrayOfChannels(this, {\n    channels: channels,\n    defaultAlpha: defaultAlpha\n  });\n\n  if (this.bitDepth !== image.bitDepth) {\n    throw new Error('Both images must have the same bitDepth');\n  }\n\n  if (this.channels !== image.channels) {\n    throw new Error('Both images must have the same number of channels');\n  }\n\n  if (this.colorModel !== image.colorModel) {\n    throw new Error('Both images must have the same colorModel');\n  }\n\n  if (typeof average === 'undefined') {\n    average = true;\n  } // we allow a shift\n  // we need to find the minX, maxX, minY, maxY\n\n\n  let minX = Math.max(border[0], -shift[0]);\n  let maxX = Math.min(this.width - border[0], this.width - shift[0]);\n  let minY = Math.max(border[1], -shift[1]);\n  let maxY = Math.min(this.height - border[1], this.height - shift[1]);\n  let results = newArray(channels.length, 0);\n\n  for (let i = 0; i < channels.length; i++) {\n    let c = channels[i];\n    let sumThis = normalize ? this.sum[c] : Math.max(this.sum[c], image.sum[c]);\n    let sumImage = normalize ? image.sum[c] : Math.max(this.sum[c], image.sum[c]);\n\n    if (sumThis !== 0 && sumImage !== 0) {\n      for (let x = minX; x < maxX; x++) {\n        for (let y = minY; y < maxY; y++) {\n          let indexThis = x * this.multiplierX + y * this.multiplierY + c;\n          let indexImage = indexThis + shift[0] * this.multiplierX + shift[1] * this.multiplierY;\n          results[i] += Math.min(this.data[indexThis] / sumThis, image.data[indexImage] / sumImage);\n        }\n      }\n    }\n  }\n\n  if (average) {\n    return results.reduce((sum, x) => sum + x) / results.length;\n  }\n\n  return results;\n}","map":{"version":3,"sources":["C:/Users/kuent/Documents/FinishDipshit/Creative/Ocean-Weather-Visualization/node_modules/image-js/src/image/utility/getSimilarity.js"],"names":["newArray","validateArrayOfChannels","getSimilarity","image","options","shift","average","channels","defaultAlpha","normalize","border","checkProcessable","bitDepth","Array","isArray","Error","colorModel","minX","Math","max","maxX","min","width","minY","maxY","height","results","length","i","c","sumThis","sum","sumImage","x","y","indexThis","multiplierX","multiplierY","indexImage","data","reduce"],"mappings":"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","sourcesContent":["import newArray from 'new-array';\n\nimport { validateArrayOfChannels } from '../../util/channel';\n\n/**\n * Try to match the current pictures with another one. If normalize we normalize separately the 2 images.\n * @memberof Image\n * @instance\n * @param {Image} image - Other image\n * @param {object} [options]\n * @return {number[]|number}\n */\nexport default function getSimilarity(image, options = {}) {\n  let {\n    shift = [0, 0],\n    average,\n    channels,\n    defaultAlpha,\n    normalize,\n    border = [0, 0],\n  } = options;\n\n  this.checkProcessable('getSimilarity', {\n    bitDepth: [8, 16],\n  });\n\n  if (!Array.isArray(border)) {\n    border = [border, border];\n  }\n  channels = validateArrayOfChannels(this, {\n    channels: channels,\n    defaultAlpha: defaultAlpha,\n  });\n\n  if (this.bitDepth !== image.bitDepth) {\n    throw new Error('Both images must have the same bitDepth');\n  }\n  if (this.channels !== image.channels) {\n    throw new Error('Both images must have the same number of channels');\n  }\n  if (this.colorModel !== image.colorModel) {\n    throw new Error('Both images must have the same colorModel');\n  }\n\n  if (typeof average === 'undefined') {\n    average = true;\n  }\n\n  // we allow a shift\n  // we need to find the minX, maxX, minY, maxY\n  let minX = Math.max(border[0], -shift[0]);\n  let maxX = Math.min(this.width - border[0], this.width - shift[0]);\n  let minY = Math.max(border[1], -shift[1]);\n  let maxY = Math.min(this.height - border[1], this.height - shift[1]);\n\n  let results = newArray(channels.length, 0);\n  for (let i = 0; i < channels.length; i++) {\n    let c = channels[i];\n    let sumThis = normalize ? this.sum[c] : Math.max(this.sum[c], image.sum[c]);\n    let sumImage = normalize\n      ? image.sum[c]\n      : Math.max(this.sum[c], image.sum[c]);\n\n    if (sumThis !== 0 && sumImage !== 0) {\n      for (let x = minX; x < maxX; x++) {\n        for (let y = minY; y < maxY; y++) {\n          let indexThis = x * this.multiplierX + y * this.multiplierY + c;\n          let indexImage =\n            indexThis +\n            shift[0] * this.multiplierX +\n            shift[1] * this.multiplierY;\n          results[i] += Math.min(\n            this.data[indexThis] / sumThis,\n            image.data[indexImage] / sumImage,\n          );\n        }\n      }\n    }\n  }\n\n  if (average) {\n    return results.reduce((sum, x) => sum + x) / results.length;\n  }\n  return results;\n}\n"]},"metadata":{},"sourceType":"module"}